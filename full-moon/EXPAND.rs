#![feature(prelude_import)]
#![warn(missing_docs)]
#![allow(clippy::large_enum_variant)]
//! # Full Moon
//!
//! `full_moon` is a lossless parser for Lua 5.1
//! Learn more by going to [the repository](https://github.com/Kampfkarren/full-moon)
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
/// Utilities for ASTs (Abstract Syntax Trees). Contains all nodes used by Full Moon (such as blocks).
pub mod ast {
    #[macro_use]
    mod parser_util {
        use super::punctuated::{Pair, Punctuated};
        use crate::{
            node::Node,
            tokenizer::TokenReference,
            visitors::{Visit, VisitMut},
        };
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        use std::{borrow::Cow, fmt};
        pub struct ParserState<'a> {
            pub index: usize,
            pub len: usize,
            pub tokens: &'a [TokenReference],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::core::clone::Clone for ParserState<'a> {
            #[inline]
            fn clone(&self) -> ParserState<'a> {
                {
                    let _: ::core::clone::AssertParamIsClone<usize>;
                    let _: ::core::clone::AssertParamIsClone<usize>;
                    let _: ::core::clone::AssertParamIsClone<&'a [TokenReference]>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::core::marker::Copy for ParserState<'a> {}
        impl<'a> ::core::marker::StructuralPartialEq for ParserState<'a> {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::core::cmp::PartialEq for ParserState<'a> {
            #[inline]
            fn eq(&self, other: &ParserState<'a>) -> bool {
                match *other {
                    ParserState {
                        index: ref __self_1_0,
                        len: ref __self_1_1,
                        tokens: ref __self_1_2,
                    } => match *self {
                        ParserState {
                            index: ref __self_0_0,
                            len: ref __self_0_1,
                            tokens: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ParserState<'a>) -> bool {
                match *other {
                    ParserState {
                        index: ref __self_1_0,
                        len: ref __self_1_1,
                        tokens: ref __self_1_2,
                    } => match *self {
                        ParserState {
                            index: ref __self_0_0,
                            len: ref __self_0_1,
                            tokens: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl<'a> ParserState<'a> {
            pub fn new(tokens: &'a [TokenReference]) -> ParserState<'a> {
                ParserState {
                    index: 0,
                    len: tokens.len(),
                    tokens,
                }
            }
            pub fn advance(self) -> Option<ParserState<'a>> {
                if self.index + 1 == self.len {
                    None
                } else {
                    Some(ParserState {
                        index: self.index + 1,
                        ..self
                    })
                }
            }
            pub fn peek(&self) -> &TokenReference {
                if self.index >= self.len {
                    {
                        ::std::rt::begin_panic("peek failed, when there should always be an eof")
                    };
                }
                self.tokens.get(self.index).expect("couldn't peek, no eof?")
            }
        }
        impl<'a> fmt::Debug for ParserState<'a> {
            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
                formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["ParserState { index: ", ", current: ", " }"],
                    &match (&self.index, &self.peek()) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                ))
            }
        }
        pub(crate) trait Parser: Sized {
            type Item;
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Self::Item), InternalAstError>;
        }
        pub enum InternalAstError {
            NoMatch,
            UnexpectedToken {
                token: TokenReference,
                additional: Option<Cow<'static, str>>,
            },
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for InternalAstError {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "variant identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "NoMatch" => _serde::export::Ok(__Field::__field0),
                                "UnexpectedToken" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"NoMatch" => _serde::export::Ok(__Field::__field0),
                                b"UnexpectedToken" => _serde::export::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::export::from_utf8_lossy(__value);
                                    _serde::export::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<InternalAstError>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = InternalAstError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "enum InternalAstError",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                    _serde::export::Ok(InternalAstError::NoMatch)
                                }
                                (__Field::__field1, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __ignore,
                                    }
                                    struct __FieldVisitor;
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::export::Formatter,
                                        ) -> _serde::export::fmt::Result
                                        {
                                            _serde::export::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::export::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::export::Ok(__Field::__field0),
                                                1u64 => _serde::export::Ok(__Field::__field1),
                                                _ => _serde::export::Err(
                                                    _serde::de::Error::invalid_value(
                                                        _serde::de::Unexpected::Unsigned(__value),
                                                        &"field index 0 <= i < 2",
                                                    ),
                                                ),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::export::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "token" => _serde::export::Ok(__Field::__field0),
                                                "additional" => {
                                                    _serde::export::Ok(__Field::__field1)
                                                }
                                                _ => _serde::export::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::export::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"token" => _serde::export::Ok(__Field::__field0),
                                                b"additional" => {
                                                    _serde::export::Ok(__Field::__field1)
                                                }
                                                _ => _serde::export::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    struct __Visitor<'de> {
                                        marker: _serde::export::PhantomData<InternalAstError>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = InternalAstError;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::export::Formatter,
                                        ) -> _serde::export::fmt::Result
                                        {
                                            _serde::export::Formatter::write_str(
                                                __formatter,
                                                "struct variant InternalAstError::UnexpectedToken",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::export::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 =
                                                match match _serde::de::SeqAccess::next_element::<
                                                    TokenReference,
                                                >(
                                                    &mut __seq
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                } {
                                                    _serde::export::Some(__value) => __value,
                                                    _serde::export::None => {
                                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant InternalAstError::UnexpectedToken with 2 elements")) ;
                                                    }
                                                };
                                            let __field1 =
                                                match match _serde::de::SeqAccess::next_element::<
                                                    Option<Cow<'static, str>>,
                                                >(
                                                    &mut __seq
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                } {
                                                    _serde::export::Some(__value) => __value,
                                                    _serde::export::None => {
                                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant InternalAstError::UnexpectedToken with 2 elements")) ;
                                                    }
                                                };
                                            _serde::export::Ok(InternalAstError::UnexpectedToken {
                                                token: __field0,
                                                additional: __field1,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::export::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::export::Option<
                                                TokenReference,
                                            > = _serde::export::None;
                                            let mut __field1: _serde::export::Option<
                                                Option<Cow<'static, str>>,
                                            > = _serde::export::None;
                                            while let _serde::export::Some(__key) =
                                                match _serde::de::MapAccess::next_key::<__Field>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::export::Option::is_some(
                                                            &__field0,
                                                        ) {
                                                            return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("token")) ;
                                                        }
                                                        __field0 = _serde::export::Some(
                                                            match _serde::de::MapAccess::next_value::<
                                                                TokenReference,
                                                            >(
                                                                &mut __map
                                                            ) {
                                                                _serde::export::Ok(__val) => __val,
                                                                _serde::export::Err(__err) => {
                                                                    return _serde::export::Err(
                                                                        __err,
                                                                    );
                                                                }
                                                            },
                                                        );
                                                    }
                                                    __Field::__field1 => {
                                                        if _serde::export::Option::is_some(
                                                            &__field1,
                                                        ) {
                                                            return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("additional")) ;
                                                        }
                                                        __field1 = _serde::export::Some(
                                                            match _serde::de::MapAccess::next_value::<
                                                                Option<Cow<'static, str>>,
                                                            >(
                                                                &mut __map
                                                            ) {
                                                                _serde::export::Ok(__val) => __val,
                                                                _serde::export::Err(__err) => {
                                                                    return _serde::export::Err(
                                                                        __err,
                                                                    );
                                                                }
                                                            },
                                                        );
                                                    }
                                                    _ => {
                                                        let _ =
                                                            match _serde::de::MapAccess::next_value::<
                                                                _serde::de::IgnoredAny,
                                                            >(
                                                                &mut __map
                                                            ) {
                                                                _serde::export::Ok(__val) => __val,
                                                                _serde::export::Err(__err) => {
                                                                    return _serde::export::Err(
                                                                        __err,
                                                                    );
                                                                }
                                                            };
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::export::Some(__field0) => __field0,
                                                _serde::export::None => {
                                                    match _serde::private::de::missing_field(
                                                        "token",
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    }
                                                }
                                            };
                                            let __field1 = match __field1 {
                                                _serde::export::Some(__field1) => __field1,
                                                _serde::export::None => {
                                                    match _serde::private::de::missing_field(
                                                        "additional",
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    }
                                                }
                                            };
                                            _serde::export::Ok(InternalAstError::UnexpectedToken {
                                                token: __field0,
                                                additional: __field1,
                                            })
                                        }
                                    }
                                    const FIELDS: &'static [&'static str] =
                                        &["token", "additional"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::export::PhantomData::<InternalAstError>,
                                            lifetime: _serde::export::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["NoMatch", "UnexpectedToken"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "InternalAstError",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<InternalAstError>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for InternalAstError {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        InternalAstError::NoMatch => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "InternalAstError",
                            0u32,
                            "NoMatch",
                        ),
                        InternalAstError::UnexpectedToken {
                            ref token,
                            ref additional,
                        } => {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_struct_variant(
                                    __serializer,
                                    "InternalAstError",
                                    1u32,
                                    "UnexpectedToken",
                                    0 + 1 + 1,
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeStructVariant::serialize_field(
                                &mut __serde_state,
                                "token",
                                token,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeStructVariant::serialize_field(
                                &mut __serde_state,
                                "additional",
                                additional,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeStructVariant::end(__serde_state)
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for InternalAstError {
            #[inline]
            fn clone(&self) -> InternalAstError {
                match (&*self,) {
                    (&InternalAstError::NoMatch,) => InternalAstError::NoMatch,
                    (&InternalAstError::UnexpectedToken {
                        token: ref __self_0,
                        additional: ref __self_1,
                    },) => InternalAstError::UnexpectedToken {
                        token: ::core::clone::Clone::clone(&(*__self_0)),
                        additional: ::core::clone::Clone::clone(&(*__self_1)),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for InternalAstError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&InternalAstError::NoMatch,) => {
                        ::core::fmt::Formatter::write_str(f, "NoMatch")
                    }
                    (&InternalAstError::UnexpectedToken {
                        token: ref __self_0,
                        additional: ref __self_1,
                    },) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "UnexpectedToken");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "token",
                            &&(*__self_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "additional",
                            &&(*__self_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for InternalAstError {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for InternalAstError {
            #[inline]
            fn eq(&self, other: &InternalAstError) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &InternalAstError::UnexpectedToken {
                                    token: ref __self_0,
                                    additional: ref __self_1,
                                },
                                &InternalAstError::UnexpectedToken {
                                    token: ref __arg_1_0,
                                    additional: ref __arg_1_1,
                                },
                            ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &InternalAstError) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &InternalAstError::UnexpectedToken {
                                    token: ref __self_0,
                                    additional: ref __self_1,
                                },
                                &InternalAstError::UnexpectedToken {
                                    token: ref __arg_1_0,
                                    additional: ref __arg_1_1,
                                },
                            ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        pub struct ZeroOrMore<P>(pub P);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<P: ::core::clone::Clone> ::core::clone::Clone for ZeroOrMore<P> {
            #[inline]
            fn clone(&self) -> ZeroOrMore<P> {
                match *self {
                    ZeroOrMore(ref __self_0_0) => {
                        ZeroOrMore(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<P: ::core::fmt::Debug> ::core::fmt::Debug for ZeroOrMore<P> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ZeroOrMore(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ZeroOrMore");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl<P> ::core::marker::StructuralPartialEq for ZeroOrMore<P> {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<P: ::core::cmp::PartialEq> ::core::cmp::PartialEq for ZeroOrMore<P> {
            #[inline]
            fn eq(&self, other: &ZeroOrMore<P>) -> bool {
                match *other {
                    ZeroOrMore(ref __self_1_0) => match *self {
                        ZeroOrMore(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ZeroOrMore<P>) -> bool {
                match *other {
                    ZeroOrMore(ref __self_1_0) => match *self {
                        ZeroOrMore(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl<P, T> Parser for ZeroOrMore<P>
        where
            P: Parser<Item = T>,
        {
            type Item = Vec<T>;
            fn parse<'a>(
                &self,
                mut state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Vec<T>), InternalAstError> {
                let mut nodes = Vec::new();
                loop {
                    match self.0.parse(state) {
                        Ok((new_state, node)) => {
                            state = new_state;
                            nodes.push(node);
                        }
                        Err(InternalAstError::NoMatch) => break,
                        Err(other) => return Err(other),
                    };
                }
                Ok((state, nodes))
            }
        }
        pub struct ZeroOrMoreDelimited<ItemParser, Delimiter>(
            pub ItemParser,
            pub Delimiter,
            pub bool,
        );
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::clone::Clone, Delimiter: ::core::clone::Clone> ::core::clone::Clone
            for ZeroOrMoreDelimited<ItemParser, Delimiter>
        {
            #[inline]
            fn clone(&self) -> ZeroOrMoreDelimited<ItemParser, Delimiter> {
                match *self {
                    ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                        ZeroOrMoreDelimited(
                            ::core::clone::Clone::clone(&(*__self_0_0)),
                            ::core::clone::Clone::clone(&(*__self_0_1)),
                            ::core::clone::Clone::clone(&(*__self_0_2)),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::fmt::Debug, Delimiter: ::core::fmt::Debug> ::core::fmt::Debug
            for ZeroOrMoreDelimited<ItemParser, Delimiter>
        {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ZeroOrMoreDelimited");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_1));
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_2));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl<ItemParser, Delimiter> ::core::marker::StructuralPartialEq
            for ZeroOrMoreDelimited<ItemParser, Delimiter>
        {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::cmp::PartialEq, Delimiter: ::core::cmp::PartialEq>
            ::core::cmp::PartialEq for ZeroOrMoreDelimited<ItemParser, Delimiter>
        {
            #[inline]
            fn eq(&self, other: &ZeroOrMoreDelimited<ItemParser, Delimiter>) -> bool {
                match *other {
                    ZeroOrMoreDelimited(ref __self_1_0, ref __self_1_1, ref __self_1_2) => {
                        match *self {
                            ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                                (*__self_0_0) == (*__self_1_0)
                                    && (*__self_0_1) == (*__self_1_1)
                                    && (*__self_0_2) == (*__self_1_2)
                            }
                        }
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &ZeroOrMoreDelimited<ItemParser, Delimiter>) -> bool {
                match *other {
                    ZeroOrMoreDelimited(ref __self_1_0, ref __self_1_1, ref __self_1_2) => {
                        match *self {
                            ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                                (*__self_0_0) != (*__self_1_0)
                                    || (*__self_0_1) != (*__self_1_1)
                                    || (*__self_0_2) != (*__self_1_2)
                            }
                        }
                    }
                }
            }
        }
        #[allow(clippy::blocks_in_if_conditions)]
        #[allow(clippy::nonminimal_bool)]
        impl<ItemParser, Delimiter, T> Parser for ZeroOrMoreDelimited<ItemParser, Delimiter>
        where
            ItemParser: Parser<Item = T>,
            Delimiter: Parser<Item = TokenReference>,
            T: Node + Visit + VisitMut,
        {
            type Item = Punctuated<T>;
            fn parse<'a>(
                &self,
                mut state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Punctuated<T>), InternalAstError> {
                let mut nodes = Punctuated::new();
                if let Ok((new_state, node)) = match self.0.parse(state) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    state = new_state;
                    nodes.push(Pair::End(node));
                } else {
                    return Ok((state, Punctuated::new()));
                }
                while let Ok((new_state, delimiter)) = match self.1.parse(state) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let last_value = nodes.pop().unwrap().into_value();
                    nodes.push(Pair::Punctuated(last_value, delimiter));
                    state = new_state;
                    match self.0.parse(state) {
                        Ok((new_state, node)) => {
                            state = new_state;
                            nodes.push(Pair::End(node));
                        }
                        Err(InternalAstError::NoMatch) => {
                            if self.2 {
                                break;
                            } else {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("trailing character")),
                                });
                            }
                        }
                        Err(other) => {
                            return Err(other);
                        }
                    }
                }
                if !self.2 {
                    if true {
                        let len = nodes.len();
                        for (index, node) in nodes.pairs().enumerate() {
                            if index + 1 == len && node.punctuation().is_some() {
                                {
                                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                                        &["", " pairs illogical: last node has punctuation: "],
                                        &match (
                                            &"ZeroOrMoreDelimited",
                                            &node.punctuation().unwrap(),
                                        ) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Debug::fmt,
                                                ),
                                            ],
                                        },
                                    ))
                                };
                            } else if index + 1 != len && node.punctuation().is_none() {
                                {
                                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                                        &[
                                            "",
                                            " pairs illogical: non-last node (",
                                            ") has no punctuation",
                                        ],
                                        &match (&"ZeroOrMoreDelimited", &index) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                            ],
                                        },
                                    ))
                                };
                            }
                        }
                    };
                }
                Ok((state, nodes))
            }
        }
        pub struct OneOrMore<ItemParser, Delimiter>(pub ItemParser, pub Delimiter, pub bool);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::clone::Clone, Delimiter: ::core::clone::Clone> ::core::clone::Clone
            for OneOrMore<ItemParser, Delimiter>
        {
            #[inline]
            fn clone(&self) -> OneOrMore<ItemParser, Delimiter> {
                match *self {
                    OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => OneOrMore(
                        ::core::clone::Clone::clone(&(*__self_0_0)),
                        ::core::clone::Clone::clone(&(*__self_0_1)),
                        ::core::clone::Clone::clone(&(*__self_0_2)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::fmt::Debug, Delimiter: ::core::fmt::Debug> ::core::fmt::Debug
            for OneOrMore<ItemParser, Delimiter>
        {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "OneOrMore");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_1));
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_2));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl<ItemParser, Delimiter> ::core::marker::StructuralPartialEq
            for OneOrMore<ItemParser, Delimiter>
        {
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<ItemParser: ::core::cmp::PartialEq, Delimiter: ::core::cmp::PartialEq>
            ::core::cmp::PartialEq for OneOrMore<ItemParser, Delimiter>
        {
            #[inline]
            fn eq(&self, other: &OneOrMore<ItemParser, Delimiter>) -> bool {
                match *other {
                    OneOrMore(ref __self_1_0, ref __self_1_1, ref __self_1_2) => match *self {
                        OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &OneOrMore<ItemParser, Delimiter>) -> bool {
                match *other {
                    OneOrMore(ref __self_1_0, ref __self_1_1, ref __self_1_2) => match *self {
                        OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        #[allow(clippy::blocks_in_if_conditions)]
        #[allow(clippy::nonminimal_bool)]
        impl<ItemParser, Delimiter: Parser, T> Parser for OneOrMore<ItemParser, Delimiter>
        where
            ItemParser: Parser<Item = T>,
            Delimiter: Parser<Item = TokenReference>,
            T: Node + Visit + VisitMut,
        {
            type Item = Punctuated<ItemParser::Item>;
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Punctuated<ItemParser::Item>), InternalAstError>
            {
                let mut nodes = Punctuated::new();
                let (mut state, node) = self.0.parse(state)?;
                nodes.push(Pair::End(node));
                while let Ok((new_state, delimiter)) = self.1.parse(state) {
                    let last_value = nodes.pop().unwrap().into_value();
                    nodes.push(Pair::Punctuated(last_value, delimiter));
                    match self.0.parse(new_state) {
                        Ok((new_state, node)) => {
                            state = new_state;
                            nodes.push(Pair::End(node));
                        }
                        Err(InternalAstError::NoMatch) => {
                            if self.2 {
                                state = new_state;
                            }
                            break;
                        }
                        Err(other) => {
                            return Err(other);
                        }
                    }
                }
                if !self.2 {
                    let last_value = nodes.pop().unwrap().into_value();
                    nodes.push(Pair::End(last_value));
                    if true {
                        let len = nodes.len();
                        for (index, node) in nodes.pairs().enumerate() {
                            if index + 1 == len && node.punctuation().is_some() {
                                {
                                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                                        &["", " pairs illogical: last node has punctuation: "],
                                        &match (&"OneOrMore", &node.punctuation().unwrap()) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Debug::fmt,
                                                ),
                                            ],
                                        },
                                    ))
                                };
                            } else if index + 1 != len && node.punctuation().is_none() {
                                {
                                    ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                                        &[
                                            "",
                                            " pairs illogical: non-last node (",
                                            ") has no punctuation",
                                        ],
                                        &match (&"OneOrMore", &index) {
                                            (arg0, arg1) => [
                                                ::core::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                                ::core::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::core::fmt::Display::fmt,
                                                ),
                                            ],
                                        },
                                    ))
                                };
                            }
                        }
                    };
                }
                Ok((state, nodes))
            }
        }
        pub struct NoDelimiter;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for NoDelimiter {
            #[inline]
            fn clone(&self) -> NoDelimiter {
                match *self {
                    NoDelimiter => NoDelimiter,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for NoDelimiter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    NoDelimiter => ::core::fmt::Formatter::write_str(f, "NoDelimiter"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for NoDelimiter {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for NoDelimiter {
            #[inline]
            fn eq(&self, other: &NoDelimiter) -> bool {
                match *other {
                    NoDelimiter => match *self {
                        NoDelimiter => true,
                    },
                }
            }
        }
        impl Parser for NoDelimiter {
            type Item = ();
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, ()), InternalAstError> {
                (|_, mut state: ParserState<'a>| Ok((state, ())))(self, state)
            }
        }
    }
    mod parsers {
        use super::{
            parser_util::{InternalAstError, Parser},
            span::ContainedSpan,
            *,
        };
        use crate::tokenizer::{TokenKind, TokenReference, TokenType};
        use std::{borrow::Cow, marker::PhantomData};
        struct ParseSymbol(Symbol);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseSymbol {
            #[inline]
            fn clone(&self) -> ParseSymbol {
                match *self {
                    ParseSymbol(ref __self_0_0) => {
                        ParseSymbol(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseSymbol {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseSymbol(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ParseSymbol");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseSymbol {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseSymbol {
            #[inline]
            fn eq(&self, other: &ParseSymbol) -> bool {
                match *other {
                    ParseSymbol(ref __self_1_0) => match *self {
                        ParseSymbol(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ParseSymbol) -> bool {
                match *other {
                    ParseSymbol(ref __self_1_0) => match *self {
                        ParseSymbol(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl Parser for ParseSymbol {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|this: &ParseSymbol, mut state: ParserState<'a>| {
                    let expecting = TokenType::Symbol { symbol: this.0 };
                    let token = state.peek();
                    if *token.token_type() == expecting {
                        Ok((
                            state.advance().ok_or(InternalAstError::NoMatch)?,
                            token.clone(),
                        ))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseNumber;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseNumber {
            #[inline]
            fn clone(&self) -> ParseNumber {
                match *self {
                    ParseNumber => ParseNumber,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseNumber {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseNumber => ::core::fmt::Formatter::write_str(f, "ParseNumber"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseNumber {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseNumber {
            #[inline]
            fn eq(&self, other: &ParseNumber) -> bool {
                match *other {
                    ParseNumber => match *self {
                        ParseNumber => true,
                    },
                }
            }
        }
        impl Parser for ParseNumber {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let token = state.peek();
                    if token.token_kind() == TokenKind::Number {
                        Ok((
                            state.advance().ok_or(InternalAstError::NoMatch)?,
                            token.clone(),
                        ))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseStringLiteral;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseStringLiteral {
            #[inline]
            fn clone(&self) -> ParseStringLiteral {
                match *self {
                    ParseStringLiteral => ParseStringLiteral,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseStringLiteral {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseStringLiteral => {
                        ::core::fmt::Formatter::write_str(f, "ParseStringLiteral")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseStringLiteral {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseStringLiteral {
            #[inline]
            fn eq(&self, other: &ParseStringLiteral) -> bool {
                match *other {
                    ParseStringLiteral => match *self {
                        ParseStringLiteral => true,
                    },
                }
            }
        }
        impl Parser for ParseStringLiteral {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let token = state.peek();
                    if token.token_kind() == TokenKind::StringLiteral {
                        Ok((
                            state.advance().ok_or(InternalAstError::NoMatch)?,
                            token.clone(),
                        ))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        pub struct ParseBlock;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseBlock {
            #[inline]
            fn clone(&self) -> ParseBlock {
                match *self {
                    ParseBlock => ParseBlock,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseBlock {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseBlock => ::core::fmt::Formatter::write_str(f, "ParseBlock"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseBlock {
            #[inline]
            fn default() -> ParseBlock {
                ParseBlock {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseBlock {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseBlock {
            #[inline]
            fn eq(&self, other: &ParseBlock) -> bool {
                match *other {
                    ParseBlock => match *self {
                        ParseBlock => true,
                    },
                }
            }
        }
        impl Parser for ParseBlock {
            type Item = Block;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Block), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let mut stmts = Vec::new();
                    while let Ok((new_state, stmt)) = match ParseStmt.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        state = new_state;
                        let mut semicolon = None;
                        if let Ok((new_state, new_semicolon)) =
                            ParseSymbol(Symbol::Semicolon).parse(state)
                        {
                            state = new_state;
                            semicolon = Some(new_semicolon);
                        }
                        stmts.push((stmt, semicolon));
                    }
                    if let Ok((mut state, last_stmt)) = match ParseLastStmt.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        let mut semicolon = None;
                        if let Ok((new_state, new_semicolon)) =
                            ParseSymbol(Symbol::Semicolon).parse(state)
                        {
                            state = new_state;
                            semicolon = Some(new_semicolon)
                        }
                        Ok((
                            state,
                            Block {
                                stmts,
                                last_stmt: Some((last_stmt, semicolon)),
                                plugin_info: (),
                            },
                        ))
                    } else {
                        Ok((
                            state,
                            Block {
                                stmts,
                                last_stmt: None,
                                plugin_info: (),
                            },
                        ))
                    }
                })(self, state)
            }
        }
        struct ParseLastStmt;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseLastStmt {
            #[inline]
            fn clone(&self) -> ParseLastStmt {
                match *self {
                    ParseLastStmt => ParseLastStmt,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseLastStmt {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseLastStmt => ::core::fmt::Formatter::write_str(f, "ParseLastStmt"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseLastStmt {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseLastStmt {
            #[inline]
            fn eq(&self, other: &ParseLastStmt) -> bool {
                match *other {
                    ParseLastStmt => match *self {
                        ParseLastStmt => true,
                    },
                }
            }
        }
        impl Parser for ParseLastStmt {
            type Item = LastStmt;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, LastStmt), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, token)) = ParseSymbol(Symbol::Return).parse(state) {
                        let (state, returns) = match ZeroOrMoreDelimited(
                            ParseExpression,
                            ParseSymbol(Symbol::Comma),
                            false,
                        )
                        .parse(state)
                        {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("return values")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        Ok((
                            state,
                            LastStmt::Return(Return {
                                token,
                                returns,
                                plugin_info: (),
                            }),
                        ))
                    } else if let Ok((state, token)) = ParseSymbol(Symbol::Break).parse(state) {
                        Ok((state, LastStmt::Break(token)))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseField;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseField {
            #[inline]
            fn clone(&self) -> ParseField {
                match *self {
                    ParseField => ParseField,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseField {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseField => ::core::fmt::Formatter::write_str(f, "ParseField"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseField {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseField {
            #[inline]
            fn eq(&self, other: &ParseField) -> bool {
                match *other {
                    ParseField => match *self {
                        ParseField => true,
                    },
                }
            }
        }
        impl Parser for ParseField {
            type Item = Field;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Field), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, start_bracket)) =
                        ParseSymbol(Symbol::LeftBracket).parse(state)
                    {
                        let (state, key) = match ParseExpression.parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected key")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (state, end_bracket) =
                            match ParseSymbol(Symbol::RightBracket).parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected ']'")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        let (state, equal) = match ParseSymbol(Symbol::Equal).parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected '='")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (state, value) = match ParseExpression.parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected value")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        return Ok((
                            state,
                            Field::ExpressionKey {
                                brackets: ContainedSpan::new(start_bracket, end_bracket),
                                key,
                                equal,
                                value,
                            },
                        ));
                    } else if let Ok((state, key)) = match ParseIdentifier.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        if let Ok((state, equal)) = ParseSymbol(Symbol::Equal).parse(state) {
                            let (state, value) = match ParseExpression.parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected value")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                            return Ok((state, Field::NameKey { key, equal, value }));
                        }
                    }
                    if let Ok((state, expr)) = match ParseExpression.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        return Ok((state, Field::NoKey(expr)));
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseTableConstructor;
        impl Parser for ParseTableConstructor {
            type Item = TableConstructor;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TableConstructor), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (mut state, start_brace) = ParseSymbol(Symbol::LeftBrace).parse(state)?;
                    let mut fields = Punctuated::new();
                    while let Ok((new_state, field)) = match ParseField.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        let field_sep = if let Ok((new_state, separator)) =
                            ParseSymbol(Symbol::Comma).parse(new_state)
                        {
                            state = new_state;
                            Some(separator)
                        } else if let Ok((new_state, separator)) =
                            ParseSymbol(Symbol::Semicolon).parse(new_state)
                        {
                            state = new_state;
                            Some(separator)
                        } else {
                            state = new_state;
                            None
                        };
                        let is_end = field_sep.is_none();
                        fields.push(Pair::new(field, field_sep));
                        if is_end {
                            break;
                        }
                    }
                    let (state, end_brace) = match ParseSymbol(Symbol::RightBrace).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected '}'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        TableConstructor {
                            braces: ContainedSpan::new(start_brace, end_brace),
                            fields,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseUnaryExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseUnaryExpression {
            #[inline]
            fn clone(&self) -> ParseUnaryExpression {
                match *self {
                    ParseUnaryExpression => ParseUnaryExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseUnaryExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseUnaryExpression => {
                        ::core::fmt::Formatter::write_str(f, "ParseUnaryExpression")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseUnaryExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseUnaryExpression {
            #[inline]
            fn eq(&self, other: &ParseUnaryExpression) -> bool {
                match *other {
                    ParseUnaryExpression => match *self {
                        ParseUnaryExpression => true,
                    },
                }
            }
        }
        impl Parser for ParseUnaryExpression {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, unop) = match ParseUnOp.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    }?;
                    let (state, expression) =
                        match ParseExpressionAtPrecedence(unop.precedence()).parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected expression")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                    let expression = Box::new(expression);
                    Ok((state, Expression::UnaryOperator { unop, expression }))
                })(self, state)
            }
        }
        struct ParseParenExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseParenExpression {
            #[inline]
            fn clone(&self) -> ParseParenExpression {
                match *self {
                    ParseParenExpression => ParseParenExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseParenExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseParenExpression => {
                        ::core::fmt::Formatter::write_str(f, "ParseParenExpression")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseParenExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseParenExpression {
            #[inline]
            fn eq(&self, other: &ParseParenExpression) -> bool {
                match *other {
                    ParseParenExpression => match *self {
                        ParseParenExpression => true,
                    },
                }
            }
        }
        impl Parser for ParseParenExpression {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, left_paren) = ParseSymbol(Symbol::LeftParen).parse(state)?;
                    let (state, expression) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected expression")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, right_paren) = match ParseSymbol(Symbol::RightParen).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected ')'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        Expression::Parentheses {
                            contained: ContainedSpan::new(left_paren, right_paren),
                            expression: Box::new(expression),
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseValueExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseValueExpression {
            #[inline]
            fn clone(&self) -> ParseValueExpression {
                match *self {
                    ParseValueExpression => ParseValueExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseValueExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseValueExpression => {
                        ::core::fmt::Formatter::write_str(f, "ParseValueExpression")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseValueExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseValueExpression {
            #[inline]
            fn eq(&self, other: &ParseValueExpression) -> bool {
                match *other {
                    ParseValueExpression => match *self {
                        ParseValueExpression => true,
                    },
                }
            }
        }
        impl Parser for ParseValueExpression {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, value) = match ParseValue.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    }?;
                    let value = Box::new(value);
                    Ok((state, Expression::Value { value }))
                })(self, state)
            }
        }
        struct ParsePartExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParsePartExpression {
            #[inline]
            fn clone(&self) -> ParsePartExpression {
                match *self {
                    ParsePartExpression => ParsePartExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParsePartExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParsePartExpression => {
                        ::core::fmt::Formatter::write_str(f, "ParsePartExpression")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParsePartExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParsePartExpression {
            #[inline]
            fn eq(&self, other: &ParsePartExpression) -> bool {
                match *other {
                    ParsePartExpression => match *self {
                        ParsePartExpression => true,
                    },
                }
            }
        }
        impl Parser for ParsePartExpression {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, expression)) = match ParseUnaryExpression.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        Ok((state, expression))
                    } else if let Ok((state, expression)) = match ParseValueExpression.parse(state)
                    {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        Ok((state, expression))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseExpressionAtPrecedence(u8);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseExpressionAtPrecedence {
            #[inline]
            fn clone(&self) -> ParseExpressionAtPrecedence {
                match *self {
                    ParseExpressionAtPrecedence(ref __self_0_0) => {
                        ParseExpressionAtPrecedence(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseExpressionAtPrecedence {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseExpressionAtPrecedence(ref __self_0_0) => {
                        let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(
                            f,
                            "ParseExpressionAtPrecedence",
                        );
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseExpressionAtPrecedence {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseExpressionAtPrecedence {
            #[inline]
            fn eq(&self, other: &ParseExpressionAtPrecedence) -> bool {
                match *other {
                    ParseExpressionAtPrecedence(ref __self_1_0) => match *self {
                        ParseExpressionAtPrecedence(ref __self_0_0) => {
                            (*__self_0_0) == (*__self_1_0)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ParseExpressionAtPrecedence) -> bool {
                match *other {
                    ParseExpressionAtPrecedence(ref __self_1_0) => match *self {
                        ParseExpressionAtPrecedence(ref __self_0_0) => {
                            (*__self_0_0) != (*__self_1_0)
                        }
                    },
                }
            }
        }
        impl Parser for ParseExpressionAtPrecedence {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|this: &ParseExpressionAtPrecedence, mut state: ParserState<'a>| {
                    let min_precedence = this.0;
                    let (mut state, mut current_expr) = ParsePartExpression.parse(state)?;
                    while let Ok((next_state, operator)) = ParseBinOp.parse(state) {
                        if operator.precedence() < min_precedence {
                            break;
                        }
                        let next_min_precedence = if operator.is_right_associative() {
                            operator.precedence()
                        } else {
                            operator.precedence() + 1
                        };
                        let (next_state, rhs) = match ParseExpressionAtPrecedence(
                            next_min_precedence,
                        )
                        .parse(next_state)
                        {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: next_state.peek().clone(),
                                    additional: Some(Cow::from("expected expression")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        state = next_state;
                        current_expr = Expression::BinaryOperator {
                            lhs: Box::new(current_expr),
                            binop: operator,
                            rhs: Box::new(rhs),
                        };
                    }
                    Ok((state, current_expr))
                })(self, state)
            }
        }
        struct ParseExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseExpression {
            #[inline]
            fn clone(&self) -> ParseExpression {
                match *self {
                    ParseExpression => ParseExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseExpression => ::core::fmt::Formatter::write_str(f, "ParseExpression"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseExpression {
            #[inline]
            fn eq(&self, other: &ParseExpression) -> bool {
                match *other {
                    ParseExpression => match *self {
                        ParseExpression => true,
                    },
                }
            }
        }
        impl Parser for ParseExpression {
            type Item = Expression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Expression), InternalAstError> {
                (|_, mut state: ParserState<'a>| ParseExpressionAtPrecedence(1).parse(state))(
                    self, state,
                )
            }
        }
        struct ParseTypeAssertion;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseTypeAssertion {
            #[inline]
            fn clone(&self) -> ParseTypeAssertion {
                match *self {
                    ParseTypeAssertion => ParseTypeAssertion,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseTypeAssertion {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseTypeAssertion => {
                        ::core::fmt::Formatter::write_str(f, "ParseTypeAssertion")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseTypeAssertion {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseTypeAssertion {
            #[inline]
            fn eq(&self, other: &ParseTypeAssertion) -> bool {
                match *other {
                    ParseTypeAssertion => match *self {
                        ParseTypeAssertion => true,
                    },
                }
            }
        }
        impl Parser for ParseTypeAssertion {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseValue;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseValue {
            #[inline]
            fn clone(&self) -> ParseValue {
                match *self {
                    ParseValue => ParseValue,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseValue {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseValue => ::core::fmt::Formatter::write_str(f, "ParseValue"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseValue {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseValue {
            #[inline]
            fn eq(&self, other: &ParseValue) -> bool {
                match *other {
                    ParseValue => match *self {
                        ParseValue => true,
                    },
                }
            }
        }
        impl Parser for ParseValue {
            type Item = Value;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Value), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseSymbol(Symbol::Nil)
                            .parse(state)
                            .map(|(state, node)| (state, Value::Symbol(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseSymbol(Symbol::False)
                            .parse(state)
                            .map(|(state, node)| (state, Value::Symbol(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseSymbol(Symbol::True)
                            .parse(state)
                            .map(|(state, node)| (state, Value::Symbol(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseNumber
                            .parse(state)
                            .map(|(state, node)| (state, Value::Number(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseStringLiteral
                            .parse(state)
                            .map(|(state, node)| (state, Value::String(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseSymbol(Symbol::Ellipse)
                            .parse(state)
                            .map(|(state, node)| (state, Value::Symbol(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseFunction
                            .parse(state)
                            .map(|(state, node)| (state, Value::Function(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseTableConstructor
                            .parse(state)
                            .map(|(state, node)| (state, Value::TableConstructor(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseFunctionCall
                            .parse(state)
                            .map(|(state, node)| (state, Value::FunctionCall(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseVar
                            .parse(state)
                            .map(|(state, node)| (state, Value::Var(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseParenExpression
                            .parse(state)
                            .map(|(state, node)| (state, Value::ParenthesesExpression(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseStmt;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseStmt {
            #[inline]
            fn clone(&self) -> ParseStmt {
                match *self {
                    ParseStmt => ParseStmt,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseStmt {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseStmt => ::core::fmt::Formatter::write_str(f, "ParseStmt"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseStmt {
            #[inline]
            fn default() -> ParseStmt {
                ParseStmt {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseStmt {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseStmt {
            #[inline]
            fn eq(&self, other: &ParseStmt) -> bool {
                match *other {
                    ParseStmt => match *self {
                        ParseStmt => true,
                    },
                }
            }
        }
        impl Parser for ParseStmt {
            type Item = Stmt;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Stmt), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseAssignment
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::Assignment(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseFunctionCall
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::FunctionCall(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseDo
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::Do(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseWhile
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::While(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseRepeat
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::Repeat(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseIf
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::If(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseNumericFor
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::NumericFor(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseGenericFor
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::GenericFor(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseFunctionDeclaration
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::FunctionDeclaration(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseLocalFunction
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::LocalFunction(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseLocalAssignment
                            .parse(state)
                            .map(|(state, node)| (state, Stmt::LocalAssignment(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParsePrefix;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParsePrefix {
            #[inline]
            fn clone(&self) -> ParsePrefix {
                match *self {
                    ParsePrefix => ParsePrefix,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParsePrefix {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParsePrefix => ::core::fmt::Formatter::write_str(f, "ParsePrefix"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParsePrefix {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParsePrefix {
            #[inline]
            fn eq(&self, other: &ParsePrefix) -> bool {
                match *other {
                    ParsePrefix => match *self {
                        ParsePrefix => true,
                    },
                }
            }
        }
        impl Parser for ParsePrefix {
            type Item = Prefix;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Prefix), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseParenExpression
                            .parse(state)
                            .map(|(state, node)| (state, Prefix::Expression(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseIdentifier
                            .parse(state)
                            .map(|(state, node)| (state, Prefix::Name(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseIndex;
        impl Parser for ParseIndex {
            type Item = Index;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Index), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, start_bracket)) =
                        ParseSymbol(Symbol::LeftBracket).parse(state)
                    {
                        let (state, expression) = match ParseExpression.parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected expression")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (state, end_bracket) =
                            match ParseSymbol(Symbol::RightBracket).parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected ']'")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        Ok((
                            state,
                            Index::Brackets {
                                brackets: ContainedSpan::new(start_bracket, end_bracket),
                                expression,
                            },
                        ))
                    } else if let Ok((state, dot)) = ParseSymbol(Symbol::Dot).parse(state) {
                        let (state, name) = match ParseIdentifier.parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected name")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        Ok((state, Index::Dot { dot, name }))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseFunctionArgs;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunctionArgs {
            #[inline]
            fn clone(&self) -> ParseFunctionArgs {
                match *self {
                    ParseFunctionArgs => ParseFunctionArgs,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunctionArgs {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunctionArgs => ::core::fmt::Formatter::write_str(f, "ParseFunctionArgs"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunctionArgs {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunctionArgs {
            #[inline]
            fn eq(&self, other: &ParseFunctionArgs) -> bool {
                match *other {
                    ParseFunctionArgs => match *self {
                        ParseFunctionArgs => true,
                    },
                }
            }
        }
        impl Parser for ParseFunctionArgs {
            type Item = FunctionArgs;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, FunctionArgs), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, left_paren)) =
                        match ParseSymbol(Symbol::LeftParen).parse(state) {
                            Ok((state, node)) => Ok((state, node)),
                            Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                            Err(other) => return Err(other),
                        }
                    {
                        let (state, arguments) = match ZeroOrMoreDelimited(
                            ParseExpression,
                            ParseSymbol(Symbol::Comma),
                            false,
                        )
                        .parse(state)
                        {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected arguments")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (state, right_paren) =
                            match ParseSymbol(Symbol::RightParen).parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected ')'")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        Ok((
                            state,
                            FunctionArgs::Parentheses {
                                arguments,
                                parentheses: ContainedSpan::new(left_paren, right_paren),
                            },
                        ))
                    } else if let Ok((state, table_constructor)) =
                        match ParseTableConstructor.parse(state) {
                            Ok((state, node)) => Ok((state, node)),
                            Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                            Err(other) => return Err(other),
                        }
                    {
                        Ok((state, FunctionArgs::TableConstructor(table_constructor)))
                    } else if let Ok((state, string)) = match ParseStringLiteral.parse(state) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    } {
                        Ok((state, FunctionArgs::String(string)))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseNumericFor;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseNumericFor {
            #[inline]
            fn clone(&self) -> ParseNumericFor {
                match *self {
                    ParseNumericFor => ParseNumericFor,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseNumericFor {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseNumericFor => ::core::fmt::Formatter::write_str(f, "ParseNumericFor"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseNumericFor {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseNumericFor {
            #[inline]
            fn eq(&self, other: &ParseNumericFor) -> bool {
                match *other {
                    ParseNumericFor => match *self {
                        ParseNumericFor => true,
                    },
                }
            }
        }
        impl Parser for ParseNumericFor {
            type Item = NumericFor;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, NumericFor), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (mut state, for_token) = ParseSymbol(Symbol::For).parse(state)?;
                    let index_variable;
                    let (new_state, new_index_variable) = match ParseIdentifier.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected names")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    state = new_state;
                    index_variable = new_index_variable;
                    let (state, equal_token) = ParseSymbol(Symbol::Equal).parse(state)?;
                    let (state, start) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected start expression")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, start_end_comma) = match ParseSymbol(Symbol::Comma).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected comma")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected end expression")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, step, end_step_comma) =
                        if let Ok((state, comma)) = ParseSymbol(Symbol::Comma).parse(state) {
                            let (state, expression) = match ParseExpression.parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected limit expression")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                            (state, Some(expression), Some(comma))
                        } else {
                            (state, None, None)
                        };
                    let (state, do_token) = match ParseSymbol(Symbol::Do).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'do'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        NumericFor {
                            for_token,
                            index_variable,
                            equal_token,
                            start,
                            start_end_comma,
                            end,
                            end_step_comma,
                            step,
                            do_token,
                            block,
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseGenericFor;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseGenericFor {
            #[inline]
            fn clone(&self) -> ParseGenericFor {
                match *self {
                    ParseGenericFor => ParseGenericFor,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseGenericFor {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseGenericFor => ::core::fmt::Formatter::write_str(f, "ParseGenericFor"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseGenericFor {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseGenericFor {
            #[inline]
            fn eq(&self, other: &ParseGenericFor) -> bool {
                match *other {
                    ParseGenericFor => match *self {
                        ParseGenericFor => true,
                    },
                }
            }
        }
        impl Parser for ParseGenericFor {
            type Item = GenericFor;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, GenericFor), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (mut state, for_token) = ParseSymbol(Symbol::For).parse(state)?;
                    let mut names;
                    let mut type_specifiers = Vec::new();
                    if false {
                        names = Punctuated::new();
                        let (new_state, full_name_list) =
                            match OneOrMore(ParseNameWithType, ParseSymbol(Symbol::Comma), false)
                                .parse(state)
                            {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected names")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        for mut pair in full_name_list.into_pairs() {
                            type_specifiers.push(pair.value_mut().1.take());
                            names.push(pair.map(|(name, _)| name));
                        }
                        state = new_state;
                    } else {
                        let (new_state, new_names) =
                            match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                                .parse(state)
                            {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected names")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        state = new_state;
                        names = new_names;
                    }
                    let (state, in_token) = match ParseSymbol(Symbol::In).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'in'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, expr_list) =
                        match OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                            .parse(state)
                        {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected expression")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                    let (state, do_token) = match ParseSymbol(Symbol::Do).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'do'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        GenericFor {
                            for_token,
                            names,
                            in_token,
                            expr_list,
                            do_token,
                            block,
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseIf;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseIf {
            #[inline]
            fn clone(&self) -> ParseIf {
                match *self {
                    ParseIf => ParseIf,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseIf {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseIf => ::core::fmt::Formatter::write_str(f, "ParseIf"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseIf {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseIf {
            #[inline]
            fn eq(&self, other: &ParseIf) -> bool {
                match *other {
                    ParseIf => match *self {
                        ParseIf => true,
                    },
                }
            }
        }
        impl Parser for ParseIf {
            type Item = If;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, If), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, if_token) = ParseSymbol(Symbol::If).parse(state)?;
                    let (state, condition) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected condition")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, then_token) = match ParseSymbol(Symbol::Then).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'then'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (mut state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let mut else_ifs = Vec::new();
                    while let Ok((new_state, else_if_token)) =
                        ParseSymbol(Symbol::ElseIf).parse(state)
                    {
                        let (new_state, condition) = match ParseExpression.parse(new_state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected condition")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (new_state, then_token) =
                            match ParseSymbol(Symbol::Then).parse(new_state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected 'then'")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        let (new_state, block) = match ParseBlock.parse(new_state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected block")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        state = new_state;
                        else_ifs.push(ElseIf {
                            else_if_token,
                            condition,
                            then_token,
                            block,
                            plugin_info: (),
                        });
                    }
                    let (state, else_token, r#else) =
                        if let Ok((state, else_token)) = ParseSymbol(Symbol::Else).parse(state) {
                            let (state, block) = match ParseBlock.parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected block")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                            (state, Some(else_token), Some(block))
                        } else {
                            (state, None, None)
                        };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        If {
                            if_token,
                            condition,
                            then_token,
                            block,
                            else_token,
                            r#else,
                            else_if: if else_ifs.is_empty() {
                                None
                            } else {
                                Some(else_ifs)
                            },
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseWhile;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseWhile {
            #[inline]
            fn clone(&self) -> ParseWhile {
                match *self {
                    ParseWhile => ParseWhile,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseWhile {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseWhile => ::core::fmt::Formatter::write_str(f, "ParseWhile"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseWhile {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseWhile {
            #[inline]
            fn eq(&self, other: &ParseWhile) -> bool {
                match *other {
                    ParseWhile => match *self {
                        ParseWhile => true,
                    },
                }
            }
        }
        impl Parser for ParseWhile {
            type Item = While;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, While), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, while_token) = ParseSymbol(Symbol::While).parse(state)?;
                    let (state, condition) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected condition")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, do_token) = match ParseSymbol(Symbol::Do).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'do'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        While {
                            while_token,
                            condition,
                            do_token,
                            block,
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseRepeat;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseRepeat {
            #[inline]
            fn clone(&self) -> ParseRepeat {
                match *self {
                    ParseRepeat => ParseRepeat,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseRepeat {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseRepeat => ::core::fmt::Formatter::write_str(f, "ParseRepeat"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseRepeat {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseRepeat {
            #[inline]
            fn eq(&self, other: &ParseRepeat) -> bool {
                match *other {
                    ParseRepeat => match *self {
                        ParseRepeat => true,
                    },
                }
            }
        }
        impl Parser for ParseRepeat {
            type Item = Repeat;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Repeat), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, repeat_token) = ParseSymbol(Symbol::Repeat).parse(state)?;
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, until_token) = match ParseSymbol(Symbol::Until).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'until'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, until) = match ParseExpression.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected condition")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        Repeat {
                            repeat_token,
                            block,
                            until_token,
                            until,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseMethodCall;
        impl Parser for ParseMethodCall {
            type Item = MethodCall;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, MethodCall), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, colon_token) = ParseSymbol(Symbol::Colon).parse(state)?;
                    let (state, name) = match ParseIdentifier.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected method")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, args) = match ParseFunctionArgs.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected args")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        MethodCall {
                            colon_token,
                            name,
                            args,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseCall;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseCall {
            #[inline]
            fn clone(&self) -> ParseCall {
                match *self {
                    ParseCall => ParseCall,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseCall => ::core::fmt::Formatter::write_str(f, "ParseCall"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseCall {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseCall {
            #[inline]
            fn eq(&self, other: &ParseCall) -> bool {
                match *other {
                    ParseCall => match *self {
                        ParseCall => true,
                    },
                }
            }
        }
        impl Parser for ParseCall {
            type Item = Call;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Call), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseFunctionArgs
                            .parse(state)
                            .map(|(state, node)| (state, Call::AnonymousCall(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseMethodCall
                            .parse(state)
                            .map(|(state, node)| (state, Call::MethodCall(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseFunctionBody;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunctionBody {
            #[inline]
            fn clone(&self) -> ParseFunctionBody {
                match *self {
                    ParseFunctionBody => ParseFunctionBody,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunctionBody {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunctionBody => ::core::fmt::Formatter::write_str(f, "ParseFunctionBody"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunctionBody {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunctionBody {
            #[inline]
            fn eq(&self, other: &ParseFunctionBody) -> bool {
                match *other {
                    ParseFunctionBody => match *self {
                        ParseFunctionBody => true,
                    },
                }
            }
        }
        impl Parser for ParseFunctionBody {
            type Item = FunctionBody;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, FunctionBody), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (mut state, start_parenthese) =
                        match ParseSymbol(Symbol::LeftParen).parse(state) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected '('")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                    let mut parameters = Punctuated::new();
                    let mut name_list = None;
                    let mut type_specifiers = Vec::new();
                    if false {
                        if let Ok((new_state, full_name_list)) =
                            match OneOrMore(ParseNameWithType, ParseSymbol(Symbol::Comma), false)
                                .parse(state)
                            {
                                Ok((state, node)) => Ok((state, node)),
                                Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                                Err(other) => return Err(other),
                            }
                        {
                            let mut new_name_list = Punctuated::new();
                            for mut pair in full_name_list.into_pairs() {
                                type_specifiers.push(pair.value_mut().1.take());
                                new_name_list.push(pair.map(|(name, _)| name));
                            }
                            state = new_state;
                            name_list = Some(new_name_list);
                        }
                    } else if let Ok((new_state, new_name_list)) =
                        match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                            .parse(state)
                        {
                            Ok((state, node)) => Ok((state, node)),
                            Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                            Err(other) => return Err(other),
                        }
                    {
                        state = new_state;
                        name_list = Some(new_name_list);
                    }
                    if let Some(names) = name_list {
                        parameters.extend(names.into_pairs().map(|pair| {
                            let tuple = pair.into_tuple();
                            Pair::new(Parameter::Name(tuple.0), tuple.1)
                        }));
                        if let Ok((new_state, comma)) = ParseSymbol(Symbol::Comma).parse(state) {
                            if let Ok((new_state, ellipse)) =
                                ParseSymbol(Symbol::Ellipse).parse(new_state)
                            {
                                state = new_state;
                                let mut last_parameter = parameters.pop().expect(
                                    "comma parsed and accepted, but no arguments before it?",
                                );
                                last_parameter =
                                    Pair::new(last_parameter.into_value(), Some(comma));
                                parameters.push(last_parameter);
                                parameters.push(Pair::new(Parameter::Ellipse(ellipse), None));
                                if false {
                                    if let Ok((new_state, type_specifier)) =
                                        ParseTypeSpecifier(TypeInfoContext::VarArgSpecifier)
                                            .parse(state)
                                    {
                                        state = new_state;
                                        type_specifiers.push(Some(type_specifier));
                                    } else {
                                        type_specifiers.push(None);
                                    }
                                }
                            }
                        }
                    } else if let Ok((new_state, ellipse)) =
                        ParseSymbol(Symbol::Ellipse).parse(state)
                    {
                        state = new_state;
                        parameters.push(Pair::new(Parameter::Ellipse(ellipse), None));
                        if false {
                            if let Ok((new_state, type_specifier)) =
                                ParseTypeSpecifier(TypeInfoContext::VarArgSpecifier).parse(state)
                            {
                                state = new_state;
                                type_specifiers.push(Some(type_specifier));
                            } else {
                                type_specifiers.push(None);
                            }
                        }
                    }
                    let (state, end_parenthese) = match ParseSymbol(Symbol::RightParen).parse(state)
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected ')'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    #[allow(unused_variables)]
                    let (state, return_type) = if let Ok((state, return_type)) =
                        ParseTypeSpecifier(TypeInfoContext::ReturnType).parse(state)
                    {
                        (state, Some(return_type))
                    } else {
                        (state, None)
                    };
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        FunctionBody {
                            parameters_parentheses: ContainedSpan::new(
                                start_parenthese,
                                end_parenthese,
                            ),
                            parameters,
                            block,
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseFunction;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunction {
            #[inline]
            fn clone(&self) -> ParseFunction {
                match *self {
                    ParseFunction => ParseFunction,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunction => ::core::fmt::Formatter::write_str(f, "ParseFunction"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunction {
            #[inline]
            fn eq(&self, other: &ParseFunction) -> bool {
                match *other {
                    ParseFunction => match *self {
                        ParseFunction => true,
                    },
                }
            }
        }
        impl Parser for ParseFunction {
            type Item = (TokenReference, FunctionBody);
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, (TokenReference, FunctionBody)), InternalAstError>
            {
                (|_, mut state: ParserState<'a>| {
                    let (state, token) = ParseSymbol(Symbol::Function).parse(state)?;
                    let (state, body) = match ParseFunctionBody.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected function body")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, (token, body)))
                })(self, state)
            }
        }
        struct ParseSuffix;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseSuffix {
            #[inline]
            fn clone(&self) -> ParseSuffix {
                match *self {
                    ParseSuffix => ParseSuffix,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseSuffix {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseSuffix => ::core::fmt::Formatter::write_str(f, "ParseSuffix"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseSuffix {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseSuffix {
            #[inline]
            fn eq(&self, other: &ParseSuffix) -> bool {
                match *other {
                    ParseSuffix => match *self {
                        ParseSuffix => true,
                    },
                }
            }
        }
        impl Parser for ParseSuffix {
            type Item = Suffix;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Suffix), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseCall
                            .parse(state)
                            .map(|(state, node)| (state, Suffix::Call(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseIndex
                            .parse(state)
                            .map(|(state, node)| (state, Suffix::Index(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseVarExpression;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseVarExpression {
            #[inline]
            fn clone(&self) -> ParseVarExpression {
                match *self {
                    ParseVarExpression => ParseVarExpression,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseVarExpression {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseVarExpression => {
                        ::core::fmt::Formatter::write_str(f, "ParseVarExpression")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseVarExpression {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseVarExpression {
            #[inline]
            fn eq(&self, other: &ParseVarExpression) -> bool {
                match *other {
                    ParseVarExpression => match *self {
                        ParseVarExpression => true,
                    },
                }
            }
        }
        impl Parser for ParseVarExpression {
            type Item = VarExpression;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, VarExpression), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, prefix) = ParsePrefix.parse(state)?;
                    let (state, suffixes) = ZeroOrMore(ParseSuffix).parse(state)?;
                    if let Some(Suffix::Index(_)) = suffixes.last() {
                        Ok((state, VarExpression { prefix, suffixes }))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseVar;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseVar {
            #[inline]
            fn clone(&self) -> ParseVar {
                match *self {
                    ParseVar => ParseVar,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseVar {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseVar => ::core::fmt::Formatter::write_str(f, "ParseVar"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseVar {
            #[inline]
            fn default() -> ParseVar {
                ParseVar {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseVar {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseVar {
            #[inline]
            fn eq(&self, other: &ParseVar) -> bool {
                match *other {
                    ParseVar => match *self {
                        ParseVar => true,
                    },
                }
            }
        }
        impl Parser for ParseVar {
            type Item = Var;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Var), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    {
                        let parser_result = ParseVarExpression
                            .parse(state)
                            .map(|(state, node)| (state, Var::Expression(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    {
                        let parser_result = ParseIdentifier
                            .parse(state)
                            .map(|(state, node)| (state, Var::Name(node)));
                        if parser_result != Err(InternalAstError::NoMatch) {
                            return parser_result;
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseAssignment;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseAssignment {
            #[inline]
            fn clone(&self) -> ParseAssignment {
                match *self {
                    ParseAssignment => ParseAssignment,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseAssignment {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseAssignment => ::core::fmt::Formatter::write_str(f, "ParseAssignment"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseAssignment {
            #[inline]
            fn default() -> ParseAssignment {
                ParseAssignment {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseAssignment {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseAssignment {
            #[inline]
            fn eq(&self, other: &ParseAssignment) -> bool {
                match *other {
                    ParseAssignment => match *self {
                        ParseAssignment => true,
                    },
                }
            }
        }
        impl Parser for ParseAssignment {
            type Item = Assignment;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Assignment), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, var_list) =
                        OneOrMore(ParseVar, ParseSymbol(Symbol::Comma), false).parse(state)?;
                    let (state, equal_token) = ParseSymbol(Symbol::Equal).parse(state)?;
                    let (state, expr_list) =
                        match OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                            .parse(state)
                        {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek().clone(),
                                    additional: Some(Cow::from("expected values")),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                    Ok((
                        state,
                        Assignment {
                            var_list,
                            equal_token,
                            expr_list,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseLocalFunction;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseLocalFunction {
            #[inline]
            fn clone(&self) -> ParseLocalFunction {
                match *self {
                    ParseLocalFunction => ParseLocalFunction,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseLocalFunction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseLocalFunction => {
                        ::core::fmt::Formatter::write_str(f, "ParseLocalFunction")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseLocalFunction {
            #[inline]
            fn default() -> ParseLocalFunction {
                ParseLocalFunction {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseLocalFunction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseLocalFunction {
            #[inline]
            fn eq(&self, other: &ParseLocalFunction) -> bool {
                match *other {
                    ParseLocalFunction => match *self {
                        ParseLocalFunction => true,
                    },
                }
            }
        }
        impl Parser for ParseLocalFunction {
            type Item = LocalFunction;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, LocalFunction), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, local_token) = ParseSymbol(Symbol::Local).parse(state)?;
                    let (state, function_token) = ParseSymbol(Symbol::Function).parse(state)?;
                    let (state, name) = match ParseIdentifier.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected name")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, body) = ParseFunctionBody.parse(state)?;
                    Ok((
                        state,
                        LocalFunction {
                            local_token,
                            function_token,
                            name,
                            body,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseLocalAssignment;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseLocalAssignment {
            #[inline]
            fn clone(&self) -> ParseLocalAssignment {
                match *self {
                    ParseLocalAssignment => ParseLocalAssignment,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseLocalAssignment {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseLocalAssignment => {
                        ::core::fmt::Formatter::write_str(f, "ParseLocalAssignment")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseLocalAssignment {
            #[inline]
            fn default() -> ParseLocalAssignment {
                ParseLocalAssignment {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseLocalAssignment {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseLocalAssignment {
            #[inline]
            fn eq(&self, other: &ParseLocalAssignment) -> bool {
                match *other {
                    ParseLocalAssignment => match *self {
                        ParseLocalAssignment => true,
                    },
                }
            }
        }
        impl Parser for ParseLocalAssignment {
            type Item = LocalAssignment;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, LocalAssignment), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (mut state, local_token) = ParseSymbol(Symbol::Local).parse(state)?;
                    let mut name_list;
                    let mut type_specifiers = Vec::new();
                    if false {
                        name_list = Punctuated::new();
                        let (new_state, full_name_list) =
                            match OneOrMore(ParseNameWithType, ParseSymbol(Symbol::Comma), false)
                                .parse(state)
                            {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected name")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        for mut pair in full_name_list.into_pairs() {
                            type_specifiers.push(pair.value_mut().1.take());
                            name_list.push(pair.map(|(name, _)| name));
                        }
                        state = new_state;
                    } else {
                        let (new_state, new_name_list) =
                            match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                                .parse(state)
                            {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected name")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                        state = new_state;
                        name_list = new_name_list;
                    }
                    let ((state, expr_list), equal_token) =
                        match ParseSymbol(Symbol::Equal).parse(state) {
                            Ok((state, equal_token)) => (
                                OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                                    .parse(state)
                                    .map_err(|_| InternalAstError::UnexpectedToken {
                                        token: (*state.peek()).to_owned(),
                                        additional: Some(Cow::from("expected expression")),
                                    })?,
                                Some(equal_token),
                            ),
                            Err(InternalAstError::NoMatch) => ((state, Punctuated::new()), None),
                            Err(other) => return Err(other),
                        };
                    Ok((
                        state,
                        LocalAssignment {
                            local_token,
                            name_list,
                            equal_token,
                            expr_list,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseDo;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseDo {
            #[inline]
            fn clone(&self) -> ParseDo {
                match *self {
                    ParseDo => ParseDo,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseDo {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseDo => ::core::fmt::Formatter::write_str(f, "ParseDo"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseDo {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseDo {
            #[inline]
            fn eq(&self, other: &ParseDo) -> bool {
                match *other {
                    ParseDo => match *self {
                        ParseDo => true,
                    },
                }
            }
        }
        impl Parser for ParseDo {
            type Item = Do;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, Do), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, do_token) = ParseSymbol(Symbol::Do).parse(state)?;
                    let (state, block) = match ParseBlock.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected block")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, end_token) = match ParseSymbol(Symbol::End).parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected 'end'")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        Do {
                            do_token,
                            block,
                            end_token,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseFunctionCall;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunctionCall {
            #[inline]
            fn clone(&self) -> ParseFunctionCall {
                match *self {
                    ParseFunctionCall => ParseFunctionCall,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunctionCall {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunctionCall => ::core::fmt::Formatter::write_str(f, "ParseFunctionCall"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunctionCall {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunctionCall {
            #[inline]
            fn eq(&self, other: &ParseFunctionCall) -> bool {
                match *other {
                    ParseFunctionCall => match *self {
                        ParseFunctionCall => true,
                    },
                }
            }
        }
        impl Parser for ParseFunctionCall {
            type Item = FunctionCall;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, FunctionCall), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, prefix) = ParsePrefix.parse(state)?;
                    let (state, suffixes) = ZeroOrMore(ParseSuffix).parse(state)?;
                    if let Some(Suffix::Call(_)) = suffixes.last() {
                        Ok((state, FunctionCall { prefix, suffixes }))
                    } else {
                        Err(InternalAstError::NoMatch)
                    }
                })(self, state)
            }
        }
        struct ParseFunctionName;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunctionName {
            #[inline]
            fn clone(&self) -> ParseFunctionName {
                match *self {
                    ParseFunctionName => ParseFunctionName,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunctionName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunctionName => ::core::fmt::Formatter::write_str(f, "ParseFunctionName"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunctionName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunctionName {
            #[inline]
            fn eq(&self, other: &ParseFunctionName) -> bool {
                match *other {
                    ParseFunctionName => match *self {
                        ParseFunctionName => true,
                    },
                }
            }
        }
        impl Parser for ParseFunctionName {
            type Item = FunctionName;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, FunctionName), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, names) =
                        OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Dot), false).parse(state)?;
                    let (state, colon_name) =
                        if let Ok((state, colon)) = ParseSymbol(Symbol::Colon).parse(state) {
                            let (state, colon_name) = match ParseIdentifier.parse(state) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek().clone(),
                                        additional: Some(Cow::from("expected method name")),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                            (state, Some((colon, colon_name)))
                        } else {
                            (state, None)
                        };
                    Ok((
                        state,
                        FunctionName {
                            names,
                            colon_name,
                            _phantom: PhantomData,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseFunctionDeclaration;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseFunctionDeclaration {
            #[inline]
            fn clone(&self) -> ParseFunctionDeclaration {
                match *self {
                    ParseFunctionDeclaration => ParseFunctionDeclaration,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseFunctionDeclaration {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseFunctionDeclaration => {
                        ::core::fmt::Formatter::write_str(f, "ParseFunctionDeclaration")
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseFunctionDeclaration {
            #[inline]
            fn default() -> ParseFunctionDeclaration {
                ParseFunctionDeclaration {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseFunctionDeclaration {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseFunctionDeclaration {
            #[inline]
            fn eq(&self, other: &ParseFunctionDeclaration) -> bool {
                match *other {
                    ParseFunctionDeclaration => match *self {
                        ParseFunctionDeclaration => true,
                    },
                }
            }
        }
        impl Parser for ParseFunctionDeclaration {
            type Item = FunctionDeclaration;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, FunctionDeclaration), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let (state, function_token) = ParseSymbol(Symbol::Function).parse(state)?;
                    let (state, name) = match ParseFunctionName.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected function name")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, body) = match ParseFunctionBody.parse(state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek().clone(),
                                additional: Some(Cow::from("expected function body")),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        FunctionDeclaration {
                            function_token,
                            name,
                            body,
                        },
                    ))
                })(self, state)
            }
        }
        struct ParseIdentifier;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseIdentifier {
            #[inline]
            fn clone(&self) -> ParseIdentifier {
                match *self {
                    ParseIdentifier => ParseIdentifier,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseIdentifier {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseIdentifier => ::core::fmt::Formatter::write_str(f, "ParseIdentifier"),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for ParseIdentifier {
            #[inline]
            fn default() -> ParseIdentifier {
                ParseIdentifier {}
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseIdentifier {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseIdentifier {
            #[inline]
            fn eq(&self, other: &ParseIdentifier) -> bool {
                match *other {
                    ParseIdentifier => match *self {
                        ParseIdentifier => true,
                    },
                }
            }
        }
        impl Parser for ParseIdentifier {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    let next_token = state.peek();
                    match next_token.token_kind() {
                        TokenKind::Identifier => Ok((
                            state.advance().ok_or(InternalAstError::NoMatch)?,
                            next_token.clone(),
                        )),
                        _ => Err(InternalAstError::NoMatch),
                    }
                })(self, state)
            }
        }
        enum TypeInfoContext {
            /// The return type of a function declaration or callback type, such as `function foo(bar) -> number`.
            /// This is the only location where Tuple types are allowed. Variadic type infos are also allowed here
            ReturnType,
            /// A type specifier for the variadic argument `...` in a function definition parameter list
            /// In these cases, we are allowed a generic variadic pack `T...` to be specified
            VarArgSpecifier,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TypeInfoContext {
            #[inline]
            fn clone(&self) -> TypeInfoContext {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TypeInfoContext {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TypeInfoContext {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TypeInfoContext::ReturnType,) => {
                        ::core::fmt::Formatter::write_str(f, "ReturnType")
                    }
                    (&TypeInfoContext::VarArgSpecifier,) => {
                        ::core::fmt::Formatter::write_str(f, "VarArgSpecifier")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for TypeInfoContext {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for TypeInfoContext {
            #[inline]
            fn eq(&self, other: &TypeInfoContext) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        struct ParseNameWithType;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseNameWithType {
            #[inline]
            fn clone(&self) -> ParseNameWithType {
                match *self {
                    ParseNameWithType => ParseNameWithType,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseNameWithType {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseNameWithType => ::core::fmt::Formatter::write_str(f, "ParseNameWithType"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseNameWithType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseNameWithType {
            #[inline]
            fn eq(&self, other: &ParseNameWithType) -> bool {
                match *other {
                    ParseNameWithType => match *self {
                        ParseNameWithType => true,
                    },
                }
            }
        }
        impl Parser for ParseNameWithType {
            type Item = (TokenReference, Option<TokenReference>);
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, (TokenReference, Option<TokenReference>)), InternalAstError>
            {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseTypeSpecifier(TypeInfoContext);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseTypeSpecifier {
            #[inline]
            fn clone(&self) -> ParseTypeSpecifier {
                match *self {
                    ParseTypeSpecifier(ref __self_0_0) => {
                        ParseTypeSpecifier(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseTypeSpecifier {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseTypeSpecifier(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ParseTypeSpecifier");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseTypeSpecifier {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseTypeSpecifier {
            #[inline]
            fn eq(&self, other: &ParseTypeSpecifier) -> bool {
                match *other {
                    ParseTypeSpecifier(ref __self_1_0) => match *self {
                        ParseTypeSpecifier(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ParseTypeSpecifier) -> bool {
                match *other {
                    ParseTypeSpecifier(ref __self_1_0) => match *self {
                        ParseTypeSpecifier(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl Parser for ParseTypeSpecifier {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseGenericDeclarationParameter;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseGenericDeclarationParameter {
            #[inline]
            fn clone(&self) -> ParseGenericDeclarationParameter {
                match *self {
                    ParseGenericDeclarationParameter => ParseGenericDeclarationParameter,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseGenericDeclarationParameter {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseGenericDeclarationParameter => {
                        ::core::fmt::Formatter::write_str(f, "ParseGenericDeclarationParameter")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseGenericDeclarationParameter {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseGenericDeclarationParameter {
            #[inline]
            fn eq(&self, other: &ParseGenericDeclarationParameter) -> bool {
                match *other {
                    ParseGenericDeclarationParameter => match *self {
                        ParseGenericDeclarationParameter => true,
                    },
                }
            }
        }
        impl Parser for ParseGenericDeclarationParameter {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseGenericDeclaration;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseGenericDeclaration {
            #[inline]
            fn clone(&self) -> ParseGenericDeclaration {
                match *self {
                    ParseGenericDeclaration => ParseGenericDeclaration,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseGenericDeclaration {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseGenericDeclaration => {
                        ::core::fmt::Formatter::write_str(f, "ParseGenericDeclaration")
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseGenericDeclaration {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseGenericDeclaration {
            #[inline]
            fn eq(&self, other: &ParseGenericDeclaration) -> bool {
                match *other {
                    ParseGenericDeclaration => match *self {
                        ParseGenericDeclaration => true,
                    },
                }
            }
        }
        impl Parser for ParseGenericDeclaration {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseGoto;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseGoto {
            #[inline]
            fn clone(&self) -> ParseGoto {
                match *self {
                    ParseGoto => ParseGoto,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseGoto {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseGoto => ::core::fmt::Formatter::write_str(f, "ParseGoto"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseGoto {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseGoto {
            #[inline]
            fn eq(&self, other: &ParseGoto) -> bool {
                match *other {
                    ParseGoto => match *self {
                        ParseGoto => true,
                    },
                }
            }
        }
        impl Parser for ParseGoto {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseLabel;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseLabel {
            #[inline]
            fn clone(&self) -> ParseLabel {
                match *self {
                    ParseLabel => ParseLabel,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseLabel {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseLabel => ::core::fmt::Formatter::write_str(f, "ParseLabel"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseLabel {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseLabel {
            #[inline]
            fn eq(&self, other: &ParseLabel) -> bool {
                match *other {
                    ParseLabel => match *self {
                        ParseLabel => true,
                    },
                }
            }
        }
        impl Parser for ParseLabel {
            type Item = TokenReference;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, TokenReference), InternalAstError> {
                (|_, _| Err(InternalAstError::NoMatch))(self, state)
            }
        }
        struct ParseBinOp;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseBinOp {
            #[inline]
            fn clone(&self) -> ParseBinOp {
                match *self {
                    ParseBinOp => ParseBinOp,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseBinOp {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseBinOp => ::core::fmt::Formatter::write_str(f, "ParseBinOp"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseBinOp {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseBinOp {
            #[inline]
            fn eq(&self, other: &ParseBinOp) -> bool {
                match *other {
                    ParseBinOp => match *self {
                        ParseBinOp => true,
                    },
                }
            }
        }
        impl Parser for ParseBinOp {
            type Item = BinOp;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, BinOp), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, operator)) = ParseSymbol(Symbol::And).parse(state) {
                        return Ok((state, BinOp::And(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Caret).parse(state) {
                        return Ok((state, BinOp::Caret(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::GreaterThan).parse(state) {
                        return Ok((state, BinOp::GreaterThan(operator)));
                    }
                    if let Ok((state, operator)) =
                        ParseSymbol(Symbol::GreaterThanEqual).parse(state)
                    {
                        return Ok((state, BinOp::GreaterThanEqual(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::LessThan).parse(state) {
                        return Ok((state, BinOp::LessThan(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::LessThanEqual).parse(state) {
                        return Ok((state, BinOp::LessThanEqual(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Minus).parse(state) {
                        return Ok((state, BinOp::Minus(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Or).parse(state) {
                        return Ok((state, BinOp::Or(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Percent).parse(state) {
                        return Ok((state, BinOp::Percent(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Plus).parse(state) {
                        return Ok((state, BinOp::Plus(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Slash).parse(state) {
                        return Ok((state, BinOp::Slash(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Star).parse(state) {
                        return Ok((state, BinOp::Star(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::TildeEqual).parse(state) {
                        return Ok((state, BinOp::TildeEqual(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::TwoDots).parse(state) {
                        return Ok((state, BinOp::TwoDots(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::TwoEqual).parse(state) {
                        return Ok((state, BinOp::TwoEqual(operator)));
                    }
                    if let Some(x) = None {
                        match x {
                            BinOp::And(_) => {}
                            BinOp::Caret(_) => {}
                            BinOp::GreaterThan(_) => {}
                            BinOp::GreaterThanEqual(_) => {}
                            BinOp::LessThan(_) => {}
                            BinOp::LessThanEqual(_) => {}
                            BinOp::Minus(_) => {}
                            BinOp::Or(_) => {}
                            BinOp::Percent(_) => {}
                            BinOp::Plus(_) => {}
                            BinOp::Slash(_) => {}
                            BinOp::Star(_) => {}
                            BinOp::TildeEqual(_) => {}
                            BinOp::TwoDots(_) => {}
                            BinOp::TwoEqual(_) => {}
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
        struct ParseUnOp;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ParseUnOp {
            #[inline]
            fn clone(&self) -> ParseUnOp {
                match *self {
                    ParseUnOp => ParseUnOp,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ParseUnOp {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ParseUnOp => ::core::fmt::Formatter::write_str(f, "ParseUnOp"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ParseUnOp {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ParseUnOp {
            #[inline]
            fn eq(&self, other: &ParseUnOp) -> bool {
                match *other {
                    ParseUnOp => match *self {
                        ParseUnOp => true,
                    },
                }
            }
        }
        impl Parser for ParseUnOp {
            type Item = UnOp;
            #[allow(unused_mut)]
            fn parse<'a>(
                &self,
                state: ParserState<'a>,
            ) -> Result<(ParserState<'a>, UnOp), InternalAstError> {
                (|_, mut state: ParserState<'a>| {
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Minus).parse(state) {
                        return Ok((state, UnOp::Minus(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Not).parse(state) {
                        return Ok((state, UnOp::Not(operator)));
                    }
                    if let Ok((state, operator)) = ParseSymbol(Symbol::Hash).parse(state) {
                        return Ok((state, UnOp::Hash(operator)));
                    }
                    if let Some(x) = None {
                        match x {
                            UnOp::Minus(_) => {}
                            UnOp::Not(_) => {}
                            UnOp::Hash(_) => {}
                        }
                    }
                    Err(InternalAstError::NoMatch)
                })(self, state)
            }
        }
    }
    pub mod punctuated {
        //! A punctuated sequence of syntax tree nodes separated by punctuation (tokens).
        //!
        //! Examples of punctuated sequences include:
        //! - Arguments in a function call are `Punctuated<Expression>`
        //! - Names and definitions in a local assignment are `Punctuated<TokenReference>` and `Punctuated<Expression>` respectively
        //! - The values of a return statement are `Punctuated<Expression>`
        //!
        //! Everything with punctuation uses the [`Punctuated<T>`](Punctuated) type with the following logic.
        //! ```rust
        //! # use full_moon::parse;
        //! # fn main() -> Result<(), Box<std::error::Error>> {
        //! let ast = parse("call(arg1, arg2, arg3)")?;
        //! //                   ^^^^^ ~~~~~ ^^^^^
        //! # Ok(())
        //! # }
        //! ```
        use crate::{
            node::{Node, TokenItem, Tokens},
            private::Sealed,
            tokenizer::{Position, TokenReference},
            util,
            visitors::{Visit, VisitMut, Visitor, VisitorMut},
        };
        use derive_more::Display;
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        use std::{fmt::Display, iter::FromIterator};
        /// A punctuated sequence of node `T` separated by
        /// [`TokenReference`](crate::tokenizer::TokenReference).
        /// Refer to the [module documentation](index.html) for more details.
        #[display(bound = "T: Display")]
        #[display(fmt = "{}", "util::join_vec(pairs)")]
        pub struct Punctuated<T> {
            pairs: Vec<Pair<T>>,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for Punctuated<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "pairs" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"pairs" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Punctuated<T>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = Punctuated<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Punctuated")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Vec<Pair<T>>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Punctuated with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(Punctuated { pairs: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Vec<Pair<T>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pairs",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<Pair<T>>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("pairs") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Punctuated { pairs: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["pairs"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Punctuated",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Punctuated<T>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<T> _serde::Serialize for Punctuated<T>
            where
                T: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Punctuated",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pairs",
                        &self.pairs,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for Punctuated<T> {
            #[inline]
            fn clone(&self) -> Punctuated<T> {
                match *self {
                    Punctuated {
                        pairs: ref __self_0_0,
                    } => Punctuated {
                        pairs: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Punctuated<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Punctuated {
                        pairs: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Punctuated");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "pairs",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::default::Default> ::core::default::Default for Punctuated<T> {
            #[inline]
            fn default() -> Punctuated<T> {
                Punctuated {
                    pairs: ::core::default::Default::default(),
                }
            }
        }
        impl<T> ::core::fmt::Display for Punctuated<T>
        where
            T: Display,
        {
            #[allow(unused_variables)]
            #[inline]
            fn fmt(
                &self,
                _derive_more_display_formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                match self {
                    Punctuated { pairs } => {
                        _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&util::join_vec(pairs),) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                    _ => Ok(()),
                }
            }
        }
        impl<T> ::core::marker::StructuralPartialEq for Punctuated<T> {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Punctuated<T> {
            #[inline]
            fn eq(&self, other: &Punctuated<T>) -> bool {
                match *other {
                    Punctuated {
                        pairs: ref __self_1_0,
                    } => match *self {
                        Punctuated {
                            pairs: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Punctuated<T>) -> bool {
                match *other {
                    Punctuated {
                        pairs: ref __self_1_0,
                    } => match *self {
                        Punctuated {
                            pairs: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl<T> Punctuated<T> {
            /// Creates an empty punctuated sequence
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated: Punctuated<i32> = Punctuated::new();
            /// ```
            pub fn new() -> Self {
                Self { pairs: Vec::new() }
            }
            /// Returns whether there's any nodes in the punctuated sequence
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// assert!(punctuated.is_empty());
            /// punctuated.push(Pair::new((), None));
            /// assert!(!punctuated.is_empty());
            /// ```
            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }
            /// Returns the number of pairs in the punctuated sequence
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// assert_eq!(punctuated.len(), 0);
            /// punctuated.push(Pair::new((), None));
            /// assert_eq!(punctuated.len(), 1);
            /// ```
            pub fn len(&self) -> usize {
                self.pairs.len()
            }
            /// Returns an iterator over references of the sequence values, ignoring punctuation
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// let mut iterator = punctuated.iter();
            /// assert_eq!(iterator.next(), Some(&1));
            /// assert_eq!(iterator.next(), None);
            /// ```
            pub fn iter(&self) -> Iter<'_, T> {
                self.into_iter()
            }
            /// Returns an iterator over mutable references of the sequence values, ignoring punctuation
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// for item in punctuated.iter_mut() {
            ///     *item += 1;
            /// }
            /// assert_eq!(punctuated.pop(), Some(Pair::new(2, None)));
            /// ```
            pub fn iter_mut(&mut self) -> IterMut<'_, T> {
                self.into_iter()
            }
            /// Returns an iterator over pairs
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// let mut iterator = punctuated.into_pairs();
            /// assert_eq!(iterator.next(), Some(Pair::new(1, None)));
            /// assert_eq!(iterator.next(), None);
            /// ```
            pub fn into_pairs(self) -> impl Iterator<Item = Pair<T>> {
                self.pairs.into_iter()
            }
            /// Returns the last pair in the sequence
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// assert_eq!(punctuated.last(), Some(&Pair::new(1, None)));
            /// ```
            pub fn last(&self) -> Option<&Pair<T>> {
                self.pairs.last()
            }
            /// Returns an iterator over pairs as references
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// let mut iterator = punctuated.pairs();
            /// assert_eq!(iterator.next(), Some(&Pair::new(1, None)));
            /// assert_eq!(iterator.next(), None);
            /// ```
            pub fn pairs(&self) -> impl Iterator<Item = &Pair<T>> {
                self.pairs.iter()
            }
            /// Returns an iterator over pairs as mutable references
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// for item in punctuated.pairs_mut() {
            ///     *item.value_mut() += 1;
            /// }
            /// assert_eq!(punctuated.pop(), Some(Pair::new(2, None)));
            /// ```
            pub fn pairs_mut(&mut self) -> impl Iterator<Item = &mut Pair<T>> {
                self.pairs.iter_mut()
            }
            /// Pops off the last pair if it isn't empty
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// assert_eq!(punctuated.pop(), Some(Pair::new(1, None)));
            /// ```
            pub fn pop(&mut self) -> Option<Pair<T>> {
                self.pairs.pop()
            }
            /// Pushes a new pair onto the sequence
            /// ```rust
            /// # use full_moon::ast::punctuated::{Pair, Punctuated};
            /// let mut punctuated = Punctuated::new();
            /// punctuated.push(Pair::new(1, None));
            /// assert_eq!(punctuated.pop(), Some(Pair::new(1, None)));
            /// ```
            pub fn push(&mut self, pair: Pair<T>) {
                self.pairs.push(pair);
            }
        }
        impl<T> Sealed for Punctuated<T> {}
        impl<T: Node> Node for Punctuated<T> {
            fn start_position(&self) -> Option<Position> {
                self.pairs.first()?.start_position()
            }
            fn end_position(&self) -> Option<Position> {
                self.pairs.last()?.end_position()
            }
            fn similar(&self, other: &Self) -> bool {
                self.into_iter()
                    .collect::<Vec<_>>()
                    .similar(&other.into_iter().collect::<Vec<_>>())
            }
            fn tokens(&self) -> Tokens {
                self.pairs.tokens()
            }
        }
        impl<T: Visit> Visit for Punctuated<T> {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                self.pairs.visit(visitor);
            }
        }
        impl<T: VisitMut> VisitMut for Punctuated<T> {
            fn visit_mut<V: VisitorMut>(self, visitor: &mut V) -> Self {
                Punctuated {
                    pairs: self.pairs.visit_mut(visitor),
                }
            }
        }
        impl<T> std::iter::Extend<Pair<T>> for Punctuated<T> {
            fn extend<I: IntoIterator<Item = Pair<T>>>(&mut self, iter: I) {
                self.pairs.extend(iter);
            }
        }
        impl<T> IntoIterator for Punctuated<T> {
            type Item = T;
            type IntoIter = IntoIter<T>;
            fn into_iter(self) -> Self::IntoIter {
                IntoIter {
                    inner: self.pairs.into_iter(),
                }
            }
        }
        impl<T> FromIterator<Pair<T>> for Punctuated<T> {
            fn from_iter<I: IntoIterator<Item = Pair<T>>>(iter: I) -> Self {
                Punctuated {
                    pairs: iter.into_iter().collect(),
                }
            }
        }
        impl<'a, T> IntoIterator for &'a Punctuated<T> {
            type Item = &'a T;
            type IntoIter = Iter<'a, T>;
            fn into_iter(self) -> Self::IntoIter {
                Iter {
                    inner: self.pairs.iter(),
                }
            }
        }
        impl<'a, T> IntoIterator for &'a mut Punctuated<T> {
            type Item = &'a mut T;
            type IntoIter = IterMut<'a, T>;
            fn into_iter(self) -> Self::IntoIter {
                IterMut {
                    inner: self.pairs.iter_mut(),
                }
            }
        }
        /// An iterator over owned values of type `T`.
        /// Refer to the [module documentation](index.html) for more details.
        pub struct IntoIter<T> {
            inner: std::vec::IntoIter<Pair<T>>,
        }
        impl<T> Iterator for IntoIter<T> {
            type Item = T;
            fn next(&mut self) -> Option<Self::Item> {
                Some(self.inner.next()?.into_value())
            }
        }
        /// An iterator over borrowed values of type `&T`.
        /// Refer to the [module documentation](index.html) for more details.
        pub struct Iter<'a, T> {
            inner: std::slice::Iter<'a, Pair<T>>,
        }
        impl<'a, T> Iterator for Iter<'a, T> {
            type Item = &'a T;
            fn next(&mut self) -> Option<Self::Item> {
                Some(self.inner.next()?.value())
            }
        }
        /// An iterator over borrowed values of type `&mut T`.
        /// Refer to the [module documentation](index.html) for more details.
        pub struct IterMut<'a, T> {
            inner: std::slice::IterMut<'a, Pair<T>>,
        }
        impl<'a, T> Iterator for IterMut<'a, T> {
            type Item = &'a mut T;
            fn next(&mut self) -> Option<Self::Item> {
                Some(self.inner.next()?.value_mut())
            }
        }
        /// A node `T` followed by the possible trailing
        /// [`TokenReference`](crate::tokenizer::TokenReference).
        /// Refer to the [module documentation](index.html) for more details.
        pub enum Pair<T> {
            /// A node `T` with no trailing punctuation
            #[display(fmt = "{}", "_0")]
            End(T),
            /// A node `T` followed by punctuation (in the form of a
            /// [`TokenReference`](crate::tokenizer::TokenReference))
            #[display(fmt = "{}{}", "_0", "_1")]
            Punctuated(T, TokenReference),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de, T> _serde::Deserialize<'de> for Pair<T>
            where
                T: _serde::Deserialize<'de>,
            {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "variant identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "End" => _serde::export::Ok(__Field::__field0),
                                "Punctuated" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"End" => _serde::export::Ok(__Field::__field0),
                                b"Punctuated" => _serde::export::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::export::from_utf8_lossy(__value);
                                    _serde::export::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Pair<T>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                    where
                        T: _serde::Deserialize<'de>,
                    {
                        type Value = Pair<T>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "enum Pair")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => _serde::export::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<T>(__variant),
                                    Pair::End,
                                ),
                                (__Field::__field1, __variant) => {
                                    struct __Visitor<'de, T>
                                    where
                                        T: _serde::Deserialize<'de>,
                                    {
                                        marker: _serde::export::PhantomData<Pair<T>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                                    where
                                        T: _serde::Deserialize<'de>,
                                    {
                                        type Value = Pair<T>;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::export::Formatter,
                                        ) -> _serde::export::fmt::Result
                                        {
                                            _serde::export::Formatter::write_str(
                                                __formatter,
                                                "tuple variant Pair::Punctuated",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::export::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 =
                                                match match _serde::de::SeqAccess::next_element::<T>(
                                                    &mut __seq,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                } {
                                                    _serde::export::Some(__value) => __value,
                                                    _serde::export::None => {
                                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "tuple variant Pair::Punctuated with 2 elements")) ;
                                                    }
                                                };
                                            let __field1 =
                                                match match _serde::de::SeqAccess::next_element::<
                                                    TokenReference,
                                                >(
                                                    &mut __seq
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                } {
                                                    _serde::export::Some(__value) => __value,
                                                    _serde::export::None => {
                                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "tuple variant Pair::Punctuated with 2 elements")) ;
                                                    }
                                                };
                                            _serde::export::Ok(Pair::Punctuated(__field0, __field1))
                                        }
                                    }
                                    _serde::de::VariantAccess::tuple_variant(
                                        __variant,
                                        2usize,
                                        __Visitor {
                                            marker: _serde::export::PhantomData::<Pair<T>>,
                                            lifetime: _serde::export::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["End", "Punctuated"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Pair",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Pair<T>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<T> _serde::Serialize for Pair<T>
            where
                T: _serde::Serialize,
            {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        Pair::End(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Pair",
                            0u32,
                            "End",
                            __field0,
                        ),
                        Pair::Punctuated(ref __field0, ref __field1) => {
                            let mut __serde_state =
                                match _serde::Serializer::serialize_tuple_variant(
                                    __serializer,
                                    "Pair",
                                    1u32,
                                    "Punctuated",
                                    0 + 1 + 1,
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            match _serde::ser::SerializeTupleVariant::serialize_field(
                                &mut __serde_state,
                                __field0,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            match _serde::ser::SerializeTupleVariant::serialize_field(
                                &mut __serde_state,
                                __field1,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::ser::SerializeTupleVariant::end(__serde_state)
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::clone::Clone> ::core::clone::Clone for Pair<T> {
            #[inline]
            fn clone(&self) -> Pair<T> {
                match (&*self,) {
                    (&Pair::End(ref __self_0),) => {
                        Pair::End(::core::clone::Clone::clone(&(*__self_0)))
                    }
                    (&Pair::Punctuated(ref __self_0, ref __self_1),) => Pair::Punctuated(
                        ::core::clone::Clone::clone(&(*__self_0)),
                        ::core::clone::Clone::clone(&(*__self_1)),
                    ),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Pair<T> {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Pair::End(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "End");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&Pair::Punctuated(ref __self_0, ref __self_1),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Punctuated");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_1));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl<T> ::core::fmt::Display for Pair<T>
        where
            T: ::core::fmt::Display,
        {
            #[allow(unused_variables)]
            #[inline]
            fn fmt(
                &self,
                _derive_more_display_formatter: &mut ::core::fmt::Formatter,
            ) -> ::core::fmt::Result {
                match self {
                    Pair::End(_0) => {
                        _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&_0,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                    Pair::Punctuated(_0, _1) => {
                        _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &["", ""],
                            &match (&_0, &_1) {
                                (arg0, arg1) => [
                                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ],
                            },
                        ))
                    }
                    _ => Ok(()),
                }
            }
        }
        impl<T> ::core::marker::StructuralPartialEq for Pair<T> {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<T: ::core::cmp::PartialEq> ::core::cmp::PartialEq for Pair<T> {
            #[inline]
            fn eq(&self, other: &Pair<T>) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Pair::End(ref __self_0), &Pair::End(ref __arg_1_0)) => {
                                (*__self_0) == (*__arg_1_0)
                            }
                            (
                                &Pair::Punctuated(ref __self_0, ref __self_1),
                                &Pair::Punctuated(ref __arg_1_0, ref __arg_1_1),
                            ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Pair<T>) -> bool {
                {
                    let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                    let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (&Pair::End(ref __self_0), &Pair::End(ref __arg_1_0)) => {
                                (*__self_0) != (*__arg_1_0)
                            }
                            (
                                &Pair::Punctuated(ref __self_0, ref __self_1),
                                &Pair::Punctuated(ref __arg_1_0, ref __arg_1_1),
                            ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                            _ => unsafe { ::core::intrinsics::unreachable() },
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl<T> Pair<T> {
            /// Creates a `Pair` with node `T` and optional punctuation
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(1, None);
            /// ```
            pub fn new(value: T, punctuation: Option<TokenReference>) -> Self {
                match punctuation {
                    None => Pair::End(value),
                    Some(punctuation) => Pair::Punctuated(value, punctuation),
                }
            }
            /// Takes the `Pair` and returns the node `T` and the punctuation, if it exists as a tuple
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(1, None);
            /// assert_eq!(pair.into_tuple(), (1, None));
            /// ```
            pub fn into_tuple(self) -> (T, Option<TokenReference>) {
                match self {
                    Pair::End(value) => (value, None),
                    Pair::Punctuated(value, punctuation) => (value, Some(punctuation)),
                }
            }
            /// Takes the `Pair` and returns the node `T`
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(1, None);
            /// assert_eq!(pair.into_value(), 1);
            /// ```
            pub fn into_value(self) -> T {
                self.into_tuple().0
            }
            /// Returns a reference to the node `T`
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(1, None);
            /// assert_eq!(pair.value(), &1);
            /// ```
            pub fn value(&self) -> &T {
                match self {
                    Pair::End(value) => value,
                    Pair::Punctuated(value, _) => value,
                }
            }
            /// Returns a mutable reference to the node `T`
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let mut pair = Pair::new(1, None);
            /// *pair.value_mut() += 1;
            /// assert_eq!(pair.into_value(), 2);
            /// ```
            pub fn value_mut(&mut self) -> &mut T {
                match self {
                    Pair::End(value) => value,
                    Pair::Punctuated(value, _) => value,
                }
            }
            /// Returns the trailing punctuation, if it exists
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(1, None);
            /// assert_eq!(pair.punctuation(), None);
            /// ```
            pub fn punctuation(&self) -> Option<&TokenReference> {
                match self {
                    Pair::End(_) => None,
                    Pair::Punctuated(_, punctuation) => Some(punctuation),
                }
            }
            /// Maps a `Pair<T>` to a `Pair<U>` by applying a function to the value of the pair,
            /// while preserving punctuation if it is not the end.
            /// ```rust
            /// # use full_moon::ast::punctuated::Pair;
            /// let pair = Pair::new(2, None);
            /// assert_eq!(*pair.map(|i| i * 2).value(), 4);
            /// ```
            pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Pair<U> {
                match self {
                    Pair::End(value) => Pair::End(f(value)),
                    Pair::Punctuated(value, punctuated) => Pair::Punctuated(f(value), punctuated),
                }
            }
        }
        impl<T> Sealed for Pair<T> {}
        impl<T: Node> Node for Pair<T> {
            fn start_position(&self) -> Option<Position> {
                self.value().start_position()
            }
            fn end_position(&self) -> Option<Position> {
                self.punctuation()
                    .and_then(Node::end_position)
                    .or_else(|| self.value().end_position())
            }
            fn similar(&self, other: &Self) -> bool {
                self.value().similar(other.value())
            }
            fn tokens(&self) -> Tokens {
                match self {
                    Pair::Punctuated(node, separator) => {
                        let mut items = node.tokens().items;
                        items.push(TokenItem::TokenReference(separator));
                        Tokens { items }
                    }
                    Pair::End(node) => node.tokens(),
                }
            }
        }
        impl<T: Visit> Visit for Pair<T> {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                match self {
                    Pair::End(value) => value.visit(visitor),
                    Pair::Punctuated(value, punctuation) => {
                        value.visit(visitor);
                        punctuation.visit(visitor);
                    }
                }
            }
        }
        impl<T: VisitMut> VisitMut for Pair<T> {
            fn visit_mut<V: VisitorMut>(self, visitor: &mut V) -> Self {
                match self {
                    Pair::End(value) => Pair::End(value.visit_mut(visitor)),
                    Pair::Punctuated(value, punctuation) => {
                        Pair::Punctuated(value.visit_mut(visitor), punctuation.visit_mut(visitor))
                    }
                }
            }
        }
    }
    pub mod span {
        //! A representation of a "contained span", or a span within specific bounds.
        //!
        //! Examples of contained spans include:
        //! - Arguments in a function call use parentheses `(...)`
        //! - Indexing a table uses brackets `[...]`
        //! - Creating a table uses braces `{...}`
        //!
        //! Contained spans don't contain the inner data, just the start and end bounds.
        use crate::{
            node::{Node, Tokens},
            private::Sealed,
            tokenizer::{Position, TokenReference},
        };
        use full_moon_derive::Visit;
        #[cfg(feature = "serde")]
        use serde::{Deserialize, Serialize};
        /// A contained span with the beginning and ending bounds.
        /// Refer to the [module documentation](index.html) for more details.
        pub struct ContainedSpan {
            pub(crate) tokens: (TokenReference, TokenReference),
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ContainedSpan {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "tokens" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"tokens" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<ContainedSpan>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ContainedSpan;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct ContainedSpan",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<(
                                TokenReference,
                                TokenReference,
                            )>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ContainedSpan with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(ContainedSpan { tokens: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<(
                                TokenReference,
                                TokenReference,
                            )> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tokens",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<(
                                                TokenReference,
                                                TokenReference,
                                            )>(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("tokens") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(ContainedSpan { tokens: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["tokens"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ContainedSpan",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<ContainedSpan>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ContainedSpan {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ContainedSpan",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tokens",
                        &self.tokens,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ContainedSpan {
            #[inline]
            fn clone(&self) -> ContainedSpan {
                match *self {
                    ContainedSpan {
                        tokens: ref __self_0_0,
                    } => ContainedSpan {
                        tokens: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ContainedSpan {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ContainedSpan {
                        tokens: ref __self_0_0,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "ContainedSpan");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "tokens",
                            &&(*__self_0_0),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ContainedSpan {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ContainedSpan {
            #[inline]
            fn eq(&self, other: &ContainedSpan) -> bool {
                match *other {
                    ContainedSpan {
                        tokens: ref __self_1_0,
                    } => match *self {
                        ContainedSpan {
                            tokens: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ContainedSpan) -> bool {
                match *other {
                    ContainedSpan {
                        tokens: ref __self_1_0,
                    } => match *self {
                        ContainedSpan {
                            tokens: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl crate::visitors::Visit for ContainedSpan {
            fn visit<V: crate::visitors::Visitor>(&self, visitor: &mut V) {
                visitor.visit_contained_span(self);
                self.tokens.visit(visitor);
                visitor.visit_contained_span_end(self);
            }
        }
        impl crate::visitors::VisitMut for ContainedSpan {
            fn visit_mut<V: crate::visitors::VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_contained_span(self);
                self.tokens = self.tokens.visit_mut(visitor);
                self = visitor.visit_contained_span_end(self);
                self
            }
        }
        impl ContainedSpan {
            /// Creates a contained span from the start and end bounds
            pub fn new(start: TokenReference, end: TokenReference) -> Self {
                Self {
                    tokens: (start, end),
                }
            }
            /// Returns the start and end bounds in a tuple as references
            pub fn tokens(&self) -> (&TokenReference, &TokenReference) {
                (&self.tokens.0, &self.tokens.1)
            }
        }
        impl Node for ContainedSpan {
            fn start_position(&self) -> Option<Position> {
                self.tokens.0.start_position()
            }
            fn end_position(&self) -> Option<Position> {
                self.tokens.1.end_position()
            }
            fn similar(&self, other: &Self) -> bool {
                self.tokens.0.similar(&other.tokens.0) && self.tokens.1.similar(&other.tokens.1)
            }
            fn tokens(&self) -> Tokens {
                self.tokens.tokens()
            }
        }
        impl Sealed for ContainedSpan {}
    }
    mod update_positions {
        use crate::{
            ast::Ast,
            tokenizer::{Position, Token, TokenKind, TokenReference},
            visitors::VisitorMut,
        };
        struct UpdatePositionsRewriter {
            start_position: Position,
            next_is_new_line: bool,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for UpdatePositionsRewriter {
            #[inline]
            fn default() -> UpdatePositionsRewriter {
                UpdatePositionsRewriter {
                    start_position: ::core::default::Default::default(),
                    next_is_new_line: ::core::default::Default::default(),
                }
            }
        }
        impl UpdatePositionsRewriter {
            fn update_token(&mut self, token: &Token) -> Token {
                let display = token.to_string();
                let mut end_position = self.start_position;
                if token.token_kind() != TokenKind::Eof {
                    for character in display.chars() {
                        if self.next_is_new_line {
                            self.next_is_new_line = false;
                            end_position.line += 1;
                            end_position.character = 1;
                        }
                        if character == '\n' {
                            self.next_is_new_line = true;
                        } else {
                            end_position.character += 1;
                        }
                        end_position.bytes += character.len_utf8();
                    }
                }
                let result = Token {
                    start_position: self.start_position,
                    end_position,
                    token_type: token.token_type.to_owned(),
                };
                if self.next_is_new_line {
                    self.next_is_new_line = false;
                    end_position.line += 1;
                    end_position.character = 1;
                }
                self.start_position = end_position;
                result
            }
        }
        impl VisitorMut for UpdatePositionsRewriter {
            fn visit_token_reference(&mut self, token: TokenReference) -> TokenReference {
                TokenReference::new(
                    token
                        .leading_trivia()
                        .map(|token| self.update_token(token))
                        .collect(),
                    self.update_token(token.token()),
                    token
                        .trailing_trivia()
                        .map(|token| self.update_token(token))
                        .collect(),
                )
            }
        }
        impl Ast {
            /// Will update the positions of all the tokens in the tree
            /// Necessary if you are both mutating the tree and need the positions of the tokens
            pub fn update_positions(self) -> Self {
                let mut rewriter = UpdatePositionsRewriter {
                    start_position: Position {
                        bytes: 0,
                        character: 1,
                        line: 1,
                    },
                    ..Default::default()
                };
                rewriter.visit_ast(self)
            }
        }
    }
    mod visitors {
        use super::*;
        use crate::visitors::{Visit, VisitMut, Visitor, VisitorMut};
        impl Visit for Field {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_field(self);
                match self {
                    Field::ExpressionKey {
                        brackets,
                        key,
                        equal,
                        value,
                    } => {
                        brackets.tokens.0.visit(visitor);
                        key.visit(visitor);
                        brackets.tokens.1.visit(visitor);
                        equal.visit(visitor);
                        value.visit(visitor);
                    }
                    Field::NameKey { key, equal, value } => {
                        key.visit(visitor);
                        equal.visit(visitor);
                        value.visit(visitor);
                    }
                    Field::NoKey(__self_0) => {
                        __self_0.visit(visitor);
                    }
                    Field::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit(Field::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                    }
                };
                visitor.visit_field_end(self);
            }
        }
        impl VisitMut for Field {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_field(self);
                self = match self {
                    Field::ExpressionKey {
                        mut brackets,
                        mut key,
                        equal,
                        value,
                    } => {
                        brackets.tokens.0 = brackets.tokens.0.visit_mut(visitor);
                        key = key.visit_mut(visitor);
                        brackets.tokens.1 = brackets.tokens.1.visit_mut(visitor);
                        Field::ExpressionKey {
                            brackets,
                            key,
                            equal: equal.visit_mut(visitor),
                            value: value.visit_mut(visitor),
                        }
                    }
                    Field::NameKey { key, equal, value } => Field::NameKey {
                        key: key.visit_mut(visitor),
                        equal: equal.visit_mut(visitor),
                        value: value.visit_mut(visitor),
                    },
                    Field::NoKey(__self_0) => Field::NoKey(__self_0.visit_mut(visitor)),
                    Field::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit_mut(Field::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                self = visitor.visit_field_end(self);
                self
            }
        }
        impl Visit for Expression {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_expression(self);
                match self {
                    Expression::BinaryOperator { lhs, binop, rhs } => {
                        lhs.visit(visitor);
                        binop.visit(visitor);
                        rhs.visit(visitor);
                    }
                    Expression::Parentheses {
                        contained,
                        expression,
                    } => {
                        contained.tokens.0.visit(visitor);
                        expression.visit(visitor);
                        contained.tokens.1.visit(visitor);
                    }
                    Expression::UnaryOperator { unop, expression } => {
                        unop.visit(visitor);
                        expression.visit(visitor);
                    }
                    Expression::Value { value } => {
                        value.visit(visitor);
                    }
                    Expression::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit(Expression::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                visitor.visit_expression_end(self);
            }
        }
        impl VisitMut for Expression {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_expression(self);
                self = match self {
                    Expression::BinaryOperator { lhs, binop, rhs } => Expression::BinaryOperator {
                        lhs: lhs.visit_mut(visitor),
                        binop: binop.visit_mut(visitor),
                        rhs: rhs.visit_mut(visitor),
                    },
                    Expression::Parentheses {
                        mut contained,
                        mut expression,
                    } => {
                        contained.tokens.0 = contained.tokens.0.visit_mut(visitor);
                        expression = expression.visit_mut(visitor);
                        contained.tokens.1 = contained.tokens.1.visit_mut(visitor);
                        Expression::Parentheses {
                            contained,
                            expression,
                        }
                    }
                    Expression::UnaryOperator { unop, expression } => Expression::UnaryOperator {
                        unop: unop.visit_mut(visitor),
                        expression: expression.visit_mut(visitor),
                    },
                    Expression::Value { value } => Expression::Value {
                        value: value.visit_mut(visitor),
                    },
                    Expression::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit_mut(Expression::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                self = visitor.visit_expression_end(self);
                self
            }
        }
        impl Visit for Index {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_index(self);
                match self {
                    Index::Brackets {
                        brackets,
                        expression,
                    } => {
                        brackets.tokens.0.visit(visitor);
                        expression.visit(visitor);
                        brackets.tokens.1.visit(visitor);
                    }
                    Index::Dot { dot, name } => {
                        dot.visit(visitor);
                        name.visit(visitor);
                    }
                    Index::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit(Index::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                visitor.visit_index_end(self);
            }
        }
        impl VisitMut for Index {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_index(self);
                self = match self {
                    Index::Brackets {
                        mut brackets,
                        mut expression,
                    } => {
                        brackets.tokens.0 = brackets.tokens.0.visit_mut(visitor);
                        expression = expression.visit_mut(visitor);
                        brackets.tokens.1 = brackets.tokens.1.visit_mut(visitor);
                        Index::Brackets {
                            brackets,
                            expression,
                        }
                    }
                    Index::Dot { dot, name } => Index::Dot {
                        dot: dot.visit_mut(visitor),
                        name: name.visit_mut(visitor),
                    },
                    Index::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit_mut(Index::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                self = visitor.visit_index_end(self);
                self
            }
        }
        impl Visit for FunctionArgs {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_function_args(self);
                match self {
                    FunctionArgs::Parentheses {
                        parentheses,
                        arguments,
                    } => {
                        parentheses.tokens.0.visit(visitor);
                        arguments.visit(visitor);
                        parentheses.tokens.1.visit(visitor);
                    }
                    FunctionArgs::String(__self_0) => {
                        __self_0.visit(visitor);
                    }
                    FunctionArgs::TableConstructor(__self_0) => {
                        __self_0.visit(visitor);
                    }
                    FunctionArgs::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit(FunctionArgs::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                visitor.visit_function_args_end(self);
            }
        }
        impl VisitMut for FunctionArgs {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_function_args(self);
                self = match self {
                    FunctionArgs::Parentheses {
                        mut parentheses,
                        mut arguments,
                    } => {
                        parentheses.tokens.0 = parentheses.tokens.0.visit_mut(visitor);
                        arguments = arguments.visit_mut(visitor);
                        parentheses.tokens.1 = parentheses.tokens.1.visit_mut(visitor);
                        FunctionArgs::Parentheses {
                            parentheses,
                            arguments,
                        }
                    }
                    FunctionArgs::String(__self_0) => {
                        FunctionArgs::String(__self_0.visit_mut(visitor))
                    }
                    FunctionArgs::TableConstructor(__self_0) => {
                        FunctionArgs::TableConstructor(__self_0.visit_mut(visitor))
                    }
                    FunctionArgs::Plugin(__self_0) => {
                        ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                            &["not implemented: "],
                            &match (&::core::fmt::Arguments::new_v1(
                                &["visit_mut(FunctionArgs::Plugin)"],
                                &match () {
                                    () => [],
                                },
                            ),)
                            {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                };
                self = visitor.visit_function_args_end(self);
                self
            }
        }
        impl Visit for FunctionBody {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_function_body(self);
                self.parameters_parentheses.tokens.0.visit(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                for parameter in &self.parameters {
                    parameter.visit(visitor);
                    type_specifiers.next().visit(visitor);
                }
                self.parameters_parentheses.tokens.1.visit(visitor);
                self.block.visit(visitor);
                self.end_token.visit(visitor);
                visitor.visit_function_body_end(self);
            }
        }
        impl VisitMut for FunctionBody {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_function_body(self);
                self.parameters_parentheses.tokens.0 =
                    self.parameters_parentheses.tokens.0.visit_mut(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                let mut new_type_specifiers = Vec::new();
                let mut new_parameters = Punctuated::new();
                for parameter_pair in self.parameters.into_pairs() {
                    let parameter_tuple = parameter_pair.into_tuple();
                    let parameter = parameter_tuple.0.visit_mut(visitor);
                    let type_specifier = type_specifiers
                        .next()
                        .and_then(|type_specifier| type_specifier)
                        .map(|type_specifier| type_specifier.visit_mut(visitor));
                    new_type_specifiers.push(type_specifier);
                    let punctuation = parameter_tuple.1.visit_mut(visitor);
                    new_parameters.push(Pair::new(parameter, punctuation));
                }
                self.parameters = new_parameters;
                self.parameters_parentheses.tokens.1 =
                    self.parameters_parentheses.tokens.1.visit_mut(visitor);
                self.block = self.block.visit_mut(visitor);
                self.end_token = self.end_token.visit_mut(visitor);
                self = visitor.visit_function_body_end(self);
                self
            }
        }
        impl Visit for LocalAssignment {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_local_assignment(self);
                self.local_token.visit(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                for name in &self.name_list {
                    name.visit(visitor);
                    type_specifiers.next().visit(visitor);
                }
                self.equal_token.visit(visitor);
                self.expr_list.visit(visitor);
                visitor.visit_local_assignment_end(self);
            }
        }
        impl VisitMut for LocalAssignment {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_local_assignment(self);
                self.local_token = self.local_token.visit_mut(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                let mut new_type_specifiers = Vec::new();
                let mut new_names = Punctuated::new();
                for parameter_pair in self.name_list.into_pairs() {
                    let parameter_tuple = parameter_pair.into_tuple();
                    let parameter = parameter_tuple.0.visit_mut(visitor);
                    let type_specifier = type_specifiers
                        .next()
                        .and_then(|type_specifier| type_specifier)
                        .map(|type_specifier| type_specifier.visit_mut(visitor));
                    let punctuation = parameter_tuple.1.visit_mut(visitor);
                    new_type_specifiers.push(type_specifier);
                    new_names.push(Pair::new(parameter, punctuation));
                }
                self.name_list = new_names;
                self.equal_token = self.equal_token.visit_mut(visitor);
                self.expr_list = self.expr_list.visit_mut(visitor);
                self = visitor.visit_local_assignment_end(self);
                self
            }
        }
        impl Visit for GenericFor {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_generic_for(self);
                self.for_token.visit(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                for name in &self.names {
                    name.visit(visitor);
                    type_specifiers.next().visit(visitor);
                }
                self.in_token.visit(visitor);
                self.expr_list.visit(visitor);
                self.do_token.visit(visitor);
                self.block.visit(visitor);
                self.end_token.visit(visitor);
                visitor.visit_generic_for_end(self);
            }
        }
        impl VisitMut for GenericFor {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_generic_for(self);
                self.for_token = self.for_token.visit_mut(visitor);
                let mut type_specifiers;
                #[cfg(not(feature = "roblox"))]
                {
                    type_specifiers = std::iter::repeat::<Option<Self>>(None);
                }
                let mut new_type_specifiers = Vec::new();
                let mut new_names = Punctuated::new();
                for parameter_pair in self.names.into_pairs() {
                    let parameter_tuple = parameter_pair.into_tuple();
                    let parameter = parameter_tuple.0.visit_mut(visitor);
                    let type_specifier = type_specifiers
                        .next()
                        .and_then(|type_specifier| type_specifier)
                        .map(|type_specifier| type_specifier.visit_mut(visitor));
                    let punctuation = parameter_tuple.1.visit_mut(visitor);
                    new_type_specifiers.push(type_specifier);
                    new_names.push(Pair::new(parameter, punctuation));
                }
                self.names = new_names;
                self.in_token = self.in_token.visit_mut(visitor);
                self.expr_list = self.expr_list.visit_mut(visitor);
                self.do_token = self.do_token.visit_mut(visitor);
                self.block = self.block.visit_mut(visitor);
                self.end_token = self.end_token.visit_mut(visitor);
                self = visitor.visit_generic_for_end(self);
                self
            }
        }
        impl Visit for NumericFor {
            fn visit<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit_numeric_for(self);
                self.for_token.visit(visitor);
                self.index_variable.visit(visitor);
                self.equal_token.visit(visitor);
                self.start.visit(visitor);
                self.start_end_comma.visit(visitor);
                self.end.visit(visitor);
                self.end_step_comma.visit(visitor);
                self.step.visit(visitor);
                self.do_token.visit(visitor);
                self.block.visit(visitor);
                self.end_token.visit(visitor);
                visitor.visit_numeric_for_end(self);
            }
        }
        impl VisitMut for NumericFor {
            fn visit_mut<V: VisitorMut>(mut self, visitor: &mut V) -> Self {
                self = visitor.visit_numeric_for(self);
                self.for_token = self.for_token.visit_mut(visitor);
                self.index_variable = self.index_variable.visit_mut(visitor);
                self.equal_token = self.equal_token.visit_mut(visitor);
                self.start = self.start.visit_mut(visitor);
                self.start_end_comma = self.start_end_comma.visit_mut(visitor);
                self.end = self.end.visit_mut(visitor);
                self.end_step_comma = self.end_step_comma.visit_mut(visitor);
                self.step = self.step.visit_mut(visitor);
                self.do_token = self.do_token.visit_mut(visitor);
                self.block = self.block.visit_mut(visitor);
                self.end_token = self.end_token.visit_mut(visitor);
                self = visitor.visit_numeric_for_end(self);
                self
            }
        }
    }
    use crate::{
        plugins::{DefaultPlugin, Plugin, PluginInfo, PluginMod},
        tokenizer::{Symbol, Token, TokenReference, TokenType},
        util::*,
    };
    use derive_more::Display;
    use full_moon_derive::{Node, Visit};
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};
    use std::{borrow::Cow, fmt};
    use parser_util::{
        InternalAstError, OneOrMore, Parser, ParserState, ZeroOrMore, ZeroOrMoreDelimited,
    };
    use punctuated::{Pair, Punctuated};
    use span::ContainedSpan;
    /// A block of statements, such as in if/do/etc block
    #[display(fmt = "PLUGIN TODO: Display Block")]
    pub struct Block<P: Plugin = DefaultPlugin> {
        stmts: Vec<(Stmt<P>, Option<TokenReference>)>,
        #[serde(skip_serializing_if = "Option::is_none")]
        last_stmt: Option<(LastStmt<P>, Option<TokenReference>)>,
        plugin_info: <<P as Plugin>::BlockMod as PluginMod<Block<P>>>::NodeInfo,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Block<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "stmts" => _serde::export::Ok(__Field::__field0),
                            "last_stmt" => _serde::export::Ok(__Field::__field1),
                            "plugin_info" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"stmts" => _serde::export::Ok(__Field::__field0),
                            b"last_stmt" => _serde::export::Ok(__Field::__field1),
                            b"plugin_info" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Block<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Block<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Block")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<(Stmt<P>, Option<TokenReference>)>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Block with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<(LastStmt<P>, Option<TokenReference>)>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Block with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            <<P as Plugin>::BlockMod as PluginMod<Block<P>>>::NodeInfo,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Block with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Block {
                            stmts: __field0,
                            last_stmt: __field1,
                            plugin_info: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<
                            Vec<(Stmt<P>, Option<TokenReference>)>,
                        > = _serde::export::None;
                        let mut __field1: _serde::export::Option<
                            Option<(LastStmt<P>, Option<TokenReference>)>,
                        > = _serde::export::None;
                        let mut __field2: _serde::export::Option<
                            <<P as Plugin>::BlockMod as PluginMod<Block<P>>>::NodeInfo,
                        > = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "stmts",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<(Stmt<P>, Option<TokenReference>)>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_stmt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<(LastStmt<P>, Option<TokenReference>)>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "plugin_info",
                                            ),
                                        );
                                    }
                                    __field2 = _serde :: export :: Some (match _serde :: de :: MapAccess :: next_value :: < < < P as Plugin > :: BlockMod as PluginMod < Block < P > > > :: NodeInfo > (& mut __map) { _serde :: export :: Ok (__val) => __val , _serde :: export :: Err (__err) => { return _serde :: export :: Err (__err) ; } }) ;
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("stmts") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("last_stmt") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("plugin_info") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Block {
                            stmts: __field0,
                            last_stmt: __field1,
                            plugin_info: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["stmts", "last_stmt", "plugin_info"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Block",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Block<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Block<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Block",
                    false as usize
                        + 1
                        + if Option::is_none(&self.last_stmt) {
                            0
                        } else {
                            1
                        }
                        + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "stmts",
                    &self.stmts,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                if !Option::is_none(&self.last_stmt) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_stmt",
                        &self.last_stmt,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "last_stmt")
                    {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                }
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "plugin_info",
                    &self.plugin_info,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Block<P> {
        #[inline]
        fn clone(&self) -> Block<P> {
            match *self {
                Block {
                    stmts: ref __self_0_0,
                    last_stmt: ref __self_0_1,
                    plugin_info: ref __self_0_2,
                } => Block {
                    stmts: ::core::clone::Clone::clone(&(*__self_0_0)),
                    last_stmt: ::core::clone::Clone::clone(&(*__self_0_1)),
                    plugin_info: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Block<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Block {
                    stmts: ref __self_0_0,
                    last_stmt: ref __self_0_1,
                    plugin_info: ref __self_0_2,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Block");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "stmts",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "last_stmt",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "plugin_info",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::default::Default + Plugin> ::core::default::Default for Block<P> {
        #[inline]
        fn default() -> Block<P> {
            Block {
                stmts: ::core::default::Default::default(),
                last_stmt: ::core::default::Default::default(),
                plugin_info: ::core::default::Default::default(),
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Block<P> {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Block {
                    stmts,
                    last_stmt,
                    plugin_info,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["PLUGIN TODO: Display Block"],
                    &match () {
                        () => [],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Block<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Block<P> {
        #[inline]
        fn eq(&self, other: &Block<P>) -> bool {
            match *other {
                Block {
                    stmts: ref __self_1_0,
                    last_stmt: ref __self_1_1,
                    plugin_info: ref __self_1_2,
                } => match *self {
                    Block {
                        stmts: ref __self_0_0,
                        last_stmt: ref __self_0_1,
                        plugin_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Block<P>) -> bool {
            match *other {
                Block {
                    stmts: ref __self_1_0,
                    last_stmt: ref __self_1_1,
                    plugin_info: ref __self_1_2,
                } => match *self {
                    Block {
                        stmts: ref __self_0_0,
                        last_stmt: ref __self_0_1,
                        plugin_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Block<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.stmts.start_position())
                            .or_else(|| self.last_stmt.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.last_stmt.end_position())
                            .or_else(|| self.stmts.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.stmts.start_position())
                            .or_else(|| self.last_stmt.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.last_stmt.end_position())
                            .or_else(|| self.stmts.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.stmts.similar(&other.stmts)
                    && self.last_stmt.similar(&other.last_stmt)
                    && self.plugin_info.similar(&other.plugin_info)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.stmts),
                        crate::node::TokenItem::MoreTokens(&self.last_stmt),
                        crate::node::TokenItem::MoreTokens(&self.plugin_info),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Block<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Block<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_block(self);
            self.stmts.visit(visitor);
            self.last_stmt.visit(visitor);
            visitor.visit_block_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Block<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_block(self);
            self.stmts = self.stmts.visit_mut(visitor);
            self.last_stmt = self.last_stmt.visit_mut(visitor);
            self = visitor.visit_block_end(self);
            self
        }
    }
    impl<P: Plugin> Block<P> {
        /// Creates an empty block
        pub fn new() -> Self {
            Self {
                stmts: Vec::new(),
                last_stmt: None,
                plugin_info: <<P as Plugin>::BlockMod as PluginMod<Block<P>>>::NodeInfo::default(),
            }
        }
        /// An iterator over the statements in the block, such as `local foo = 1`
        pub fn stmts(&self) -> impl Iterator<Item = &Stmt<P>> {
            self.stmts.iter().map(|(stmt, _)| stmt)
        }
        /// An iterator over the statements in the block, including any optional
        /// semicolon token reference present
        pub fn stmts_with_semicolon(
            &self,
        ) -> impl Iterator<Item = &(Stmt<P>, Option<TokenReference>)> {
            self.stmts.iter()
        }
        /// The last statement of the block if one exists, such as `return foo`
        pub fn last_stmt(&self) -> Option<&LastStmt<P>> {
            Some(&self.last_stmt.as_ref()?.0)
        }
        /// The last statement of the block if on exists, including any optional semicolon token reference present
        pub fn last_stmt_with_semicolon(&self) -> Option<&(LastStmt<P>, Option<TokenReference>)> {
            self.last_stmt.as_ref()
        }
        /// Returns a new block with the given statements
        /// Takes a vector of statements, followed by an optional semicolon token reference
        pub fn with_stmts(self, stmts: Vec<(Stmt<P>, Option<TokenReference>)>) -> Self {
            Self { stmts, ..self }
        }
        /// Returns a new block with the given last statement, if one is given
        /// Takes an optional last statement, with an optional semicolon
        pub fn with_last_stmt(
            self,
            last_stmt: Option<(LastStmt<P>, Option<TokenReference>)>,
        ) -> Self {
            Self { last_stmt, ..self }
        }
    }
    /// The last statement of a [`Block`]
    #[non_exhaustive]
    pub enum LastStmt<P: Plugin = DefaultPlugin> {
        /// A `break` statement
        Break(TokenReference),
        /// A `return` statement
        Return(Return<P>),
        Plugin(<<P as Plugin>::LastStmtMod as PluginMod<LastStmt<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for LastStmt<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Break" => _serde::export::Ok(__Field::__field0),
                            "Return" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Break" => _serde::export::Ok(__Field::__field0),
                            b"Return" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<LastStmt<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = LastStmt<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum LastStmt")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde :: de :: EnumAccess :: variant (__data) { _serde :: export :: Ok (__val) => __val , _serde :: export :: Err (__err) => { return _serde :: export :: Err (__err) ; } } { (__Field :: __field0 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < TokenReference > (__variant) , LastStmt :: Break) , (__Field :: __field1 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < Return < P > > (__variant) , LastStmt :: Return) , (__Field :: __field2 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < < < P as Plugin > :: LastStmtMod as PluginMod < LastStmt < P > > > :: NodeInfo > (__variant) , LastStmt :: Plugin) , }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Break", "Return", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "LastStmt",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LastStmt<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for LastStmt<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    LastStmt::Break(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "LastStmt",
                        0u32,
                        "Break",
                        __field0,
                    ),
                    LastStmt::Return(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "LastStmt",
                            1u32,
                            "Return",
                            __field0,
                        )
                    }
                    LastStmt::Plugin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "LastStmt",
                            2u32,
                            "Plugin",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for LastStmt<P> {
        #[inline]
        fn clone(&self) -> LastStmt<P> {
            match (&*self,) {
                (&LastStmt::Break(ref __self_0),) => {
                    LastStmt::Break(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&LastStmt::Return(ref __self_0),) => {
                    LastStmt::Return(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&LastStmt::Plugin(ref __self_0),) => {
                    LastStmt::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for LastStmt<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&LastStmt::Break(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Break");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&LastStmt::Return(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Return");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&LastStmt::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for LastStmt<P>
    where
        <<P as Plugin>::LastStmtMod as PluginMod<LastStmt<P>>>::NodeInfo: ::core::fmt::Display,
        Return<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                LastStmt::Break(_0) => {
                    ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                }
                LastStmt::Return(_0) => {
                    ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                }
                LastStmt::Plugin(_0) => {
                    ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for LastStmt<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for LastStmt<P> {
        #[inline]
        fn eq(&self, other: &LastStmt<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&LastStmt::Break(ref __self_0), &LastStmt::Break(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&LastStmt::Return(ref __self_0), &LastStmt::Return(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&LastStmt::Plugin(ref __self_0), &LastStmt::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &LastStmt<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&LastStmt::Break(ref __self_0), &LastStmt::Break(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&LastStmt::Return(ref __self_0), &LastStmt::Return(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&LastStmt::Plugin(ref __self_0), &LastStmt::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for LastStmt<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        LastStmt::Break(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        LastStmt::Return(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        LastStmt::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        LastStmt::Break(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        LastStmt::Return(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        LastStmt::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    LastStmt::Break(__self_0) => {
                        if let LastStmt::Break(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    LastStmt::Return(__self_0) => {
                        if let LastStmt::Return(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    LastStmt::Plugin(__self_0) => {
                        if let LastStmt::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    LastStmt::Break(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    LastStmt::Return(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    LastStmt::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for LastStmt<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for LastStmt<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_last_stmt(self);
            match self {
                LastStmt::Break(__self_0) => {
                    __self_0.visit(visitor);
                }
                LastStmt::Return(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_last_stmt_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for LastStmt<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_last_stmt(self);
            self = match self {
                LastStmt::Break(__self_0) => LastStmt::Break(__self_0.visit_mut(visitor)),
                LastStmt::Return(__self_0) => LastStmt::Return(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_last_stmt_end(self);
            self
        }
    }
    /// A `return` statement
    #[display(fmt = "{}{}", token, returns)]
    pub struct Return<P: Plugin = DefaultPlugin> {
        token: TokenReference,
        returns: Punctuated<Expression<P>>,
        #[display(fmt = "PLUGIN TODO")]
        plugin_info: <<P as Plugin>::ReturnMod as PluginMod<Return<P>>>::NodeInfo,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Return<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "token" => _serde::export::Ok(__Field::__field0),
                            "returns" => _serde::export::Ok(__Field::__field1),
                            "plugin_info" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"token" => _serde::export::Ok(__Field::__field0),
                            b"returns" => _serde::export::Ok(__Field::__field1),
                            b"plugin_info" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Return<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Return<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Return")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Return with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Expression<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Return with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            <<P as Plugin>::ReturnMod as PluginMod<Return<P>>>::NodeInfo,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Return with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Return {
                            token: __field0,
                            returns: __field1,
                            plugin_info: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Punctuated<Expression<P>>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<
                            <<P as Plugin>::ReturnMod as PluginMod<Return<P>>>::NodeInfo,
                        > = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "returns",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Expression<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "plugin_info",
                                            ),
                                        );
                                    }
                                    __field2 =
                                        _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                <<P as Plugin>::ReturnMod as PluginMod<
                                                    Return<P>,
                                                >>::NodeInfo,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("returns") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("plugin_info") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Return {
                            token: __field0,
                            returns: __field1,
                            plugin_info: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["token", "returns", "plugin_info"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Return",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Return<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Return<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Return",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token",
                    &self.token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "returns",
                    &self.returns,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "plugin_info",
                    &self.plugin_info,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Return<P> {
        #[inline]
        fn clone(&self) -> Return<P> {
            match *self {
                Return {
                    token: ref __self_0_0,
                    returns: ref __self_0_1,
                    plugin_info: ref __self_0_2,
                } => Return {
                    token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    returns: ::core::clone::Clone::clone(&(*__self_0_1)),
                    plugin_info: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Return<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Return {
                    token: ref __self_0_0,
                    returns: ref __self_0_1,
                    plugin_info: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Return");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "returns",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "plugin_info",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Return<P>
    where
        Punctuated<Expression<P>>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Return {
                    token,
                    returns,
                    plugin_info,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", ""],
                    &match (&token, &returns) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Return<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Return<P> {
        #[inline]
        fn eq(&self, other: &Return<P>) -> bool {
            match *other {
                Return {
                    token: ref __self_1_0,
                    returns: ref __self_1_1,
                    plugin_info: ref __self_1_2,
                } => match *self {
                    Return {
                        token: ref __self_0_0,
                        returns: ref __self_0_1,
                        plugin_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Return<P>) -> bool {
            match *other {
                Return {
                    token: ref __self_1_0,
                    returns: ref __self_1_1,
                    plugin_info: ref __self_1_2,
                } => match *self {
                    Return {
                        token: ref __self_0_0,
                        returns: ref __self_0_1,
                        plugin_info: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Return<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.token.start_position())
                            .or_else(|| self.returns.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.returns.end_position())
                            .or_else(|| self.token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.token.start_position())
                            .or_else(|| self.returns.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.returns.end_position())
                            .or_else(|| self.token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.token.similar(&other.token)
                    && self.returns.similar(&other.returns)
                    && self.plugin_info.similar(&other.plugin_info)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.token),
                        crate::node::TokenItem::MoreTokens(&self.returns),
                        crate::node::TokenItem::MoreTokens(&self.plugin_info),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Return<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Return<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_return(self);
            self.token.visit(visitor);
            self.returns.visit(visitor);
            visitor.visit_return_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Return<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_return(self);
            self.token = self.token.visit_mut(visitor);
            self.returns = self.returns.visit_mut(visitor);
            self = visitor.visit_return_end(self);
            self
        }
    }
    impl<P: Plugin> Return<P> {
        /// Creates a new empty Return
        /// Default return token is followed by a single space
        pub fn new() -> Self {
            Self {
                token: TokenReference::symbol("return ").unwrap(),
                returns: Punctuated::new(),
                plugin_info: <<P as Plugin>::ReturnMod as PluginMod<Return<P>>>::NodeInfo::default(
                ),
            }
        }
        /// The `return` token
        pub fn token(&self) -> &TokenReference {
            &self.token
        }
        /// The values being returned
        pub fn returns(&self) -> &Punctuated<Expression<P>> {
            &self.returns
        }
        /// Returns a new Return with the given `return` token
        pub fn with_token(self, token: TokenReference) -> Self {
            Self { token, ..self }
        }
        /// Returns a new Return with the given punctuated sequence
        pub fn with_returns(self, returns: Punctuated<Expression<P>>) -> Self {
            Self { returns, ..self }
        }
    }
    impl Default for Return {
        fn default() -> Self {
            Self::new()
        }
    }
    /// Fields of a [`TableConstructor`]
    #[non_exhaustive]
    pub enum Field<P: Plugin = DefaultPlugin> {
        /// A key in the format of `[expression] = value`
        #[display(
            fmt = "{}{}{}{}{}",
            "brackets.tokens().0",
            "key",
            "brackets.tokens().1",
            "equal",
            "value"
        )]
        ExpressionKey {
            /// The `[...]` part of `[expression] = value`
            brackets: ContainedSpan,
            /// The `expression` part of `[expression] = value`
            key: Expression<P>,
            /// The `=` part of `[expression] = value`
            equal: TokenReference,
            /// The `value` part of `[expression] = value`
            value: Expression<P>,
        },
        /// A key in the format of `name = value`
        #[display(fmt = "{}{}{}", "key", "equal", "value")]
        NameKey {
            /// The `name` part of `name = value`
            key: TokenReference,
            /// The `=` part of `name = value`
            equal: TokenReference,
            /// The `value` part of `name = value`
            value: Expression<P>,
        },
        /// A field with no key, just a value (such as `"a"` in `{ "a" }`)
        #[display(fmt = "{}", "_0")]
        NoKey(Expression<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::FieldMod as PluginMod<Field<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Field<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "ExpressionKey" => _serde::export::Ok(__Field::__field0),
                            "NameKey" => _serde::export::Ok(__Field::__field1),
                            "NoKey" => _serde::export::Ok(__Field::__field2),
                            "Plugin" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"ExpressionKey" => _serde::export::Ok(__Field::__field0),
                            b"NameKey" => _serde::export::Ok(__Field::__field1),
                            b"NoKey" => _serde::export::Ok(__Field::__field2),
                            b"Plugin" => _serde::export::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Field<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Field<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Field")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            2u64 => _serde::export::Ok(__Field::__field2),
                                            3u64 => _serde::export::Ok(__Field::__field3),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 4",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "brackets" => _serde::export::Ok(__Field::__field0),
                                            "key" => _serde::export::Ok(__Field::__field1),
                                            "equal" => _serde::export::Ok(__Field::__field2),
                                            "value" => _serde::export::Ok(__Field::__field3),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"brackets" => _serde::export::Ok(__Field::__field0),
                                            b"key" => _serde::export::Ok(__Field::__field1),
                                            b"equal" => _serde::export::Ok(__Field::__field2),
                                            b"value" => _serde::export::Ok(__Field::__field3),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, P: Plugin>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::export::PhantomData<Field<P>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    type Value = Field<P>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Field::ExpressionKey",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                ContainedSpan,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Field::ExpressionKey with 4 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Expression<P>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Field::ExpressionKey with 4 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant Field::ExpressionKey with 4 elements")) ;
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Expression<P>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct variant Field::ExpressionKey with 4 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(Field::ExpressionKey {
                                            brackets: __field0,
                                            key: __field1,
                                            equal: __field2,
                                            value: __field3,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<ContainedSpan> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<Expression<P>> =
                                            _serde::export::None;
                                        let mut __field2: _serde::export::Option<TokenReference> =
                                            _serde::export::None;
                                        let mut __field3: _serde::export::Option<Expression<P>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("brackets")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ContainedSpan,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Expression<P>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("equal")) ;
                                                    }
                                                    __field2 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::export::Option::is_some(&__field3) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("value")) ;
                                                    }
                                                    __field3 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Expression<P>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("brackets")
                                                {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("key") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::export::Some(__field2) => __field2,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("equal") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::export::Some(__field3) => __field3,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("value") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Field::ExpressionKey {
                                            brackets: __field0,
                                            key: __field1,
                                            equal: __field2,
                                            value: __field3,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["brackets", "key", "equal", "value"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Field<P>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            2u64 => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 3",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "key" => _serde::export::Ok(__Field::__field0),
                                            "equal" => _serde::export::Ok(__Field::__field1),
                                            "value" => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"key" => _serde::export::Ok(__Field::__field0),
                                            b"equal" => _serde::export::Ok(__Field::__field1),
                                            b"value" => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, P: Plugin>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::export::PhantomData<Field<P>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    type Value = Field<P>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Field::NameKey",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Field::NameKey with 3 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Field::NameKey with 3 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Expression<P>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant Field::NameKey with 3 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(Field::NameKey {
                                            key: __field0,
                                            equal: __field1,
                                            value: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<TokenReference> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<TokenReference> =
                                            _serde::export::None;
                                        let mut __field2: _serde::export::Option<Expression<P>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("equal")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("value")) ;
                                                    }
                                                    __field2 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Expression<P>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("key") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("equal") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::export::Some(__field2) => __field2,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("value") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Field::NameKey {
                                            key: __field0,
                                            equal: __field1,
                                            value: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["key", "equal", "value"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Field<P>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Expression<P>>(
                                    __variant,
                                ),
                                Field::NoKey,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::FieldMod as PluginMod<Field<P>>>::NodeInfo,
                                >(__variant),
                                Field::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["ExpressionKey", "NameKey", "NoKey", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Field",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Field<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Field<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Field::ExpressionKey {
                        ref brackets,
                        ref key,
                        ref equal,
                        ref value,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Field",
                            0u32,
                            "ExpressionKey",
                            0 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "brackets",
                            brackets,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "equal",
                            equal,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Field::NameKey {
                        ref key,
                        ref equal,
                        ref value,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Field",
                            1u32,
                            "NameKey",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "equal",
                            equal,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Field::NoKey(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Field",
                        2u32,
                        "NoKey",
                        __field0,
                    ),
                    Field::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Field",
                        3u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Field<P> {
        #[inline]
        fn clone(&self) -> Field<P> {
            match (&*self,) {
                (&Field::ExpressionKey {
                    brackets: ref __self_0,
                    key: ref __self_1,
                    equal: ref __self_2,
                    value: ref __self_3,
                },) => Field::ExpressionKey {
                    brackets: ::core::clone::Clone::clone(&(*__self_0)),
                    key: ::core::clone::Clone::clone(&(*__self_1)),
                    equal: ::core::clone::Clone::clone(&(*__self_2)),
                    value: ::core::clone::Clone::clone(&(*__self_3)),
                },
                (&Field::NameKey {
                    key: ref __self_0,
                    equal: ref __self_1,
                    value: ref __self_2,
                },) => Field::NameKey {
                    key: ::core::clone::Clone::clone(&(*__self_0)),
                    equal: ::core::clone::Clone::clone(&(*__self_1)),
                    value: ::core::clone::Clone::clone(&(*__self_2)),
                },
                (&Field::NoKey(ref __self_0),) => {
                    Field::NoKey(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Field::Plugin(ref __self_0),) => {
                    Field::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Field<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Field::ExpressionKey {
                    brackets: ref __self_0,
                    key: ref __self_1,
                    equal: ref __self_2,
                    value: ref __self_3,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "ExpressionKey");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "brackets",
                        &&(*__self_0),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "key", &&(*__self_1));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "equal",
                        &&(*__self_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Field::NameKey {
                    key: ref __self_0,
                    equal: ref __self_1,
                    value: ref __self_2,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "NameKey");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "key", &&(*__self_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "equal",
                        &&(*__self_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Field::NoKey(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "NoKey");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Field::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Field<P>
    where
        Expression<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Field::ExpressionKey {
                    brackets,
                    key,
                    equal,
                    value,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", "", ""],
                    &match (
                        &brackets.tokens().0,
                        &key,
                        &brackets.tokens().1,
                        &equal,
                        &value,
                    ) {
                        (arg0, arg1, arg2, arg3, arg4) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                Field::NameKey { key, equal, value } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", "", ""],
                        &match (&key, &equal, &value) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
                Field::NoKey(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Field::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Field<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Field<P> {
        #[inline]
        fn eq(&self, other: &Field<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Field::ExpressionKey {
                                brackets: ref __self_0,
                                key: ref __self_1,
                                equal: ref __self_2,
                                value: ref __self_3,
                            },
                            &Field::ExpressionKey {
                                brackets: ref __arg_1_0,
                                key: ref __arg_1_1,
                                equal: ref __arg_1_2,
                                value: ref __arg_1_3,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                                && (*__self_3) == (*__arg_1_3)
                        }
                        (
                            &Field::NameKey {
                                key: ref __self_0,
                                equal: ref __self_1,
                                value: ref __self_2,
                            },
                            &Field::NameKey {
                                key: ref __arg_1_0,
                                equal: ref __arg_1_1,
                                value: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        (&Field::NoKey(ref __self_0), &Field::NoKey(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Field::Plugin(ref __self_0), &Field::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Field<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Field::ExpressionKey {
                                brackets: ref __self_0,
                                key: ref __self_1,
                                equal: ref __self_2,
                                value: ref __self_3,
                            },
                            &Field::ExpressionKey {
                                brackets: ref __arg_1_0,
                                key: ref __arg_1_1,
                                equal: ref __arg_1_2,
                                value: ref __arg_1_3,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                                || (*__self_3) != (*__arg_1_3)
                        }
                        (
                            &Field::NameKey {
                                key: ref __self_0,
                                equal: ref __self_1,
                                value: ref __self_2,
                            },
                            &Field::NameKey {
                                key: ref __arg_1_0,
                                equal: ref __arg_1_1,
                                value: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        (&Field::NoKey(ref __self_0), &Field::NoKey(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Field::Plugin(ref __self_0), &Field::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Field<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Field::ExpressionKey {
                            brackets,
                            key,
                            equal,
                            value,
                        } => Some((
                            None.or_else(|| brackets.start_position())
                                .or_else(|| key.start_position())
                                .or_else(|| equal.start_position())
                                .or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())
                                .or_else(|| equal.end_position())
                                .or_else(|| key.end_position())
                                .or_else(|| brackets.end_position())?,
                        )),
                        Field::NameKey { key, equal, value } => Some((
                            None.or_else(|| key.start_position())
                                .or_else(|| equal.start_position())
                                .or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())
                                .or_else(|| equal.end_position())
                                .or_else(|| key.end_position())?,
                        )),
                        Field::NoKey(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Field::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Field::ExpressionKey {
                            brackets,
                            key,
                            equal,
                            value,
                        } => Some((
                            None.or_else(|| brackets.start_position())
                                .or_else(|| key.start_position())
                                .or_else(|| equal.start_position())
                                .or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())
                                .or_else(|| equal.end_position())
                                .or_else(|| key.end_position())
                                .or_else(|| brackets.end_position())?,
                        )),
                        Field::NameKey { key, equal, value } => Some((
                            None.or_else(|| key.start_position())
                                .or_else(|| equal.start_position())
                                .or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())
                                .or_else(|| equal.end_position())
                                .or_else(|| key.end_position())?,
                        )),
                        Field::NoKey(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Field::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Field::ExpressionKey {
                        brackets,
                        key,
                        equal,
                        value,
                    } => {
                        if let Field::ExpressionKey {
                            brackets: other_brackets,
                            key: other_key,
                            equal: other_equal,
                            value: other_value,
                        } = &other
                        {
                            brackets.similar(other_brackets)
                                && key.similar(other_key)
                                && equal.similar(other_equal)
                                && value.similar(other_value)
                                && true
                        } else {
                            false
                        }
                    }
                    Field::NameKey { key, equal, value } => {
                        if let Field::NameKey {
                            key: other_key,
                            equal: other_equal,
                            value: other_value,
                        } = &other
                        {
                            key.similar(other_key)
                                && equal.similar(other_equal)
                                && value.similar(other_value)
                                && true
                        } else {
                            false
                        }
                    }
                    Field::NoKey(__self_0) => {
                        if let Field::NoKey(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Field::Plugin(__self_0) => {
                        if let Field::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Field::ExpressionKey {
                        ref brackets,
                        ref key,
                        ref equal,
                        ref value,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*brackets),
                            crate::node::TokenItem::MoreTokens(&*key),
                            crate::node::TokenItem::TokenReference(&equal),
                            crate::node::TokenItem::MoreTokens(&*value),
                        ]),
                    },
                    Field::NameKey {
                        ref key,
                        ref equal,
                        ref value,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::TokenReference(&key),
                            crate::node::TokenItem::TokenReference(&equal),
                            crate::node::TokenItem::MoreTokens(&*value),
                        ]),
                    },
                    Field::NoKey(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Field::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Field<P> {}
    /// A table being constructed, such as `{ 1, 2, 3 }` or `{ a = 1 }`
    #[display(fmt = "{}{}{}", "braces.tokens().0", "fields", "braces.tokens().1")]
    pub struct TableConstructor<P: Plugin = DefaultPlugin> {
        #[node(full_range)]
        #[visit(contains = "fields")]
        braces: ContainedSpan,
        fields: Punctuated<Field<P>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for TableConstructor<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "braces" => _serde::export::Ok(__Field::__field0),
                            "fields" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"braces" => _serde::export::Ok(__Field::__field0),
                            b"fields" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<TableConstructor<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = TableConstructor<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TableConstructor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ContainedSpan,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TableConstructor with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Field<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct TableConstructor with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(TableConstructor {
                            braces: __field0,
                            fields: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<ContainedSpan> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Punctuated<Field<P>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "braces",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<ContainedSpan>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fields",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Field<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("braces") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("fields") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(TableConstructor {
                            braces: __field0,
                            fields: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["braces", "fields"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TableConstructor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TableConstructor<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for TableConstructor<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TableConstructor",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "braces",
                    &self.braces,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fields",
                    &self.fields,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for TableConstructor<P> {
        #[inline]
        fn clone(&self) -> TableConstructor<P> {
            match *self {
                TableConstructor {
                    braces: ref __self_0_0,
                    fields: ref __self_0_1,
                } => TableConstructor {
                    braces: ::core::clone::Clone::clone(&(*__self_0_0)),
                    fields: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for TableConstructor<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TableConstructor {
                    braces: ref __self_0_0,
                    fields: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "TableConstructor");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "braces",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "fields",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for TableConstructor<P>
    where
        Punctuated<Field<P>>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                TableConstructor { braces, fields } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", "", ""],
                        &match (&braces.tokens().0, &fields, &braces.tokens().1) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for TableConstructor<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for TableConstructor<P> {
        #[inline]
        fn eq(&self, other: &TableConstructor<P>) -> bool {
            match *other {
                TableConstructor {
                    braces: ref __self_1_0,
                    fields: ref __self_1_1,
                } => match *self {
                    TableConstructor {
                        braces: ref __self_0_0,
                        fields: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TableConstructor<P>) -> bool {
            match *other {
                TableConstructor {
                    braces: ref __self_1_0,
                    fields: ref __self_1_1,
                } => match *self {
                    TableConstructor {
                        braces: ref __self_0_0,
                        fields: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for TableConstructor<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some({ self.braces.range() }?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some({ self.braces.range() }?.1)
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.braces.similar(&other.braces) && self.fields.similar(&other.fields) && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.braces),
                        crate::node::TokenItem::MoreTokens(&self.fields),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for TableConstructor<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for TableConstructor<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_table_constructor(self);
            self.braces.tokens.0.visit(visitor);
            self.fields.visit(visitor);
            self.braces.tokens.1.visit(visitor);
            visitor.visit_table_constructor_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for TableConstructor<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_table_constructor(self);
            self.braces.tokens.0 = self.braces.tokens.0.visit_mut(visitor);
            self.fields = self.fields.visit_mut(visitor);
            self.braces.tokens.1 = self.braces.tokens.1.visit_mut(visitor);
            self = visitor.visit_table_constructor_end(self);
            self
        }
    }
    impl<P: Plugin> TableConstructor<P> {
        /// Creates a new empty TableConstructor
        /// Brace tokens are followed by spaces, such that { `fields` }
        pub fn new() -> Self {
            Self {
                braces: ContainedSpan::new(
                    TokenReference::symbol("{ ").unwrap(),
                    TokenReference::symbol(" }").unwrap(),
                ),
                fields: Punctuated::new(),
            }
        }
        /// The braces of the constructor
        pub fn braces(&self) -> &ContainedSpan {
            &self.braces
        }
        /// Returns the [`Punctuated`] sequence of the fields used to create the table
        pub fn fields(&self) -> &Punctuated<Field<P>> {
            &self.fields
        }
        /// Returns a new TableConstructor with the given braces
        pub fn with_braces(self, braces: ContainedSpan) -> Self {
            Self { braces, ..self }
        }
        /// Returns a new TableConstructor with the given fields
        pub fn with_fields(self, fields: Punctuated<Field<P>>) -> Self {
            Self { fields, ..self }
        }
    }
    impl Default for TableConstructor {
        fn default() -> Self {
            Self::new()
        }
    }
    /// An expression, mostly useful for getting values
    #[serde(untagged)]
    #[non_exhaustive]
    pub enum Expression<P: Plugin = DefaultPlugin> {
        /// A binary operation, such as `1 + 3`
        #[display(fmt = "{}{}{}", "lhs", "binop", "rhs")]
        BinaryOperator {
            /// The left hand side of the binary operation, the `1` part of `1 + 3`
            lhs: Box<Expression<P>>,
            /// The binary operation used, the `+` part of `1 + 3`
            binop: BinOp,
            /// The right hand side of the binary operation, the `3` part of `1 + 3`
            rhs: Box<Expression<P>>,
        },
        /// A statement in parentheses, such as `(#list)`
        #[display(
            fmt = "{}{}{}",
            "contained.tokens().0",
            "expression",
            "contained.tokens().1"
        )]
        Parentheses {
            /// The parentheses of the `ParenExpression`
            #[node(full_range)]
            contained: ContainedSpan,
            /// The expression inside the parentheses
            expression: Box<Expression<P>>,
        },
        /// A unary operation, such as `#list`
        #[display(fmt = "{}{}", "unop", "expression")]
        UnaryOperator {
            /// The unary operation, the `#` part of `#list`
            unop: UnOp,
            /// The expression the operation is being done on, the `list` part of `#list`
            expression: Box<Expression<P>>,
        },
        /// A value, such as "strings"
        #[display(fmt = "{}", value)]
        Value {
            /// The value itself
            value: Box<Value<P>>,
        },
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::ExpressionMod as PluginMod<Expression<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Expression<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content =
                    match <_serde::private::de::Content as _serde::Deserialize>::deserialize(
                        __deserializer,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "lhs" => _serde::export::Ok(__Field::__field0),
                                "binop" => _serde::export::Ok(__Field::__field1),
                                "rhs" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"lhs" => _serde::export::Ok(__Field::__field0),
                                b"binop" => _serde::export::Ok(__Field::__field1),
                                b"rhs" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, P: Plugin>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Expression<P>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        type Value = Expression<P>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::BinaryOperator",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Box<Expression<P>>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<BinOp> = _serde::export::None;
                            let mut __field2: _serde::export::Option<Box<Expression<P>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "lhs",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Box<Expression<P>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "binop",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<BinOp>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "rhs",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Box<Expression<P>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("lhs") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("binop") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("rhs") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::BinaryOperator {
                                lhs: __field0,
                                binop: __field1,
                                rhs: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["lhs", "binop", "rhs"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<P>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "contained" => _serde::export::Ok(__Field::__field0),
                                "expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"contained" => _serde::export::Ok(__Field::__field0),
                                b"expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, P: Plugin>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Expression<P>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        type Value = Expression<P>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::Parentheses",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<ContainedSpan> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Box<Expression<P>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "contained",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<ContainedSpan>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Box<Expression<P>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("contained") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("expression") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::Parentheses {
                                contained: __field0,
                                expression: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["contained", "expression"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<P>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "unop" => _serde::export::Ok(__Field::__field0),
                                "expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"unop" => _serde::export::Ok(__Field::__field0),
                                b"expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, P: Plugin>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Expression<P>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        type Value = Expression<P>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::UnaryOperator",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<UnOp> = _serde::export::None;
                            let mut __field1: _serde::export::Option<Box<Expression<P>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unop",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<UnOp>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Box<Expression<P>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("unop") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("expression") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::UnaryOperator {
                                unop: __field0,
                                expression: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["unop", "expression"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<P>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "value" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"value" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de, P: Plugin>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        marker: _serde::export::PhantomData<Expression<P>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                    where
                        P: _serde::Deserialize<'de>,
                    {
                        type Value = Expression<P>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::Value",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Box<Value<P>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Box<Value<P>>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("value") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::Value { value: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["value"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<P>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                if let _serde :: export :: Ok (__ok) = _serde :: export :: Result :: map (< < < P as Plugin > :: ExpressionMod as PluginMod < Expression < P > > > :: NodeInfo as _serde :: Deserialize > :: deserialize (_serde :: private :: de :: ContentRefDeserializer :: < __D :: Error > :: new (& __content)) , Expression :: Plugin) { return _serde :: export :: Ok (__ok) ; }
                _serde::export::Err(_serde::de::Error::custom(
                    "data did not match any variant of untagged enum Expression",
                ))
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Expression<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Expression::BinaryOperator {
                        ref lhs,
                        ref binop,
                        ref rhs,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "lhs",
                            lhs,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "binop",
                            binop,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "rhs",
                            rhs,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Expression::Parentheses {
                        ref contained,
                        ref expression,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "contained",
                            contained,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expression",
                            expression,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Expression::UnaryOperator {
                        ref unop,
                        ref expression,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unop",
                            unop,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expression",
                            expression,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Expression::Value { ref value } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Expression::Plugin(ref __field0) => {
                        _serde::Serialize::serialize(__field0, __serializer)
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Expression<P> {
        #[inline]
        fn clone(&self) -> Expression<P> {
            match (&*self,) {
                (&Expression::BinaryOperator {
                    lhs: ref __self_0,
                    binop: ref __self_1,
                    rhs: ref __self_2,
                },) => Expression::BinaryOperator {
                    lhs: ::core::clone::Clone::clone(&(*__self_0)),
                    binop: ::core::clone::Clone::clone(&(*__self_1)),
                    rhs: ::core::clone::Clone::clone(&(*__self_2)),
                },
                (&Expression::Parentheses {
                    contained: ref __self_0,
                    expression: ref __self_1,
                },) => Expression::Parentheses {
                    contained: ::core::clone::Clone::clone(&(*__self_0)),
                    expression: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Expression::UnaryOperator {
                    unop: ref __self_0,
                    expression: ref __self_1,
                },) => Expression::UnaryOperator {
                    unop: ::core::clone::Clone::clone(&(*__self_0)),
                    expression: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Expression::Value {
                    value: ref __self_0,
                },) => Expression::Value {
                    value: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&Expression::Plugin(ref __self_0),) => {
                    Expression::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Expression<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Expression::BinaryOperator {
                    lhs: ref __self_0,
                    binop: ref __self_1,
                    rhs: ref __self_2,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "BinaryOperator");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "lhs", &&(*__self_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "binop",
                        &&(*__self_1),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "rhs", &&(*__self_2));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Expression::Parentheses {
                    contained: ref __self_0,
                    expression: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Parentheses");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "contained",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expression",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Expression::UnaryOperator {
                    unop: ref __self_0,
                    expression: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "UnaryOperator");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "unop", &&(*__self_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expression",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Expression::Value {
                    value: ref __self_0,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Value");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Expression::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Expression<P>
    where
        Box<Value<P>>: ::core::fmt::Display,
        Box<Expression<P>>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Expression::BinaryOperator { lhs, binop, rhs } => _derive_more_display_formatter
                    .write_fmt(::core::fmt::Arguments::new_v1(
                        &["", "", ""],
                        &match (&lhs, &binop, &rhs) {
                            (arg0, arg1, arg2) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ],
                        },
                    )),
                Expression::Parentheses {
                    contained,
                    expression,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&contained.tokens().0, &expression, &contained.tokens().1) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                Expression::UnaryOperator { unop, expression } => _derive_more_display_formatter
                    .write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&unop, &expression) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    )),
                Expression::Value { value } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Expression::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Expression<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Expression<P> {
        #[inline]
        fn eq(&self, other: &Expression<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Expression::BinaryOperator {
                                lhs: ref __self_0,
                                binop: ref __self_1,
                                rhs: ref __self_2,
                            },
                            &Expression::BinaryOperator {
                                lhs: ref __arg_1_0,
                                binop: ref __arg_1_1,
                                rhs: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        (
                            &Expression::Parentheses {
                                contained: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::Parentheses {
                                contained: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Expression::UnaryOperator {
                                unop: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::UnaryOperator {
                                unop: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Expression::Value {
                                value: ref __self_0,
                            },
                            &Expression::Value {
                                value: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Expression::Plugin(ref __self_0), &Expression::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Expression<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Expression::BinaryOperator {
                                lhs: ref __self_0,
                                binop: ref __self_1,
                                rhs: ref __self_2,
                            },
                            &Expression::BinaryOperator {
                                lhs: ref __arg_1_0,
                                binop: ref __arg_1_1,
                                rhs: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        (
                            &Expression::Parentheses {
                                contained: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::Parentheses {
                                contained: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Expression::UnaryOperator {
                                unop: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::UnaryOperator {
                                unop: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Expression::Value {
                                value: ref __self_0,
                            },
                            &Expression::Value {
                                value: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Expression::Plugin(ref __self_0), &Expression::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Expression<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Expression::BinaryOperator { lhs, binop, rhs } => Some((
                            None.or_else(|| lhs.start_position())
                                .or_else(|| binop.start_position())
                                .or_else(|| rhs.start_position())?,
                            None.or_else(|| rhs.end_position())
                                .or_else(|| binop.end_position())
                                .or_else(|| lhs.end_position())?,
                        )),
                        Expression::Parentheses {
                            contained,
                            expression,
                        } => contained.range(),
                        Expression::UnaryOperator { unop, expression } => Some((
                            None.or_else(|| unop.start_position())
                                .or_else(|| expression.start_position())?,
                            None.or_else(|| expression.end_position())
                                .or_else(|| unop.end_position())?,
                        )),
                        Expression::Value { value } => Some((
                            None.or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())?,
                        )),
                        Expression::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Expression::BinaryOperator { lhs, binop, rhs } => Some((
                            None.or_else(|| lhs.start_position())
                                .or_else(|| binop.start_position())
                                .or_else(|| rhs.start_position())?,
                            None.or_else(|| rhs.end_position())
                                .or_else(|| binop.end_position())
                                .or_else(|| lhs.end_position())?,
                        )),
                        Expression::Parentheses {
                            contained,
                            expression,
                        } => contained.range(),
                        Expression::UnaryOperator { unop, expression } => Some((
                            None.or_else(|| unop.start_position())
                                .or_else(|| expression.start_position())?,
                            None.or_else(|| expression.end_position())
                                .or_else(|| unop.end_position())?,
                        )),
                        Expression::Value { value } => Some((
                            None.or_else(|| value.start_position())?,
                            None.or_else(|| value.end_position())?,
                        )),
                        Expression::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Expression::BinaryOperator { lhs, binop, rhs } => {
                        if let Expression::BinaryOperator {
                            lhs: other_lhs,
                            binop: other_binop,
                            rhs: other_rhs,
                        } = &other
                        {
                            lhs.similar(other_lhs)
                                && binop.similar(other_binop)
                                && rhs.similar(other_rhs)
                                && true
                        } else {
                            false
                        }
                    }
                    Expression::Parentheses {
                        contained,
                        expression,
                    } => {
                        if let Expression::Parentheses {
                            contained: other_contained,
                            expression: other_expression,
                        } = &other
                        {
                            contained.similar(other_contained)
                                && expression.similar(other_expression)
                                && true
                        } else {
                            false
                        }
                    }
                    Expression::UnaryOperator { unop, expression } => {
                        if let Expression::UnaryOperator {
                            unop: other_unop,
                            expression: other_expression,
                        } = &other
                        {
                            unop.similar(other_unop) && expression.similar(other_expression) && true
                        } else {
                            false
                        }
                    }
                    Expression::Value { value } => {
                        if let Expression::Value { value: other_value } = &other {
                            value.similar(other_value) && true
                        } else {
                            false
                        }
                    }
                    Expression::Plugin(__self_0) => {
                        if let Expression::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Expression::BinaryOperator {
                        ref lhs,
                        ref binop,
                        ref rhs,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*lhs),
                            crate::node::TokenItem::MoreTokens(&*binop),
                            crate::node::TokenItem::MoreTokens(&*rhs),
                        ]),
                    },
                    Expression::Parentheses {
                        ref contained,
                        ref expression,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*contained),
                            crate::node::TokenItem::MoreTokens(&*expression),
                        ]),
                    },
                    Expression::UnaryOperator {
                        ref unop,
                        ref expression,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*unop),
                            crate::node::TokenItem::MoreTokens(&*expression),
                        ]),
                    },
                    Expression::Value { ref value } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(&*value)]),
                    },
                    Expression::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Expression<P> {}
    /// Values that cannot be used standalone, but as part of things such as [`Stmt`]
    #[non_exhaustive]
    pub enum Value<P: Plugin = DefaultPlugin> {
        /// An anonymous function, such as `function() end)`
        #[display(fmt = "{}{}", "_0.0", "_0.1")]
        Function((TokenReference, FunctionBody<P>)),
        /// A call of a function, such as `call()`
        #[display(fmt = "{}", "_0")]
        FunctionCall(FunctionCall<P>),
        /// A table constructor, such as `{ 1, 2, 3 }`
        #[display(fmt = "{}", "_0")]
        TableConstructor(TableConstructor<P>),
        /// A number token, such as `3.3`
        #[display(fmt = "{}", "_0")]
        Number(TokenReference),
        /// An expression between parentheses, such as `(3 + 2)`
        #[display(fmt = "{}", "_0")]
        ParenthesesExpression(Expression<P>),
        /// A string token, such as `"hello"`
        #[display(fmt = "{}", "_0")]
        String(TokenReference),
        /// A symbol, such as `true`
        #[display(fmt = "{}", "_0")]
        Symbol(TokenReference),
        /// A more complex value, such as `call().x`
        #[display(fmt = "{}", "_0")]
        Var(Var<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::ValueMod as PluginMod<Value<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Value<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 9",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Function" => _serde::export::Ok(__Field::__field0),
                            "FunctionCall" => _serde::export::Ok(__Field::__field1),
                            "TableConstructor" => _serde::export::Ok(__Field::__field2),
                            "Number" => _serde::export::Ok(__Field::__field3),
                            "ParenthesesExpression" => _serde::export::Ok(__Field::__field4),
                            "String" => _serde::export::Ok(__Field::__field5),
                            "Symbol" => _serde::export::Ok(__Field::__field6),
                            "Var" => _serde::export::Ok(__Field::__field7),
                            "Plugin" => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Function" => _serde::export::Ok(__Field::__field0),
                            b"FunctionCall" => _serde::export::Ok(__Field::__field1),
                            b"TableConstructor" => _serde::export::Ok(__Field::__field2),
                            b"Number" => _serde::export::Ok(__Field::__field3),
                            b"ParenthesesExpression" => _serde::export::Ok(__Field::__field4),
                            b"String" => _serde::export::Ok(__Field::__field5),
                            b"Symbol" => _serde::export::Ok(__Field::__field6),
                            b"Var" => _serde::export::Ok(__Field::__field7),
                            b"Plugin" => _serde::export::Ok(__Field::__field8),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Value<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Value<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Value")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<(
                                    TokenReference,
                                    FunctionBody<P>,
                                )>(__variant),
                                Value::Function,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionCall<P>>(
                                    __variant,
                                ),
                                Value::FunctionCall,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TableConstructor<P>>(
                                    __variant,
                                ),
                                Value::TableConstructor,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                Value::Number,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Expression<P>>(
                                    __variant,
                                ),
                                Value::ParenthesesExpression,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                Value::String,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                Value::Symbol,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Var<P>>(__variant),
                                Value::Var,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::ValueMod as PluginMod<Value<P>>>::NodeInfo,
                                >(__variant),
                                Value::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Function",
                    "FunctionCall",
                    "TableConstructor",
                    "Number",
                    "ParenthesesExpression",
                    "String",
                    "Symbol",
                    "Var",
                    "Plugin",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Value",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Value<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Value<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Value::Function(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        0u32,
                        "Function",
                        __field0,
                    ),
                    Value::FunctionCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            1u32,
                            "FunctionCall",
                            __field0,
                        )
                    }
                    Value::TableConstructor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            2u32,
                            "TableConstructor",
                            __field0,
                        )
                    }
                    Value::Number(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        3u32,
                        "Number",
                        __field0,
                    ),
                    Value::ParenthesesExpression(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            4u32,
                            "ParenthesesExpression",
                            __field0,
                        )
                    }
                    Value::String(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        5u32,
                        "String",
                        __field0,
                    ),
                    Value::Symbol(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        6u32,
                        "Symbol",
                        __field0,
                    ),
                    Value::Var(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        7u32,
                        "Var",
                        __field0,
                    ),
                    Value::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        8u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Value<P> {
        #[inline]
        fn clone(&self) -> Value<P> {
            match (&*self,) {
                (&Value::Function(ref __self_0),) => {
                    Value::Function(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::FunctionCall(ref __self_0),) => {
                    Value::FunctionCall(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::TableConstructor(ref __self_0),) => {
                    Value::TableConstructor(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Number(ref __self_0),) => {
                    Value::Number(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::ParenthesesExpression(ref __self_0),) => {
                    Value::ParenthesesExpression(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::String(ref __self_0),) => {
                    Value::String(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Symbol(ref __self_0),) => {
                    Value::Symbol(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Var(ref __self_0),) => {
                    Value::Var(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Plugin(ref __self_0),) => {
                    Value::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Value<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Value::Function(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Function");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::FunctionCall(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "FunctionCall");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::TableConstructor(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TableConstructor");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::Number(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Number");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::ParenthesesExpression(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ParenthesesExpression");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::String(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "String");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::Symbol(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Symbol");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::Var(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Var");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Value::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Value<P>
    where
        FunctionCall<P>: ::core::fmt::Display,
        Var<P>: ::core::fmt::Display,
        TableConstructor<P>: ::core::fmt::Display,
        Expression<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Value::Function(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&_0.0, &_0.1) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
                Value::FunctionCall(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::TableConstructor(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::Number(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::ParenthesesExpression(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::String(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::Symbol(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::Var(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Value::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Value<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Value<P> {
        #[inline]
        fn eq(&self, other: &Value<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Function(ref __self_0), &Value::Function(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Value::FunctionCall(ref __self_0),
                            &Value::FunctionCall(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Value::TableConstructor(ref __self_0),
                            &Value::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Value::Number(ref __self_0), &Value::Number(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Value::ParenthesesExpression(ref __self_0),
                            &Value::ParenthesesExpression(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Value::String(ref __self_0), &Value::String(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Value::Symbol(ref __self_0), &Value::Symbol(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Value::Var(ref __self_0), &Value::Var(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Value::Plugin(ref __self_0), &Value::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Value<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Function(ref __self_0), &Value::Function(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Value::FunctionCall(ref __self_0),
                            &Value::FunctionCall(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Value::TableConstructor(ref __self_0),
                            &Value::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Value::Number(ref __self_0), &Value::Number(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Value::ParenthesesExpression(ref __self_0),
                            &Value::ParenthesesExpression(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Value::String(ref __self_0), &Value::String(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Value::Symbol(ref __self_0), &Value::Symbol(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Value::Var(ref __self_0), &Value::Var(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Value::Plugin(ref __self_0), &Value::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Value<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Value::Function(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::FunctionCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::TableConstructor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Number(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::ParenthesesExpression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::String(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Symbol(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Var(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Value::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Value::Function(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::FunctionCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::TableConstructor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Number(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::ParenthesesExpression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::String(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Symbol(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Value::Var(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Value::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Value::Function(__self_0) => {
                        if let Value::Function(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::FunctionCall(__self_0) => {
                        if let Value::FunctionCall(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::TableConstructor(__self_0) => {
                        if let Value::TableConstructor(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::Number(__self_0) => {
                        if let Value::Number(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::ParenthesesExpression(__self_0) => {
                        if let Value::ParenthesesExpression(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::String(__self_0) => {
                        if let Value::String(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::Symbol(__self_0) => {
                        if let Value::Symbol(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::Var(__self_0) => {
                        if let Value::Var(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Value::Plugin(__self_0) => {
                        if let Value::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Value::Function(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Value::FunctionCall(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Value::TableConstructor(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Value::Number(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Value::ParenthesesExpression(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Value::String(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Value::Symbol(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Value::Var(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Value::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Value<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Value<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_value(self);
            match self {
                Value::Function(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::FunctionCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::TableConstructor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Number(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::ParenthesesExpression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::String(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Symbol(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Var(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_value_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Value<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_value(self);
            self = match self {
                Value::Function(__self_0) => Value::Function(__self_0.visit_mut(visitor)),
                Value::FunctionCall(__self_0) => Value::FunctionCall(__self_0.visit_mut(visitor)),
                Value::TableConstructor(__self_0) => {
                    Value::TableConstructor(__self_0.visit_mut(visitor))
                }
                Value::Number(__self_0) => Value::Number(__self_0.visit_mut(visitor)),
                Value::ParenthesesExpression(__self_0) => {
                    Value::ParenthesesExpression(__self_0.visit_mut(visitor))
                }
                Value::String(__self_0) => Value::String(__self_0.visit_mut(visitor)),
                Value::Symbol(__self_0) => Value::Symbol(__self_0.visit_mut(visitor)),
                Value::Var(__self_0) => Value::Var(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_value_end(self);
            self
        }
    }
    /// A statement that stands alone
    #[non_exhaustive]
    pub enum Stmt<P: Plugin = DefaultPlugin> {
        /// An assignment, such as `x = 1`
        #[display(fmt = "{}", _0)]
        Assignment(Assignment<P>),
        /// A do block, `do end`
        #[display(fmt = "{}", _0)]
        Do(Do<P>),
        /// A function call on its own, such as `call()`
        #[display(fmt = "{}", _0)]
        FunctionCall(FunctionCall<P>),
        /// A function declaration, such as `function x() end`
        #[display(fmt = "{}", _0)]
        FunctionDeclaration(FunctionDeclaration<P>),
        /// A generic for loop, such as `for index, value in pairs(list) do end`
        #[display(fmt = "{}", _0)]
        GenericFor(GenericFor<P>),
        /// An if statement
        #[display(fmt = "{}", _0)]
        If(If<P>),
        /// A local assignment, such as `local x = 1`
        #[display(fmt = "{}", _0)]
        LocalAssignment(LocalAssignment<P>),
        /// A local function declaration, such as `local function x() end`
        #[display(fmt = "{}", _0)]
        LocalFunction(LocalFunction<P>),
        /// A numeric for loop, such as `for index = 1, 10 do end`
        #[display(fmt = "{}", _0)]
        NumericFor(NumericFor<P>),
        /// A repeat loop
        #[display(fmt = "{}", _0)]
        Repeat(Repeat<P>),
        /// A while loop
        #[display(fmt = "{}", _0)]
        While(While<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::StmtMod as PluginMod<Stmt<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Stmt<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 12",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Assignment" => _serde::export::Ok(__Field::__field0),
                            "Do" => _serde::export::Ok(__Field::__field1),
                            "FunctionCall" => _serde::export::Ok(__Field::__field2),
                            "FunctionDeclaration" => _serde::export::Ok(__Field::__field3),
                            "GenericFor" => _serde::export::Ok(__Field::__field4),
                            "If" => _serde::export::Ok(__Field::__field5),
                            "LocalAssignment" => _serde::export::Ok(__Field::__field6),
                            "LocalFunction" => _serde::export::Ok(__Field::__field7),
                            "NumericFor" => _serde::export::Ok(__Field::__field8),
                            "Repeat" => _serde::export::Ok(__Field::__field9),
                            "While" => _serde::export::Ok(__Field::__field10),
                            "Plugin" => _serde::export::Ok(__Field::__field11),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Assignment" => _serde::export::Ok(__Field::__field0),
                            b"Do" => _serde::export::Ok(__Field::__field1),
                            b"FunctionCall" => _serde::export::Ok(__Field::__field2),
                            b"FunctionDeclaration" => _serde::export::Ok(__Field::__field3),
                            b"GenericFor" => _serde::export::Ok(__Field::__field4),
                            b"If" => _serde::export::Ok(__Field::__field5),
                            b"LocalAssignment" => _serde::export::Ok(__Field::__field6),
                            b"LocalFunction" => _serde::export::Ok(__Field::__field7),
                            b"NumericFor" => _serde::export::Ok(__Field::__field8),
                            b"Repeat" => _serde::export::Ok(__Field::__field9),
                            b"While" => _serde::export::Ok(__Field::__field10),
                            b"Plugin" => _serde::export::Ok(__Field::__field11),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Stmt<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Stmt<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Stmt")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Assignment<P>>(
                                    __variant,
                                ),
                                Stmt::Assignment,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Do<P>>(__variant),
                                Stmt::Do,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionCall<P>>(
                                    __variant,
                                ),
                                Stmt::FunctionCall,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionDeclaration<P>>(
                                    __variant,
                                ),
                                Stmt::FunctionDeclaration,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<GenericFor<P>>(
                                    __variant,
                                ),
                                Stmt::GenericFor,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<If<P>>(__variant),
                                Stmt::If,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<LocalAssignment<P>>(
                                    __variant,
                                ),
                                Stmt::LocalAssignment,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<LocalFunction<P>>(
                                    __variant,
                                ),
                                Stmt::LocalFunction,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<NumericFor<P>>(
                                    __variant,
                                ),
                                Stmt::NumericFor,
                            ),
                            (__Field::__field9, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Repeat<P>>(__variant),
                                Stmt::Repeat,
                            ),
                            (__Field::__field10, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<While<P>>(__variant),
                                Stmt::While,
                            ),
                            (__Field::__field11, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::StmtMod as PluginMod<Stmt<P>>>::NodeInfo,
                                >(__variant),
                                Stmt::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Assignment",
                    "Do",
                    "FunctionCall",
                    "FunctionDeclaration",
                    "GenericFor",
                    "If",
                    "LocalAssignment",
                    "LocalFunction",
                    "NumericFor",
                    "Repeat",
                    "While",
                    "Plugin",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Stmt",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Stmt<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Stmt<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Stmt::Assignment(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            0u32,
                            "Assignment",
                            __field0,
                        )
                    }
                    Stmt::Do(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        1u32,
                        "Do",
                        __field0,
                    ),
                    Stmt::FunctionCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            2u32,
                            "FunctionCall",
                            __field0,
                        )
                    }
                    Stmt::FunctionDeclaration(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            3u32,
                            "FunctionDeclaration",
                            __field0,
                        )
                    }
                    Stmt::GenericFor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            4u32,
                            "GenericFor",
                            __field0,
                        )
                    }
                    Stmt::If(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        5u32,
                        "If",
                        __field0,
                    ),
                    Stmt::LocalAssignment(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            6u32,
                            "LocalAssignment",
                            __field0,
                        )
                    }
                    Stmt::LocalFunction(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            7u32,
                            "LocalFunction",
                            __field0,
                        )
                    }
                    Stmt::NumericFor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            8u32,
                            "NumericFor",
                            __field0,
                        )
                    }
                    Stmt::Repeat(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        9u32,
                        "Repeat",
                        __field0,
                    ),
                    Stmt::While(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        10u32,
                        "While",
                        __field0,
                    ),
                    Stmt::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        11u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Stmt<P> {
        #[inline]
        fn clone(&self) -> Stmt<P> {
            match (&*self,) {
                (&Stmt::Assignment(ref __self_0),) => {
                    Stmt::Assignment(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::Do(ref __self_0),) => Stmt::Do(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::FunctionCall(ref __self_0),) => {
                    Stmt::FunctionCall(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::FunctionDeclaration(ref __self_0),) => {
                    Stmt::FunctionDeclaration(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::GenericFor(ref __self_0),) => {
                    Stmt::GenericFor(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::If(ref __self_0),) => Stmt::If(::core::clone::Clone::clone(&(*__self_0))),
                (&Stmt::LocalAssignment(ref __self_0),) => {
                    Stmt::LocalAssignment(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::LocalFunction(ref __self_0),) => {
                    Stmt::LocalFunction(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::NumericFor(ref __self_0),) => {
                    Stmt::NumericFor(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::Repeat(ref __self_0),) => {
                    Stmt::Repeat(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::While(ref __self_0),) => {
                    Stmt::While(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::Plugin(ref __self_0),) => {
                    Stmt::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Stmt<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Stmt::Assignment(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Assignment");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::Do(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Do");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::FunctionCall(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "FunctionCall");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::FunctionDeclaration(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "FunctionDeclaration");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::GenericFor(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "GenericFor");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::If(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "If");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::LocalAssignment(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LocalAssignment");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::LocalFunction(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LocalFunction");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::NumericFor(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "NumericFor");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::Repeat(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Repeat");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::While(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "While");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Stmt::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Stmt<P>
    where
        Do<P>: ::core::fmt::Display,
        NumericFor<P>: ::core::fmt::Display,
        Assignment<P>: ::core::fmt::Display,
        If<P>: ::core::fmt::Display,
        LocalAssignment<P>: ::core::fmt::Display,
        FunctionCall<P>: ::core::fmt::Display,
        While<P>: ::core::fmt::Display,
        Repeat<P>: ::core::fmt::Display,
        FunctionDeclaration<P>: ::core::fmt::Display,
        GenericFor<P>: ::core::fmt::Display,
        LocalFunction<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Stmt::Assignment(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::Do(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::FunctionCall(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::FunctionDeclaration(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::GenericFor(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::If(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::LocalAssignment(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::LocalFunction(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::NumericFor(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::Repeat(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::While(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Stmt::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Stmt<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Stmt<P> {
        #[inline]
        fn eq(&self, other: &Stmt<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Assignment(ref __self_0), &Stmt::Assignment(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::Do(ref __self_0), &Stmt::Do(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::FunctionCall(ref __self_0), &Stmt::FunctionCall(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Stmt::FunctionDeclaration(ref __self_0),
                            &Stmt::FunctionDeclaration(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Stmt::GenericFor(ref __self_0), &Stmt::GenericFor(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::If(ref __self_0), &Stmt::If(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Stmt::LocalAssignment(ref __self_0),
                            &Stmt::LocalAssignment(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Stmt::LocalFunction(ref __self_0),
                            &Stmt::LocalFunction(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Stmt::NumericFor(ref __self_0), &Stmt::NumericFor(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::Repeat(ref __self_0), &Stmt::Repeat(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::While(ref __self_0), &Stmt::While(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::Plugin(ref __self_0), &Stmt::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Stmt<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Assignment(ref __self_0), &Stmt::Assignment(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::Do(ref __self_0), &Stmt::Do(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::FunctionCall(ref __self_0), &Stmt::FunctionCall(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Stmt::FunctionDeclaration(ref __self_0),
                            &Stmt::FunctionDeclaration(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Stmt::GenericFor(ref __self_0), &Stmt::GenericFor(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::If(ref __self_0), &Stmt::If(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Stmt::LocalAssignment(ref __self_0),
                            &Stmt::LocalAssignment(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Stmt::LocalFunction(ref __self_0),
                            &Stmt::LocalFunction(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Stmt::NumericFor(ref __self_0), &Stmt::NumericFor(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::Repeat(ref __self_0), &Stmt::Repeat(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::While(ref __self_0), &Stmt::While(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::Plugin(ref __self_0), &Stmt::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Stmt<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Stmt::Assignment(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Do(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Stmt::FunctionCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::FunctionDeclaration(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::GenericFor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::If(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Stmt::LocalAssignment(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::LocalFunction(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::NumericFor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Repeat(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::While(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Stmt::Assignment(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Do(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Stmt::FunctionCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::FunctionDeclaration(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::GenericFor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::If(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Stmt::LocalAssignment(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::LocalFunction(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::NumericFor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Repeat(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::While(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Stmt::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Stmt::Assignment(__self_0) => {
                        if let Stmt::Assignment(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::Do(__self_0) => {
                        if let Stmt::Do(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::FunctionCall(__self_0) => {
                        if let Stmt::FunctionCall(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::FunctionDeclaration(__self_0) => {
                        if let Stmt::FunctionDeclaration(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::GenericFor(__self_0) => {
                        if let Stmt::GenericFor(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::If(__self_0) => {
                        if let Stmt::If(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::LocalAssignment(__self_0) => {
                        if let Stmt::LocalAssignment(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::LocalFunction(__self_0) => {
                        if let Stmt::LocalFunction(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::NumericFor(__self_0) => {
                        if let Stmt::NumericFor(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::Repeat(__self_0) => {
                        if let Stmt::Repeat(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::While(__self_0) => {
                        if let Stmt::While(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Stmt::Plugin(__self_0) => {
                        if let Stmt::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Stmt::Assignment(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::Do(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::FunctionCall(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::FunctionDeclaration(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::GenericFor(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::If(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::LocalAssignment(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::LocalFunction(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::NumericFor(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::Repeat(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::While(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Stmt::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Stmt<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Stmt<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_stmt(self);
            match self {
                Stmt::Assignment(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::Do(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::FunctionCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::FunctionDeclaration(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::GenericFor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::If(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::LocalAssignment(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::LocalFunction(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::NumericFor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::Repeat(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::While(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_stmt_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Stmt<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_stmt(self);
            self = match self {
                Stmt::Assignment(__self_0) => Stmt::Assignment(__self_0.visit_mut(visitor)),
                Stmt::Do(__self_0) => Stmt::Do(__self_0.visit_mut(visitor)),
                Stmt::FunctionCall(__self_0) => Stmt::FunctionCall(__self_0.visit_mut(visitor)),
                Stmt::FunctionDeclaration(__self_0) => {
                    Stmt::FunctionDeclaration(__self_0.visit_mut(visitor))
                }
                Stmt::GenericFor(__self_0) => Stmt::GenericFor(__self_0.visit_mut(visitor)),
                Stmt::If(__self_0) => Stmt::If(__self_0.visit_mut(visitor)),
                Stmt::LocalAssignment(__self_0) => {
                    Stmt::LocalAssignment(__self_0.visit_mut(visitor))
                }
                Stmt::LocalFunction(__self_0) => Stmt::LocalFunction(__self_0.visit_mut(visitor)),
                Stmt::NumericFor(__self_0) => Stmt::NumericFor(__self_0.visit_mut(visitor)),
                Stmt::Repeat(__self_0) => Stmt::Repeat(__self_0.visit_mut(visitor)),
                Stmt::While(__self_0) => Stmt::While(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_stmt_end(self);
            self
        }
    }
    /// A node used before another in cases such as function calling
    /// The `("foo")` part of `("foo"):upper()`
    #[non_exhaustive]
    pub enum Prefix<P: Plugin = DefaultPlugin> {
        #[display(fmt = "{}", _0)]
        /// A complicated expression, such as `("foo")`
        Expression(Expression<P>),
        #[display(fmt = "{}", _0)]
        /// Just a name, such as `foo`
        Name(TokenReference),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::PrefixMod as PluginMod<Prefix<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Prefix<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Expression" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Expression" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Prefix<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Prefix<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Prefix")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Expression<P>>(
                                    __variant,
                                ),
                                Prefix::Expression,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                Prefix::Name,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::PrefixMod as PluginMod<Prefix<P>>>::NodeInfo,
                                >(__variant),
                                Prefix::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Expression", "Name", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Prefix",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Prefix<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Prefix<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Prefix::Expression(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Prefix",
                            0u32,
                            "Expression",
                            __field0,
                        )
                    }
                    Prefix::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Prefix",
                        1u32,
                        "Name",
                        __field0,
                    ),
                    Prefix::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Prefix",
                        2u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Prefix<P> {
        #[inline]
        fn clone(&self) -> Prefix<P> {
            match (&*self,) {
                (&Prefix::Expression(ref __self_0),) => {
                    Prefix::Expression(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Prefix::Name(ref __self_0),) => {
                    Prefix::Name(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Prefix::Plugin(ref __self_0),) => {
                    Prefix::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Prefix<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Prefix::Expression(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Expression");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Prefix::Name(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Name");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Prefix::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Prefix<P>
    where
        Expression<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Prefix::Expression(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Prefix::Name(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Prefix::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Prefix<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Prefix<P> {
        #[inline]
        fn eq(&self, other: &Prefix<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Prefix::Expression(ref __self_0), &Prefix::Expression(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Prefix::Name(ref __self_0), &Prefix::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Prefix::Plugin(ref __self_0), &Prefix::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Prefix<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Prefix::Expression(ref __self_0), &Prefix::Expression(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Prefix::Name(ref __self_0), &Prefix::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Prefix::Plugin(ref __self_0), &Prefix::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Prefix<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Prefix::Expression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Prefix::Name(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Prefix::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Prefix::Expression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Prefix::Name(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Prefix::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Prefix::Expression(__self_0) => {
                        if let Prefix::Expression(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Prefix::Name(__self_0) => {
                        if let Prefix::Name(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Prefix::Plugin(__self_0) => {
                        if let Prefix::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Prefix::Expression(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Prefix::Name(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Prefix::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Prefix<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Prefix<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_prefix(self);
            match self {
                Prefix::Expression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Prefix::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_prefix_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Prefix<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_prefix(self);
            self = match self {
                Prefix::Expression(__self_0) => Prefix::Expression(__self_0.visit_mut(visitor)),
                Prefix::Name(__self_0) => Prefix::Name(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_prefix_end(self);
            self
        }
    }
    /// The indexing of something, such as `x.y` or `x["y"]`
    /// Values of variants are the keys, such as `"y"`
    #[non_exhaustive]
    pub enum Index<P: Plugin = DefaultPlugin> {
        /// Indexing in the form of `x["y"]`
        #[display(
            fmt = "{}{}{}",
            "brackets.tokens().0",
            "expression",
            "brackets.tokens().1"
        )]
        Brackets {
            /// The `[...]` part of `["y"]`
            brackets: ContainedSpan,
            /// The `"y"` part of `["y"]`
            expression: Expression<P>,
        },
        /// Indexing in the form of `x.y`
        #[display(fmt = "{}{}", "dot", "name")]
        Dot {
            /// The `.` part of `.y`
            dot: TokenReference,
            /// The `y` part of `.y`
            name: TokenReference,
        },
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::IndexMod as PluginMod<Index<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Index<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Brackets" => _serde::export::Ok(__Field::__field0),
                            "Dot" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Brackets" => _serde::export::Ok(__Field::__field0),
                            b"Dot" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Index<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Index<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Index")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "brackets" => _serde::export::Ok(__Field::__field0),
                                            "expression" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"brackets" => _serde::export::Ok(__Field::__field0),
                                            b"expression" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, P: Plugin>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::export::PhantomData<Index<P>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    type Value = Index<P>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Index::Brackets",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                ContainedSpan,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Index::Brackets with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Expression<P>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Index::Brackets with 2 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(Index::Brackets {
                                            brackets: __field0,
                                            expression: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<ContainedSpan> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<Expression<P>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("brackets")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ContainedSpan,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("expression")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Expression<P>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("brackets")
                                                {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "expression",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Index::Brackets {
                                            brackets: __field0,
                                            expression: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["brackets", "expression"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Index<P>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "dot" => _serde::export::Ok(__Field::__field0),
                                            "name" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"dot" => _serde::export::Ok(__Field::__field0),
                                            b"name" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, P: Plugin>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::export::PhantomData<Index<P>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    type Value = Index<P>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Index::Dot",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Index::Dot with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Index::Dot with 2 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(Index::Dot {
                                            dot: __field0,
                                            name: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<TokenReference> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<TokenReference> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("dot")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("dot") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("name") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Index::Dot {
                                            dot: __field0,
                                            name: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["dot", "name"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Index<P>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::IndexMod as PluginMod<Index<P>>>::NodeInfo,
                                >(__variant),
                                Index::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Brackets", "Dot", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Index",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Index<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Index<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Index::Brackets {
                        ref brackets,
                        ref expression,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Index",
                            0u32,
                            "Brackets",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "brackets",
                            brackets,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "expression",
                            expression,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Index::Dot { ref dot, ref name } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Index",
                            1u32,
                            "Dot",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "dot",
                            dot,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "name",
                            name,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Index::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Index",
                        2u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Index<P> {
        #[inline]
        fn clone(&self) -> Index<P> {
            match (&*self,) {
                (&Index::Brackets {
                    brackets: ref __self_0,
                    expression: ref __self_1,
                },) => Index::Brackets {
                    brackets: ::core::clone::Clone::clone(&(*__self_0)),
                    expression: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Index::Dot {
                    dot: ref __self_0,
                    name: ref __self_1,
                },) => Index::Dot {
                    dot: ::core::clone::Clone::clone(&(*__self_0)),
                    name: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Index::Plugin(ref __self_0),) => {
                    Index::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Index<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Index::Brackets {
                    brackets: ref __self_0,
                    expression: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Brackets");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "brackets",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expression",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Index::Dot {
                    dot: ref __self_0,
                    name: ref __self_1,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Dot");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "dot", &&(*__self_0));
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "name", &&(*__self_1));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Index::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Index<P>
    where
        Expression<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Index::Brackets {
                    brackets,
                    expression,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&brackets.tokens().0, &expression, &brackets.tokens().1) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                Index::Dot { dot, name } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&dot, &name) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
                Index::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Index<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Index<P> {
        #[inline]
        fn eq(&self, other: &Index<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Index::Brackets {
                                brackets: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Index::Brackets {
                                brackets: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Index::Dot {
                                dot: ref __self_0,
                                name: ref __self_1,
                            },
                            &Index::Dot {
                                dot: ref __arg_1_0,
                                name: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (&Index::Plugin(ref __self_0), &Index::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Index<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Index::Brackets {
                                brackets: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Index::Brackets {
                                brackets: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Index::Dot {
                                dot: ref __self_0,
                                name: ref __self_1,
                            },
                            &Index::Dot {
                                dot: ref __arg_1_0,
                                name: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (&Index::Plugin(ref __self_0), &Index::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Index<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Index::Brackets {
                            brackets,
                            expression,
                        } => Some((
                            None.or_else(|| brackets.start_position())
                                .or_else(|| expression.start_position())?,
                            None.or_else(|| expression.end_position())
                                .or_else(|| brackets.end_position())?,
                        )),
                        Index::Dot { dot, name } => Some((
                            None.or_else(|| dot.start_position())
                                .or_else(|| name.start_position())?,
                            None.or_else(|| name.end_position())
                                .or_else(|| dot.end_position())?,
                        )),
                        Index::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Index::Brackets {
                            brackets,
                            expression,
                        } => Some((
                            None.or_else(|| brackets.start_position())
                                .or_else(|| expression.start_position())?,
                            None.or_else(|| expression.end_position())
                                .or_else(|| brackets.end_position())?,
                        )),
                        Index::Dot { dot, name } => Some((
                            None.or_else(|| dot.start_position())
                                .or_else(|| name.start_position())?,
                            None.or_else(|| name.end_position())
                                .or_else(|| dot.end_position())?,
                        )),
                        Index::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Index::Brackets {
                        brackets,
                        expression,
                    } => {
                        if let Index::Brackets {
                            brackets: other_brackets,
                            expression: other_expression,
                        } = &other
                        {
                            brackets.similar(other_brackets)
                                && expression.similar(other_expression)
                                && true
                        } else {
                            false
                        }
                    }
                    Index::Dot { dot, name } => {
                        if let Index::Dot {
                            dot: other_dot,
                            name: other_name,
                        } = &other
                        {
                            dot.similar(other_dot) && name.similar(other_name) && true
                        } else {
                            false
                        }
                    }
                    Index::Plugin(__self_0) => {
                        if let Index::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Index::Brackets {
                        ref brackets,
                        ref expression,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*brackets),
                            crate::node::TokenItem::MoreTokens(&*expression),
                        ]),
                    },
                    Index::Dot { ref dot, ref name } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::TokenReference(&dot),
                            crate::node::TokenItem::TokenReference(&name),
                        ]),
                    },
                    Index::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Index<P> {}
    /// Arguments used for a function
    #[non_exhaustive]
    pub enum FunctionArgs<P: Plugin = DefaultPlugin> {
        /// Used when a function is called in the form of `call(1, 2, 3)`
        #[display(
            fmt = "{}{}{}",
            "parentheses.tokens().0",
            "arguments",
            "parentheses.tokens().1"
        )]
        Parentheses {
            /// The `(...) part of (1, 2, 3)`
            #[node(full_range)]
            parentheses: ContainedSpan,
            /// The `1, 2, 3` part of `1, 2, 3`
            arguments: Punctuated<Expression<P>>,
        },
        /// Used when a function is called in the form of `call "foobar"`
        #[display(fmt = "{}", "_0")]
        String(TokenReference),
        /// Used when a function is called in the form of `call { 1, 2, 3 }`
        #[display(fmt = "{}", "_0")]
        TableConstructor(TableConstructor<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::FunctionArgsMod as PluginMod<FunctionArgs<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for FunctionArgs<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Parentheses" => _serde::export::Ok(__Field::__field0),
                            "String" => _serde::export::Ok(__Field::__field1),
                            "TableConstructor" => _serde::export::Ok(__Field::__field2),
                            "Plugin" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Parentheses" => _serde::export::Ok(__Field::__field0),
                            b"String" => _serde::export::Ok(__Field::__field1),
                            b"TableConstructor" => _serde::export::Ok(__Field::__field2),
                            b"Plugin" => _serde::export::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<FunctionArgs<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = FunctionArgs<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum FunctionArgs")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "parentheses" => _serde::export::Ok(__Field::__field0),
                                            "arguments" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"parentheses" => _serde::export::Ok(__Field::__field0),
                                            b"arguments" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, P: Plugin>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::export::PhantomData<FunctionArgs<P>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                                where
                                    P: _serde::Deserialize<'de>,
                                {
                                    type Value = FunctionArgs<P>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant FunctionArgs::Parentheses",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                ContainedSpan,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant FunctionArgs::Parentheses with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Punctuated<Expression<P>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant FunctionArgs::Parentheses with 2 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(FunctionArgs::Parentheses {
                                            parentheses: __field0,
                                            arguments: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<ContainedSpan> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<
                                            Punctuated<Expression<P>>,
                                        > = _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("parentheses")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ContainedSpan,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arguments")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Punctuated<Expression<P>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "parentheses",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "arguments",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(FunctionArgs::Parentheses {
                                            parentheses: __field0,
                                            arguments: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["parentheses", "arguments"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<FunctionArgs<P>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                FunctionArgs::String,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TableConstructor<P>>(
                                    __variant,
                                ),
                                FunctionArgs::TableConstructor,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::FunctionArgsMod as PluginMod<
                                        FunctionArgs<P>,
                                    >>::NodeInfo,
                                >(__variant),
                                FunctionArgs::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["Parentheses", "String", "TableConstructor", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FunctionArgs",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionArgs<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for FunctionArgs<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FunctionArgs::Parentheses {
                        ref parentheses,
                        ref arguments,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "FunctionArgs",
                            0u32,
                            "Parentheses",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "parentheses",
                            parentheses,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "arguments",
                            arguments,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    FunctionArgs::String(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            1u32,
                            "String",
                            __field0,
                        )
                    }
                    FunctionArgs::TableConstructor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            2u32,
                            "TableConstructor",
                            __field0,
                        )
                    }
                    FunctionArgs::Plugin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            3u32,
                            "Plugin",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for FunctionArgs<P> {
        #[inline]
        fn clone(&self) -> FunctionArgs<P> {
            match (&*self,) {
                (&FunctionArgs::Parentheses {
                    parentheses: ref __self_0,
                    arguments: ref __self_1,
                },) => FunctionArgs::Parentheses {
                    parentheses: ::core::clone::Clone::clone(&(*__self_0)),
                    arguments: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&FunctionArgs::String(ref __self_0),) => {
                    FunctionArgs::String(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&FunctionArgs::TableConstructor(ref __self_0),) => {
                    FunctionArgs::TableConstructor(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&FunctionArgs::Plugin(ref __self_0),) => {
                    FunctionArgs::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for FunctionArgs<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&FunctionArgs::Parentheses {
                    parentheses: ref __self_0,
                    arguments: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Parentheses");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "parentheses",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "arguments",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&FunctionArgs::String(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "String");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&FunctionArgs::TableConstructor(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TableConstructor");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&FunctionArgs::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for FunctionArgs<P>
    where
        Punctuated<Expression<P>>: ::core::fmt::Display,
        TableConstructor<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                FunctionArgs::Parentheses {
                    parentheses,
                    arguments,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&parentheses.tokens().0, &arguments, &parentheses.tokens().1) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                FunctionArgs::String(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                FunctionArgs::TableConstructor(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                FunctionArgs::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for FunctionArgs<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for FunctionArgs<P> {
        #[inline]
        fn eq(&self, other: &FunctionArgs<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FunctionArgs::Parentheses {
                                parentheses: ref __self_0,
                                arguments: ref __self_1,
                            },
                            &FunctionArgs::Parentheses {
                                parentheses: ref __arg_1_0,
                                arguments: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &FunctionArgs::String(ref __self_0),
                            &FunctionArgs::String(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &FunctionArgs::TableConstructor(ref __self_0),
                            &FunctionArgs::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &FunctionArgs::Plugin(ref __self_0),
                            &FunctionArgs::Plugin(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionArgs<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FunctionArgs::Parentheses {
                                parentheses: ref __self_0,
                                arguments: ref __self_1,
                            },
                            &FunctionArgs::Parentheses {
                                parentheses: ref __arg_1_0,
                                arguments: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &FunctionArgs::String(ref __self_0),
                            &FunctionArgs::String(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &FunctionArgs::TableConstructor(ref __self_0),
                            &FunctionArgs::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &FunctionArgs::Plugin(ref __self_0),
                            &FunctionArgs::Plugin(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for FunctionArgs<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        FunctionArgs::Parentheses {
                            parentheses,
                            arguments,
                        } => parentheses.range(),
                        FunctionArgs::String(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        FunctionArgs::TableConstructor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        FunctionArgs::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        FunctionArgs::Parentheses {
                            parentheses,
                            arguments,
                        } => parentheses.range(),
                        FunctionArgs::String(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        FunctionArgs::TableConstructor(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        FunctionArgs::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    FunctionArgs::Parentheses {
                        parentheses,
                        arguments,
                    } => {
                        if let FunctionArgs::Parentheses {
                            parentheses: other_parentheses,
                            arguments: other_arguments,
                        } = &other
                        {
                            parentheses.similar(other_parentheses)
                                && arguments.similar(other_arguments)
                                && true
                        } else {
                            false
                        }
                    }
                    FunctionArgs::String(__self_0) => {
                        if let FunctionArgs::String(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    FunctionArgs::TableConstructor(__self_0) => {
                        if let FunctionArgs::TableConstructor(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    FunctionArgs::Plugin(__self_0) => {
                        if let FunctionArgs::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    FunctionArgs::Parentheses {
                        ref parentheses,
                        ref arguments,
                    } => crate::node::Tokens {
                        items: <[_]>::into_vec(box [
                            crate::node::TokenItem::MoreTokens(&*parentheses),
                            crate::node::TokenItem::MoreTokens(&*arguments),
                        ]),
                    },
                    FunctionArgs::String(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    FunctionArgs::TableConstructor(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    FunctionArgs::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for FunctionArgs<P> {}
    /// A numeric for loop, such as `for index = 1, 10 do end`
    pub struct NumericFor<P: Plugin = DefaultPlugin> {
        for_token: TokenReference,
        index_variable: TokenReference,
        equal_token: TokenReference,
        start: Expression<P>,
        start_end_comma: TokenReference,
        end: Expression<P>,
        end_step_comma: Option<TokenReference>,
        step: Option<Expression<P>>,
        do_token: TokenReference,
        block: Block<P>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for NumericFor<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 11",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "for_token" => _serde::export::Ok(__Field::__field0),
                            "index_variable" => _serde::export::Ok(__Field::__field1),
                            "equal_token" => _serde::export::Ok(__Field::__field2),
                            "start" => _serde::export::Ok(__Field::__field3),
                            "start_end_comma" => _serde::export::Ok(__Field::__field4),
                            "end" => _serde::export::Ok(__Field::__field5),
                            "end_step_comma" => _serde::export::Ok(__Field::__field6),
                            "step" => _serde::export::Ok(__Field::__field7),
                            "do_token" => _serde::export::Ok(__Field::__field8),
                            "block" => _serde::export::Ok(__Field::__field9),
                            "end_token" => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"for_token" => _serde::export::Ok(__Field::__field0),
                            b"index_variable" => _serde::export::Ok(__Field::__field1),
                            b"equal_token" => _serde::export::Ok(__Field::__field2),
                            b"start" => _serde::export::Ok(__Field::__field3),
                            b"start_end_comma" => _serde::export::Ok(__Field::__field4),
                            b"end" => _serde::export::Ok(__Field::__field5),
                            b"end_step_comma" => _serde::export::Ok(__Field::__field6),
                            b"step" => _serde::export::Ok(__Field::__field7),
                            b"do_token" => _serde::export::Ok(__Field::__field8),
                            b"block" => _serde::export::Ok(__Field::__field9),
                            b"end_token" => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<NumericFor<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = NumericFor<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct NumericFor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            Option<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            Option<Expression<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field8 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    8usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        let __field9 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct NumericFor with 11 elements",
                                    ));
                                }
                            };
                        let __field10 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    10usize,
                                    &"struct NumericFor with 11 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(NumericFor {
                            for_token: __field0,
                            index_variable: __field1,
                            equal_token: __field2,
                            start: __field3,
                            start_end_comma: __field4,
                            end: __field5,
                            end_step_comma: __field6,
                            step: __field7,
                            do_token: __field8,
                            block: __field9,
                            end_token: __field10,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        let mut __field4: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field5: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        let mut __field6: _serde::export::Option<Option<TokenReference>> =
                            _serde::export::None;
                        let mut __field7: _serde::export::Option<Option<Expression<P>>> =
                            _serde::export::None;
                        let mut __field8: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field9: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field10: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "for_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "index_variable",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "equal_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start_end_comma",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::export::Option::is_some(&__field5) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::export::Option::is_some(&__field6) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_step_comma",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::export::Option::is_some(&__field7) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "step",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Expression<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::export::Option::is_some(&__field8) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "do_token",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field9 => {
                                    if _serde::export::Option::is_some(&__field9) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field9 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field10 => {
                                    if _serde::export::Option::is_some(&__field10) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field10 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("for_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("index_variable") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("equal_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("start") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("start_end_comma") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::export::Some(__field5) => __field5,
                            _serde::export::None => match _serde::private::de::missing_field("end")
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            },
                        };
                        let __field6 = match __field6 {
                            _serde::export::Some(__field6) => __field6,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_step_comma") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::export::Some(__field7) => __field7,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("step") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::export::Some(__field8) => __field8,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("do_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field9 = match __field9 {
                            _serde::export::Some(__field9) => __field9,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field10 = match __field10 {
                            _serde::export::Some(__field10) => __field10,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(NumericFor {
                            for_token: __field0,
                            index_variable: __field1,
                            equal_token: __field2,
                            start: __field3,
                            start_end_comma: __field4,
                            end: __field5,
                            end_step_comma: __field6,
                            step: __field7,
                            do_token: __field8,
                            block: __field9,
                            end_token: __field10,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "for_token",
                    "index_variable",
                    "equal_token",
                    "start",
                    "start_end_comma",
                    "end",
                    "end_step_comma",
                    "step",
                    "do_token",
                    "block",
                    "end_token",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NumericFor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<NumericFor<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for NumericFor<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "NumericFor",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "for_token",
                    &self.for_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index_variable",
                    &self.index_variable,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "equal_token",
                    &self.equal_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start",
                    &self.start,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start_end_comma",
                    &self.start_end_comma,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end",
                    &self.end,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_step_comma",
                    &self.end_step_comma,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "step",
                    &self.step,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "do_token",
                    &self.do_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for NumericFor<P> {
        #[inline]
        fn clone(&self) -> NumericFor<P> {
            match *self {
                NumericFor {
                    for_token: ref __self_0_0,
                    index_variable: ref __self_0_1,
                    equal_token: ref __self_0_2,
                    start: ref __self_0_3,
                    start_end_comma: ref __self_0_4,
                    end: ref __self_0_5,
                    end_step_comma: ref __self_0_6,
                    step: ref __self_0_7,
                    do_token: ref __self_0_8,
                    block: ref __self_0_9,
                    end_token: ref __self_0_10,
                } => NumericFor {
                    for_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    index_variable: ::core::clone::Clone::clone(&(*__self_0_1)),
                    equal_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    start: ::core::clone::Clone::clone(&(*__self_0_3)),
                    start_end_comma: ::core::clone::Clone::clone(&(*__self_0_4)),
                    end: ::core::clone::Clone::clone(&(*__self_0_5)),
                    end_step_comma: ::core::clone::Clone::clone(&(*__self_0_6)),
                    step: ::core::clone::Clone::clone(&(*__self_0_7)),
                    do_token: ::core::clone::Clone::clone(&(*__self_0_8)),
                    block: ::core::clone::Clone::clone(&(*__self_0_9)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_10)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for NumericFor<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                NumericFor {
                    for_token: ref __self_0_0,
                    index_variable: ref __self_0_1,
                    equal_token: ref __self_0_2,
                    start: ref __self_0_3,
                    start_end_comma: ref __self_0_4,
                    end: ref __self_0_5,
                    end_step_comma: ref __self_0_6,
                    step: ref __self_0_7,
                    do_token: ref __self_0_8,
                    block: ref __self_0_9,
                    end_token: ref __self_0_10,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "NumericFor");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "for_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "index_variable",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "equal_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "start",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "start_end_comma",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_step_comma",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "step",
                        &&(*__self_0_7),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "do_token",
                        &&(*__self_0_8),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_9),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_10),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for NumericFor<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for NumericFor<P> {
        #[inline]
        fn eq(&self, other: &NumericFor<P>) -> bool {
            match *other {
                NumericFor {
                    for_token: ref __self_1_0,
                    index_variable: ref __self_1_1,
                    equal_token: ref __self_1_2,
                    start: ref __self_1_3,
                    start_end_comma: ref __self_1_4,
                    end: ref __self_1_5,
                    end_step_comma: ref __self_1_6,
                    step: ref __self_1_7,
                    do_token: ref __self_1_8,
                    block: ref __self_1_9,
                    end_token: ref __self_1_10,
                } => match *self {
                    NumericFor {
                        for_token: ref __self_0_0,
                        index_variable: ref __self_0_1,
                        equal_token: ref __self_0_2,
                        start: ref __self_0_3,
                        start_end_comma: ref __self_0_4,
                        end: ref __self_0_5,
                        end_step_comma: ref __self_0_6,
                        step: ref __self_0_7,
                        do_token: ref __self_0_8,
                        block: ref __self_0_9,
                        end_token: ref __self_0_10,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                            && (*__self_0_8) == (*__self_1_8)
                            && (*__self_0_9) == (*__self_1_9)
                            && (*__self_0_10) == (*__self_1_10)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NumericFor<P>) -> bool {
            match *other {
                NumericFor {
                    for_token: ref __self_1_0,
                    index_variable: ref __self_1_1,
                    equal_token: ref __self_1_2,
                    start: ref __self_1_3,
                    start_end_comma: ref __self_1_4,
                    end: ref __self_1_5,
                    end_step_comma: ref __self_1_6,
                    step: ref __self_1_7,
                    do_token: ref __self_1_8,
                    block: ref __self_1_9,
                    end_token: ref __self_1_10,
                } => match *self {
                    NumericFor {
                        for_token: ref __self_0_0,
                        index_variable: ref __self_0_1,
                        equal_token: ref __self_0_2,
                        start: ref __self_0_3,
                        start_end_comma: ref __self_0_4,
                        end: ref __self_0_5,
                        end_step_comma: ref __self_0_6,
                        step: ref __self_0_7,
                        do_token: ref __self_0_8,
                        block: ref __self_0_9,
                        end_token: ref __self_0_10,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                            || (*__self_0_8) != (*__self_1_8)
                            || (*__self_0_9) != (*__self_1_9)
                            || (*__self_0_10) != (*__self_1_10)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for NumericFor<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.for_token.start_position())
                            .or_else(|| self.index_variable.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.start.start_position())
                            .or_else(|| self.start_end_comma.start_position())
                            .or_else(|| self.end.start_position())
                            .or_else(|| self.end_step_comma.start_position())
                            .or_else(|| self.step.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.step.end_position())
                            .or_else(|| self.end_step_comma.end_position())
                            .or_else(|| self.end.end_position())
                            .or_else(|| self.start_end_comma.end_position())
                            .or_else(|| self.start.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.index_variable.end_position())
                            .or_else(|| self.for_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.for_token.start_position())
                            .or_else(|| self.index_variable.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.start.start_position())
                            .or_else(|| self.start_end_comma.start_position())
                            .or_else(|| self.end.start_position())
                            .or_else(|| self.end_step_comma.start_position())
                            .or_else(|| self.step.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.step.end_position())
                            .or_else(|| self.end_step_comma.end_position())
                            .or_else(|| self.end.end_position())
                            .or_else(|| self.start_end_comma.end_position())
                            .or_else(|| self.start.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.index_variable.end_position())
                            .or_else(|| self.for_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.for_token.similar(&other.for_token)
                    && self.index_variable.similar(&other.index_variable)
                    && self.equal_token.similar(&other.equal_token)
                    && self.start.similar(&other.start)
                    && self.start_end_comma.similar(&other.start_end_comma)
                    && self.end.similar(&other.end)
                    && self.end_step_comma.similar(&other.end_step_comma)
                    && self.step.similar(&other.step)
                    && self.do_token.similar(&other.do_token)
                    && self.block.similar(&other.block)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.for_token),
                        crate::node::TokenItem::TokenReference(&self.index_variable),
                        crate::node::TokenItem::TokenReference(&self.equal_token),
                        crate::node::TokenItem::MoreTokens(&self.start),
                        crate::node::TokenItem::TokenReference(&self.start_end_comma),
                        crate::node::TokenItem::MoreTokens(&self.end),
                        crate::node::TokenItem::MoreTokens(&self.end_step_comma),
                        crate::node::TokenItem::MoreTokens(&self.step),
                        crate::node::TokenItem::TokenReference(&self.do_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for NumericFor<P> {}
    impl<P: Plugin> NumericFor<P> {
        /// Creates a new NumericFor from the given index variable, start, and end expressions
        pub fn new(
            index_variable: TokenReference,
            start: Expression<P>,
            end: Expression<P>,
        ) -> Self {
            Self {
                for_token: TokenReference::symbol("for ").unwrap(),
                index_variable,
                equal_token: TokenReference::symbol(" = ").unwrap(),
                start,
                start_end_comma: TokenReference::symbol(", ").unwrap(),
                end,
                end_step_comma: None,
                step: None,
                do_token: TokenReference::symbol(" do\n").unwrap(),
                block: Block::new(),
                end_token: TokenReference::symbol("\nend").unwrap(),
            }
        }
        /// The `for` token
        pub fn for_token(&self) -> &TokenReference {
            &self.for_token
        }
        /// The index identity, `index` in the initial example
        pub fn index_variable(&self) -> &TokenReference {
            &self.index_variable
        }
        /// The `=` token
        pub fn equal_token(&self) -> &TokenReference {
            &self.equal_token
        }
        /// The starting point, `1` in the initial example
        pub fn start(&self) -> &Expression<P> {
            &self.start
        }
        /// The comma in between the starting point and end point
        /// for _ = 1, 10 do
        ///          ^
        pub fn start_end_comma(&self) -> &TokenReference {
            &self.start_end_comma
        }
        /// The ending point, `10` in the initial example
        pub fn end(&self) -> &Expression<P> {
            &self.end
        }
        /// The comma in between the ending point and limit, if one exists
        /// for _ = 0, 10, 2 do
        ///              ^
        pub fn end_step_comma(&self) -> Option<&TokenReference> {
            self.end_step_comma.as_ref()
        }
        /// The step if one exists, `2` in `for index = 0, 10, 2 do end`
        pub fn step(&self) -> Option<&Expression<P>> {
            self.step.as_ref()
        }
        /// The `do` token
        pub fn do_token(&self) -> &TokenReference {
            &self.do_token
        }
        /// The code inside the for loop
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new NumericFor with the given for token
        pub fn with_for_token(self, for_token: TokenReference) -> Self {
            Self { for_token, ..self }
        }
        /// Returns a new NumericFor with the given index variable
        pub fn with_index_variable(self, index_variable: TokenReference) -> Self {
            Self {
                index_variable,
                ..self
            }
        }
        /// Returns a new NumericFor with the given `=` token
        pub fn with_equal_token(self, equal_token: TokenReference) -> Self {
            Self {
                equal_token,
                ..self
            }
        }
        /// Returns a new NumericFor with the given start expression
        pub fn with_start(self, start: Expression<P>) -> Self {
            Self { start, ..self }
        }
        /// Returns a new NumericFor with the given comma between the start and end expressions
        pub fn with_start_end_comma(self, start_end_comma: TokenReference) -> Self {
            Self {
                start_end_comma,
                ..self
            }
        }
        /// Returns a new NumericFor with the given end expression
        pub fn with_end(self, end: Expression<P>) -> Self {
            Self { end, ..self }
        }
        /// Returns a new NumericFor with the given comma between the end and the step expressions
        pub fn with_end_step_comma(self, end_step_comma: Option<TokenReference>) -> Self {
            Self {
                end_step_comma,
                ..self
            }
        }
        /// Returns a new NumericFor with the given step expression
        pub fn with_step(self, step: Option<Expression<P>>) -> Self {
            Self { step, ..self }
        }
        /// Returns a new NumericFor with the given `do` token
        pub fn with_do_token(self, do_token: TokenReference) -> Self {
            Self { do_token, ..self }
        }
        /// Returns a new NumericFor with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
        /// Returns a new NumericFor with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    impl fmt::Display for NumericFor {
        #[cfg(not(feature = "roblox"))]
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["not implemented: "],
                &match (&::core::fmt::Arguments::new_v1(
                    &["PLUGIN TODO: NumericFor::Display"],
                    &match () {
                        () => [],
                    },
                ),)
                {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    /// A generic for loop, such as `for index, value in pairs(list) do end`
    pub struct GenericFor<P: Plugin = DefaultPlugin> {
        for_token: TokenReference,
        names: Punctuated<TokenReference>,
        in_token: TokenReference,
        expr_list: Punctuated<Expression<P>>,
        do_token: TokenReference,
        block: Block<P>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for GenericFor<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 7",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "for_token" => _serde::export::Ok(__Field::__field0),
                            "names" => _serde::export::Ok(__Field::__field1),
                            "in_token" => _serde::export::Ok(__Field::__field2),
                            "expr_list" => _serde::export::Ok(__Field::__field3),
                            "do_token" => _serde::export::Ok(__Field::__field4),
                            "block" => _serde::export::Ok(__Field::__field5),
                            "end_token" => _serde::export::Ok(__Field::__field6),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"for_token" => _serde::export::Ok(__Field::__field0),
                            b"names" => _serde::export::Ok(__Field::__field1),
                            b"in_token" => _serde::export::Ok(__Field::__field2),
                            b"expr_list" => _serde::export::Ok(__Field::__field3),
                            b"do_token" => _serde::export::Ok(__Field::__field4),
                            b"block" => _serde::export::Ok(__Field::__field5),
                            b"end_token" => _serde::export::Ok(__Field::__field6),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<GenericFor<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = GenericFor<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct GenericFor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Expression<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        let __field5 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct GenericFor with 7 elements",
                                    ));
                                }
                            };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct GenericFor with 7 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(GenericFor {
                            for_token: __field0,
                            names: __field1,
                            in_token: __field2,
                            expr_list: __field3,
                            do_token: __field4,
                            block: __field5,
                            end_token: __field6,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Punctuated<TokenReference>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Punctuated<Expression<P>>> =
                            _serde::export::None;
                        let mut __field4: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field5: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field6: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "for_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "names",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "in_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Expression<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "do_token",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::export::Option::is_some(&__field5) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::export::Option::is_some(&__field6) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("for_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("names") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("in_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("do_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::export::Some(__field5) => __field5,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::export::Some(__field6) => __field6,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(GenericFor {
                            for_token: __field0,
                            names: __field1,
                            in_token: __field2,
                            expr_list: __field3,
                            do_token: __field4,
                            block: __field5,
                            end_token: __field6,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "for_token",
                    "names",
                    "in_token",
                    "expr_list",
                    "do_token",
                    "block",
                    "end_token",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GenericFor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<GenericFor<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for GenericFor<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "GenericFor",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "for_token",
                    &self.for_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "names",
                    &self.names,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "in_token",
                    &self.in_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "do_token",
                    &self.do_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for GenericFor<P> {
        #[inline]
        fn clone(&self) -> GenericFor<P> {
            match *self {
                GenericFor {
                    for_token: ref __self_0_0,
                    names: ref __self_0_1,
                    in_token: ref __self_0_2,
                    expr_list: ref __self_0_3,
                    do_token: ref __self_0_4,
                    block: ref __self_0_5,
                    end_token: ref __self_0_6,
                } => GenericFor {
                    for_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    names: ::core::clone::Clone::clone(&(*__self_0_1)),
                    in_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    expr_list: ::core::clone::Clone::clone(&(*__self_0_3)),
                    do_token: ::core::clone::Clone::clone(&(*__self_0_4)),
                    block: ::core::clone::Clone::clone(&(*__self_0_5)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_6)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for GenericFor<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                GenericFor {
                    for_token: ref __self_0_0,
                    names: ref __self_0_1,
                    in_token: ref __self_0_2,
                    expr_list: ref __self_0_3,
                    do_token: ref __self_0_4,
                    block: ref __self_0_5,
                    end_token: ref __self_0_6,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "GenericFor");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "for_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "names",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "in_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expr_list",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "do_token",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_6),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for GenericFor<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for GenericFor<P> {
        #[inline]
        fn eq(&self, other: &GenericFor<P>) -> bool {
            match *other {
                GenericFor {
                    for_token: ref __self_1_0,
                    names: ref __self_1_1,
                    in_token: ref __self_1_2,
                    expr_list: ref __self_1_3,
                    do_token: ref __self_1_4,
                    block: ref __self_1_5,
                    end_token: ref __self_1_6,
                } => match *self {
                    GenericFor {
                        for_token: ref __self_0_0,
                        names: ref __self_0_1,
                        in_token: ref __self_0_2,
                        expr_list: ref __self_0_3,
                        do_token: ref __self_0_4,
                        block: ref __self_0_5,
                        end_token: ref __self_0_6,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GenericFor<P>) -> bool {
            match *other {
                GenericFor {
                    for_token: ref __self_1_0,
                    names: ref __self_1_1,
                    in_token: ref __self_1_2,
                    expr_list: ref __self_1_3,
                    do_token: ref __self_1_4,
                    block: ref __self_1_5,
                    end_token: ref __self_1_6,
                } => match *self {
                    GenericFor {
                        for_token: ref __self_0_0,
                        names: ref __self_0_1,
                        in_token: ref __self_0_2,
                        expr_list: ref __self_0_3,
                        do_token: ref __self_0_4,
                        block: ref __self_0_5,
                        end_token: ref __self_0_6,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for GenericFor<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.for_token.start_position())
                            .or_else(|| self.names.start_position())
                            .or_else(|| self.in_token.start_position())
                            .or_else(|| self.expr_list.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.expr_list.end_position())
                            .or_else(|| self.in_token.end_position())
                            .or_else(|| self.names.end_position())
                            .or_else(|| self.for_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.for_token.start_position())
                            .or_else(|| self.names.start_position())
                            .or_else(|| self.in_token.start_position())
                            .or_else(|| self.expr_list.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.expr_list.end_position())
                            .or_else(|| self.in_token.end_position())
                            .or_else(|| self.names.end_position())
                            .or_else(|| self.for_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.for_token.similar(&other.for_token)
                    && self.names.similar(&other.names)
                    && self.in_token.similar(&other.in_token)
                    && self.expr_list.similar(&other.expr_list)
                    && self.do_token.similar(&other.do_token)
                    && self.block.similar(&other.block)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.for_token),
                        crate::node::TokenItem::MoreTokens(&self.names),
                        crate::node::TokenItem::TokenReference(&self.in_token),
                        crate::node::TokenItem::MoreTokens(&self.expr_list),
                        crate::node::TokenItem::TokenReference(&self.do_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for GenericFor<P> {}
    impl<P: Plugin> GenericFor<P> {
        /// Creates a new GenericFor from the given names and expressions
        pub fn new(
            names: Punctuated<TokenReference>,
            expr_list: Punctuated<Expression<P>>,
        ) -> Self {
            Self {
                for_token: TokenReference::symbol("for ").unwrap(),
                names,
                in_token: TokenReference::symbol(" in ").unwrap(),
                expr_list,
                do_token: TokenReference::symbol(" do\n").unwrap(),
                block: Block::new(),
                end_token: TokenReference::symbol("\nend").unwrap(),
            }
        }
        /// The `for` token
        pub fn for_token(&self) -> &TokenReference {
            &self.for_token
        }
        /// Returns the punctuated sequence of names
        /// In `for index, value in pairs(list) do`, iterates over `index` and `value`
        pub fn names(&self) -> &Punctuated<TokenReference> {
            &self.names
        }
        /// The `in` token
        pub fn in_token(&self) -> &TokenReference {
            &self.in_token
        }
        /// Returns the punctuated sequence of the expressions looped over
        /// In `for index, value in pairs(list) do`, iterates over `pairs(list)`
        pub fn expressions(&self) -> &Punctuated<Expression<P>> {
            &self.expr_list
        }
        /// The `do` token
        pub fn do_token(&self) -> &TokenReference {
            &self.do_token
        }
        /// The code inside the for loop
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new GenericFor with the given `for` token
        pub fn with_for_token(self, for_token: TokenReference) -> Self {
            Self { for_token, ..self }
        }
        /// Returns a new GenericFor with the given names
        pub fn with_names(self, names: Punctuated<TokenReference>) -> Self {
            Self { names, ..self }
        }
        /// Returns a new GenericFor with the given `in` token
        pub fn with_in_token(self, in_token: TokenReference) -> Self {
            Self { in_token, ..self }
        }
        /// Returns a new GenericFor with the given expression list
        pub fn with_expressions(self, expr_list: Punctuated<Expression>) -> Self {
            Self { expr_list, ..self }
        }
        /// Returns a new GenericFor with the given `do` token
        pub fn with_do_token(self, do_token: TokenReference) -> Self {
            Self { do_token, ..self }
        }
        /// Returns a new GenericFor with the given block
        pub fn with_block(self, block: Block) -> Self {
            Self { block, ..self }
        }
        /// Returns a new GenericFor with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    impl fmt::Display for GenericFor {
        #[cfg(not(feature = "roblox"))]
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["not implemented: "],
                &match (&::core::fmt::Arguments::new_v1(
                    &["PLUGIN TODO: GenericFor display"],
                    &match () {
                        () => [],
                    },
                ),)
                {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    /// An if statement
    #[display(
        fmt = "{}{}{}{}{}{}{}{}",
        "if_token",
        "condition",
        "then_token",
        "block",
        "display_option(else_if.as_ref().map(join_vec))",
        "display_option(else_token)",
        "display_option(r#else)",
        "end_token"
    )]
    pub struct If<P: Plugin = DefaultPlugin> {
        if_token: TokenReference,
        condition: Expression<P>,
        then_token: TokenReference,
        block: Block<P>,
        else_if: Option<Vec<ElseIf<P>>>,
        else_token: Option<TokenReference>,
        #[serde(rename = "else")]
        r#else: Option<Block<P>>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for If<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 8",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "if_token" => _serde::export::Ok(__Field::__field0),
                            "condition" => _serde::export::Ok(__Field::__field1),
                            "then_token" => _serde::export::Ok(__Field::__field2),
                            "block" => _serde::export::Ok(__Field::__field3),
                            "else_if" => _serde::export::Ok(__Field::__field4),
                            "else_token" => _serde::export::Ok(__Field::__field5),
                            "else" => _serde::export::Ok(__Field::__field6),
                            "end_token" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"if_token" => _serde::export::Ok(__Field::__field0),
                            b"condition" => _serde::export::Ok(__Field::__field1),
                            b"then_token" => _serde::export::Ok(__Field::__field2),
                            b"block" => _serde::export::Ok(__Field::__field3),
                            b"else_if" => _serde::export::Ok(__Field::__field4),
                            b"else_token" => _serde::export::Ok(__Field::__field5),
                            b"else" => _serde::export::Ok(__Field::__field6),
                            b"end_token" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<If<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = If<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct If")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct If with 8 elements",
                                    ));
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Option<Vec<ElseIf<P>>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Option<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            Option<Block<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct If with 8 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(If {
                            if_token: __field0,
                            condition: __field1,
                            then_token: __field2,
                            block: __field3,
                            else_if: __field4,
                            else_token: __field5,
                            r#else: __field6,
                            end_token: __field7,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field4: _serde::export::Option<Option<Vec<ElseIf<P>>>> =
                            _serde::export::None;
                        let mut __field5: _serde::export::Option<Option<TokenReference>> =
                            _serde::export::None;
                        let mut __field6: _serde::export::Option<Option<Block<P>>> =
                            _serde::export::None;
                        let mut __field7: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "if_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "then_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else_if",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Vec<ElseIf<P>>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::export::Option::is_some(&__field5) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else_token",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::export::Option::is_some(&__field6) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<Block<P>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::export::Option::is_some(&__field7) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("if_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("condition") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("then_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else_if") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::export::Some(__field5) => __field5,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::export::Some(__field6) => __field6,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::export::Some(__field7) => __field7,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(If {
                            if_token: __field0,
                            condition: __field1,
                            then_token: __field2,
                            block: __field3,
                            else_if: __field4,
                            else_token: __field5,
                            r#else: __field6,
                            end_token: __field7,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "if_token",
                    "condition",
                    "then_token",
                    "block",
                    "else_if",
                    "else_token",
                    "else",
                    "end_token",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "If",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<If<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for If<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "If",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "if_token",
                    &self.if_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition",
                    &self.condition,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "then_token",
                    &self.then_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else_if",
                    &self.else_if,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else_token",
                    &self.else_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else",
                    &self.r#else,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for If<P> {
        #[inline]
        fn clone(&self) -> If<P> {
            match *self {
                If {
                    if_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    then_token: ref __self_0_2,
                    block: ref __self_0_3,
                    else_if: ref __self_0_4,
                    else_token: ref __self_0_5,
                    r#else: ref __self_0_6,
                    end_token: ref __self_0_7,
                } => If {
                    if_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    condition: ::core::clone::Clone::clone(&(*__self_0_1)),
                    then_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    block: ::core::clone::Clone::clone(&(*__self_0_3)),
                    else_if: ::core::clone::Clone::clone(&(*__self_0_4)),
                    else_token: ::core::clone::Clone::clone(&(*__self_0_5)),
                    r#else: ::core::clone::Clone::clone(&(*__self_0_6)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_7)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for If<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                If {
                    if_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    then_token: ref __self_0_2,
                    block: ref __self_0_3,
                    else_if: ref __self_0_4,
                    else_token: ref __self_0_5,
                    r#else: ref __self_0_6,
                    end_token: ref __self_0_7,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "If");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "if_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "condition",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "then_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "else_if",
                        &&(*__self_0_4),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "else_token",
                        &&(*__self_0_5),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "else",
                        &&(*__self_0_6),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_7),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for If<P>
    where
        Expression<P>: ::core::fmt::Display,
        Block<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                If {
                    if_token,
                    condition,
                    then_token,
                    block,
                    else_if,
                    else_token,
                    r#else,
                    end_token,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", "", "", "", "", ""],
                    &match (
                        &if_token,
                        &condition,
                        &then_token,
                        &block,
                        &display_option(else_if.as_ref().map(join_vec)),
                        &display_option(else_token),
                        &display_option(r#else),
                        &end_token,
                    ) {
                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg5, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg6, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg7, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for If<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for If<P> {
        #[inline]
        fn eq(&self, other: &If<P>) -> bool {
            match *other {
                If {
                    if_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    then_token: ref __self_1_2,
                    block: ref __self_1_3,
                    else_if: ref __self_1_4,
                    else_token: ref __self_1_5,
                    r#else: ref __self_1_6,
                    end_token: ref __self_1_7,
                } => match *self {
                    If {
                        if_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        then_token: ref __self_0_2,
                        block: ref __self_0_3,
                        else_if: ref __self_0_4,
                        else_token: ref __self_0_5,
                        r#else: ref __self_0_6,
                        end_token: ref __self_0_7,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                            && (*__self_0_5) == (*__self_1_5)
                            && (*__self_0_6) == (*__self_1_6)
                            && (*__self_0_7) == (*__self_1_7)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &If<P>) -> bool {
            match *other {
                If {
                    if_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    then_token: ref __self_1_2,
                    block: ref __self_1_3,
                    else_if: ref __self_1_4,
                    else_token: ref __self_1_5,
                    r#else: ref __self_1_6,
                    end_token: ref __self_1_7,
                } => match *self {
                    If {
                        if_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        then_token: ref __self_0_2,
                        block: ref __self_0_3,
                        else_if: ref __self_0_4,
                        else_token: ref __self_0_5,
                        r#else: ref __self_0_6,
                        end_token: ref __self_0_7,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                            || (*__self_0_5) != (*__self_1_5)
                            || (*__self_0_6) != (*__self_1_6)
                            || (*__self_0_7) != (*__self_1_7)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for If<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.if_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.then_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.else_if.start_position())
                            .or_else(|| self.else_token.start_position())
                            .or_else(|| self.r#else.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.r#else.end_position())
                            .or_else(|| self.else_token.end_position())
                            .or_else(|| self.else_if.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.then_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.if_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.if_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.then_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.else_if.start_position())
                            .or_else(|| self.else_token.start_position())
                            .or_else(|| self.r#else.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.r#else.end_position())
                            .or_else(|| self.else_token.end_position())
                            .or_else(|| self.else_if.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.then_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.if_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.if_token.similar(&other.if_token)
                    && self.condition.similar(&other.condition)
                    && self.then_token.similar(&other.then_token)
                    && self.block.similar(&other.block)
                    && self.else_if.similar(&other.else_if)
                    && self.else_token.similar(&other.else_token)
                    && self.r#else.similar(&other.r#else)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.if_token),
                        crate::node::TokenItem::MoreTokens(&self.condition),
                        crate::node::TokenItem::TokenReference(&self.then_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::MoreTokens(&self.else_if),
                        crate::node::TokenItem::MoreTokens(&self.else_token),
                        crate::node::TokenItem::MoreTokens(&self.r#else),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for If<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for If<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_if(self);
            self.if_token.visit(visitor);
            self.condition.visit(visitor);
            self.then_token.visit(visitor);
            self.block.visit(visitor);
            self.else_if.visit(visitor);
            self.else_token.visit(visitor);
            self.r#else.visit(visitor);
            self.end_token.visit(visitor);
            visitor.visit_if_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for If<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_if(self);
            self.if_token = self.if_token.visit_mut(visitor);
            self.condition = self.condition.visit_mut(visitor);
            self.then_token = self.then_token.visit_mut(visitor);
            self.block = self.block.visit_mut(visitor);
            self.else_if = self.else_if.visit_mut(visitor);
            self.else_token = self.else_token.visit_mut(visitor);
            self.r#else = self.r#else.visit_mut(visitor);
            self.end_token = self.end_token.visit_mut(visitor);
            self = visitor.visit_if_end(self);
            self
        }
    }
    impl<P: Plugin> If<P> {
        /// Creates a new If from the given condition
        pub fn new(condition: Expression<P>) -> Self {
            Self {
                if_token: TokenReference::symbol("if ").unwrap(),
                condition,
                then_token: TokenReference::symbol(" then").unwrap(),
                block: Block::new(),
                else_if: None,
                else_token: None,
                r#else: None,
                end_token: TokenReference::symbol("\nend").unwrap(),
            }
        }
        /// The `if` token
        pub fn if_token(&self) -> &TokenReference {
            &self.if_token
        }
        /// The condition of the if statement, `condition` in `if condition then`
        pub fn condition(&self) -> &Expression<P> {
            &self.condition
        }
        /// The `then` token
        pub fn then_token(&self) -> &TokenReference {
            &self.then_token
        }
        /// The block inside the initial if statement
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `else` token if one exists
        pub fn else_token(&self) -> Option<&TokenReference> {
            self.else_token.as_ref()
        }
        /// If there are `elseif` conditions, returns a vector of them
        /// Expression is the condition, block is the code if the condition is true
        pub fn else_if(&self) -> Option<&Vec<ElseIf<P>>> {
            self.else_if.as_ref()
        }
        /// The code inside an `else` block if one exists
        pub fn else_block(&self) -> Option<&Block<P>> {
            self.r#else.as_ref()
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new If with the given `if` token
        pub fn with_if_token(self, if_token: TokenReference) -> Self {
            Self { if_token, ..self }
        }
        /// Returns a new If with the given condition
        pub fn with_condition(self, condition: Expression<P>) -> Self {
            Self { condition, ..self }
        }
        /// Returns a new If with the given `then` token
        pub fn with_then_token(self, then_token: TokenReference) -> Self {
            Self { then_token, ..self }
        }
        /// Returns a new If with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
        /// Returns a new If with the given list of `elseif` blocks
        pub fn with_else_if(self, else_if: Option<Vec<ElseIf<P>>>) -> Self {
            Self { else_if, ..self }
        }
        /// Returns a new If with the given `else` token
        pub fn with_else_token(self, else_token: Option<TokenReference>) -> Self {
            Self { else_token, ..self }
        }
        /// Returns a new If with the given `else` body
        pub fn with_else(self, r#else: Option<Block<P>>) -> Self {
            Self { r#else, ..self }
        }
        /// Returns a new If with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    /// An elseif block in a bigger [`If`] statement
    #[display(fmt = "{}{}{}{}", "else_if_token", "condition", "then_token", "block")]
    pub struct ElseIf<P: Plugin = DefaultPlugin> {
        else_if_token: TokenReference,
        condition: Expression<P>,
        then_token: TokenReference,
        block: Block<P>,
        plugin_info: <<P as Plugin>::ElseIfMod as PluginMod<ElseIf<P>>>::NodeInfo,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for ElseIf<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "else_if_token" => _serde::export::Ok(__Field::__field0),
                            "condition" => _serde::export::Ok(__Field::__field1),
                            "then_token" => _serde::export::Ok(__Field::__field2),
                            "block" => _serde::export::Ok(__Field::__field3),
                            "plugin_info" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"else_if_token" => _serde::export::Ok(__Field::__field0),
                            b"condition" => _serde::export::Ok(__Field::__field1),
                            b"then_token" => _serde::export::Ok(__Field::__field2),
                            b"block" => _serde::export::Ok(__Field::__field3),
                            b"plugin_info" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<ElseIf<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = ElseIf<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct ElseIf")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ElseIf with 5 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ElseIf with 5 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct ElseIf with 5 elements",
                                ));
                            }
                        };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct ElseIf with 5 elements",
                                    ));
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            <<P as Plugin>::ElseIfMod as PluginMod<ElseIf<P>>>::NodeInfo,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct ElseIf with 5 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(ElseIf {
                            else_if_token: __field0,
                            condition: __field1,
                            then_token: __field2,
                            block: __field3,
                            plugin_info: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field4: _serde::export::Option<
                            <<P as Plugin>::ElseIfMod as PluginMod<ElseIf<P>>>::NodeInfo,
                        > = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else_if_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "then_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "plugin_info",
                                            ),
                                        );
                                    }
                                    __field4 =
                                        _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                <<P as Plugin>::ElseIfMod as PluginMod<
                                                    ElseIf<P>,
                                                >>::NodeInfo,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else_if_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("condition") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("then_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("plugin_info") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(ElseIf {
                            else_if_token: __field0,
                            condition: __field1,
                            then_token: __field2,
                            block: __field3,
                            plugin_info: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "else_if_token",
                    "condition",
                    "then_token",
                    "block",
                    "plugin_info",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ElseIf",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<ElseIf<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for ElseIf<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "ElseIf",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else_if_token",
                    &self.else_if_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition",
                    &self.condition,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "then_token",
                    &self.then_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "plugin_info",
                    &self.plugin_info,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for ElseIf<P> {
        #[inline]
        fn clone(&self) -> ElseIf<P> {
            match *self {
                ElseIf {
                    else_if_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    then_token: ref __self_0_2,
                    block: ref __self_0_3,
                    plugin_info: ref __self_0_4,
                } => ElseIf {
                    else_if_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    condition: ::core::clone::Clone::clone(&(*__self_0_1)),
                    then_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    block: ::core::clone::Clone::clone(&(*__self_0_3)),
                    plugin_info: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for ElseIf<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ElseIf {
                    else_if_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    then_token: ref __self_0_2,
                    block: ref __self_0_3,
                    plugin_info: ref __self_0_4,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "ElseIf");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "else_if_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "condition",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "then_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "plugin_info",
                        &&(*__self_0_4),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for ElseIf<P>
    where
        Expression<P>: ::core::fmt::Display,
        Block<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                ElseIf {
                    else_if_token,
                    condition,
                    then_token,
                    block,
                    plugin_info,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", ""],
                    &match (&else_if_token, &condition, &then_token, &block) {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for ElseIf<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for ElseIf<P> {
        #[inline]
        fn eq(&self, other: &ElseIf<P>) -> bool {
            match *other {
                ElseIf {
                    else_if_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    then_token: ref __self_1_2,
                    block: ref __self_1_3,
                    plugin_info: ref __self_1_4,
                } => match *self {
                    ElseIf {
                        else_if_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        then_token: ref __self_0_2,
                        block: ref __self_0_3,
                        plugin_info: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ElseIf<P>) -> bool {
            match *other {
                ElseIf {
                    else_if_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    then_token: ref __self_1_2,
                    block: ref __self_1_3,
                    plugin_info: ref __self_1_4,
                } => match *self {
                    ElseIf {
                        else_if_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        then_token: ref __self_0_2,
                        block: ref __self_0_3,
                        plugin_info: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for ElseIf<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.else_if_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.then_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.then_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.else_if_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.else_if_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.then_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.plugin_info.start_position())?,
                        None.or_else(|| self.plugin_info.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.then_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.else_if_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.else_if_token.similar(&other.else_if_token)
                    && self.condition.similar(&other.condition)
                    && self.then_token.similar(&other.then_token)
                    && self.block.similar(&other.block)
                    && self.plugin_info.similar(&other.plugin_info)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.else_if_token),
                        crate::node::TokenItem::MoreTokens(&self.condition),
                        crate::node::TokenItem::TokenReference(&self.then_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::MoreTokens(&self.plugin_info),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for ElseIf<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for ElseIf<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_else_if(self);
            self.else_if_token.visit(visitor);
            self.condition.visit(visitor);
            self.then_token.visit(visitor);
            self.block.visit(visitor);
            visitor.visit_else_if_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for ElseIf<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_else_if(self);
            self.else_if_token = self.else_if_token.visit_mut(visitor);
            self.condition = self.condition.visit_mut(visitor);
            self.then_token = self.then_token.visit_mut(visitor);
            self.block = self.block.visit_mut(visitor);
            self = visitor.visit_else_if_end(self);
            self
        }
    }
    impl<P: Plugin> ElseIf<P> {
        /// Creates a new ElseIf from the given condition
        pub fn new(condition: Expression<P>) -> Self {
            Self {
                else_if_token: TokenReference::symbol("elseif ").unwrap(),
                condition,
                then_token: TokenReference::symbol(" then\n").unwrap(),
                block: Block::new(),
                plugin_info: <<P as Plugin>::ElseIfMod as PluginMod<ElseIf<P>>>::NodeInfo::default(
                ),
            }
        }
        /// The `elseif` token
        pub fn else_if_token(&self) -> &TokenReference {
            &self.else_if_token
        }
        /// The condition of the `elseif`, `condition` in `elseif condition then`
        pub fn condition(&self) -> &Expression<P> {
            &self.condition
        }
        /// The `then` token
        pub fn then_token(&self) -> &TokenReference {
            &self.then_token
        }
        /// The body of the `elseif`
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// Returns a new ElseIf with the given `elseif` token
        pub fn with_else_if_token(self, else_if_token: TokenReference) -> Self {
            Self {
                else_if_token,
                ..self
            }
        }
        /// Returns a new ElseIf with the given condition
        pub fn with_condition(self, condition: Expression<P>) -> Self {
            Self { condition, ..self }
        }
        /// Returns a new ElseIf with the given `then` token
        pub fn with_then_token(self, then_token: TokenReference) -> Self {
            Self { then_token, ..self }
        }
        /// Returns a new ElseIf with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
    }
    /// A while loop
    #[display(
        fmt = "{}{}{}{}{}",
        "while_token",
        "condition",
        "do_token",
        "block",
        "end_token"
    )]
    pub struct While<P: Plugin = DefaultPlugin> {
        while_token: TokenReference,
        condition: Expression<P>,
        do_token: TokenReference,
        block: Block<P>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for While<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "while_token" => _serde::export::Ok(__Field::__field0),
                            "condition" => _serde::export::Ok(__Field::__field1),
                            "do_token" => _serde::export::Ok(__Field::__field2),
                            "block" => _serde::export::Ok(__Field::__field3),
                            "end_token" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"while_token" => _serde::export::Ok(__Field::__field0),
                            b"condition" => _serde::export::Ok(__Field::__field1),
                            b"do_token" => _serde::export::Ok(__Field::__field2),
                            b"block" => _serde::export::Ok(__Field::__field3),
                            b"end_token" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<While<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = While<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct While")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct While with 5 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct While with 5 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct While with 5 elements",
                                ));
                            }
                        };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct While with 5 elements",
                                    ));
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct While with 5 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(While {
                            while_token: __field0,
                            condition: __field1,
                            do_token: __field2,
                            block: __field3,
                            end_token: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field4: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "while_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "do_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("while_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("condition") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("do_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(While {
                            while_token: __field0,
                            condition: __field1,
                            do_token: __field2,
                            block: __field3,
                            end_token: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["while_token", "condition", "do_token", "block", "end_token"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "While",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<While<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for While<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "While",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "while_token",
                    &self.while_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition",
                    &self.condition,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "do_token",
                    &self.do_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for While<P> {
        #[inline]
        fn clone(&self) -> While<P> {
            match *self {
                While {
                    while_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    do_token: ref __self_0_2,
                    block: ref __self_0_3,
                    end_token: ref __self_0_4,
                } => While {
                    while_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    condition: ::core::clone::Clone::clone(&(*__self_0_1)),
                    do_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    block: ::core::clone::Clone::clone(&(*__self_0_3)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for While<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                While {
                    while_token: ref __self_0_0,
                    condition: ref __self_0_1,
                    do_token: ref __self_0_2,
                    block: ref __self_0_3,
                    end_token: ref __self_0_4,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "While");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "while_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "condition",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "do_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_4),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for While<P>
    where
        Expression<P>: ::core::fmt::Display,
        Block<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                While {
                    while_token,
                    condition,
                    do_token,
                    block,
                    end_token,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", "", ""],
                    &match (&while_token, &condition, &do_token, &block, &end_token) {
                        (arg0, arg1, arg2, arg3, arg4) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for While<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for While<P> {
        #[inline]
        fn eq(&self, other: &While<P>) -> bool {
            match *other {
                While {
                    while_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    do_token: ref __self_1_2,
                    block: ref __self_1_3,
                    end_token: ref __self_1_4,
                } => match *self {
                    While {
                        while_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        do_token: ref __self_0_2,
                        block: ref __self_0_3,
                        end_token: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &While<P>) -> bool {
            match *other {
                While {
                    while_token: ref __self_1_0,
                    condition: ref __self_1_1,
                    do_token: ref __self_1_2,
                    block: ref __self_1_3,
                    end_token: ref __self_1_4,
                } => match *self {
                    While {
                        while_token: ref __self_0_0,
                        condition: ref __self_0_1,
                        do_token: ref __self_0_2,
                        block: ref __self_0_3,
                        end_token: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for While<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.while_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.while_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.while_token.start_position())
                            .or_else(|| self.condition.start_position())
                            .or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())
                            .or_else(|| self.condition.end_position())
                            .or_else(|| self.while_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.while_token.similar(&other.while_token)
                    && self.condition.similar(&other.condition)
                    && self.do_token.similar(&other.do_token)
                    && self.block.similar(&other.block)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.while_token),
                        crate::node::TokenItem::MoreTokens(&self.condition),
                        crate::node::TokenItem::TokenReference(&self.do_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for While<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for While<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_while(self);
            self.while_token.visit(visitor);
            self.condition.visit(visitor);
            self.do_token.visit(visitor);
            self.block.visit(visitor);
            self.end_token.visit(visitor);
            visitor.visit_while_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for While<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_while(self);
            self.while_token = self.while_token.visit_mut(visitor);
            self.condition = self.condition.visit_mut(visitor);
            self.do_token = self.do_token.visit_mut(visitor);
            self.block = self.block.visit_mut(visitor);
            self.end_token = self.end_token.visit_mut(visitor);
            self = visitor.visit_while_end(self);
            self
        }
    }
    impl<P: Plugin> While<P> {
        /// Creates a new While from the given condition
        pub fn new(condition: Expression<P>) -> Self {
            Self {
                while_token: TokenReference::symbol("while ").unwrap(),
                condition,
                do_token: TokenReference::symbol(" do\n").unwrap(),
                block: Block::new(),
                end_token: TokenReference::symbol("end\n").unwrap(),
            }
        }
        /// The `while` token
        pub fn while_token(&self) -> &TokenReference {
            &self.while_token
        }
        /// The `condition` part of `while condition do`
        pub fn condition(&self) -> &Expression<P> {
            &self.condition
        }
        /// The `do` token
        pub fn do_token(&self) -> &TokenReference {
            &self.do_token
        }
        /// The code inside the while loop
        pub fn block(&self) -> &Block {
            &self.block
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new While with the given `while` token
        pub fn with_while_token(self, while_token: TokenReference) -> Self {
            Self {
                while_token,
                ..self
            }
        }
        /// Returns a new While with the given condition
        pub fn with_condition(self, condition: Expression<P>) -> Self {
            Self { condition, ..self }
        }
        /// Returns a new While with the given `do` token
        pub fn with_do_token(self, do_token: TokenReference) -> Self {
            Self { do_token, ..self }
        }
        /// Returns a new While with the given block
        pub fn with_block(self, block: Block) -> Self {
            Self { block, ..self }
        }
        /// Returns a new While with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    /// A repeat loop
    #[display(fmt = "{}{}{}{}", "repeat_token", "block", "until_token", "until")]
    pub struct Repeat<P: Plugin = DefaultPlugin> {
        repeat_token: TokenReference,
        block: Block<P>,
        until_token: TokenReference,
        until: Expression<P>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Repeat<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "repeat_token" => _serde::export::Ok(__Field::__field0),
                            "block" => _serde::export::Ok(__Field::__field1),
                            "until_token" => _serde::export::Ok(__Field::__field2),
                            "until" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"repeat_token" => _serde::export::Ok(__Field::__field0),
                            b"block" => _serde::export::Ok(__Field::__field1),
                            b"until_token" => _serde::export::Ok(__Field::__field2),
                            b"until" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Repeat<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Repeat<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Repeat")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Repeat with 4 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Repeat with 4 elements",
                                    ));
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Repeat with 4 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Expression<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct Repeat with 4 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Repeat {
                            repeat_token: __field0,
                            block: __field1,
                            until_token: __field2,
                            until: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Expression<P>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "repeat_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "until_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "until",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("repeat_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("until_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("until") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Repeat {
                            repeat_token: __field0,
                            block: __field1,
                            until_token: __field2,
                            until: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["repeat_token", "block", "until_token", "until"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Repeat",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Repeat<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Repeat<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Repeat",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "repeat_token",
                    &self.repeat_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "until_token",
                    &self.until_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "until",
                    &self.until,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Repeat<P> {
        #[inline]
        fn clone(&self) -> Repeat<P> {
            match *self {
                Repeat {
                    repeat_token: ref __self_0_0,
                    block: ref __self_0_1,
                    until_token: ref __self_0_2,
                    until: ref __self_0_3,
                } => Repeat {
                    repeat_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    block: ::core::clone::Clone::clone(&(*__self_0_1)),
                    until_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    until: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Repeat<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Repeat {
                    repeat_token: ref __self_0_0,
                    block: ref __self_0_1,
                    until_token: ref __self_0_2,
                    until: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Repeat");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "repeat_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "until_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "until",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Repeat<P>
    where
        Expression<P>: ::core::fmt::Display,
        Block<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Repeat {
                    repeat_token,
                    block,
                    until_token,
                    until,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", ""],
                    &match (&repeat_token, &block, &until_token, &until) {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Repeat<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Repeat<P> {
        #[inline]
        fn eq(&self, other: &Repeat<P>) -> bool {
            match *other {
                Repeat {
                    repeat_token: ref __self_1_0,
                    block: ref __self_1_1,
                    until_token: ref __self_1_2,
                    until: ref __self_1_3,
                } => match *self {
                    Repeat {
                        repeat_token: ref __self_0_0,
                        block: ref __self_0_1,
                        until_token: ref __self_0_2,
                        until: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Repeat<P>) -> bool {
            match *other {
                Repeat {
                    repeat_token: ref __self_1_0,
                    block: ref __self_1_1,
                    until_token: ref __self_1_2,
                    until: ref __self_1_3,
                } => match *self {
                    Repeat {
                        repeat_token: ref __self_0_0,
                        block: ref __self_0_1,
                        until_token: ref __self_0_2,
                        until: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Repeat<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.repeat_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.until_token.start_position())
                            .or_else(|| self.until.start_position())?,
                        None.or_else(|| self.until.end_position())
                            .or_else(|| self.until_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.repeat_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.repeat_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.until_token.start_position())
                            .or_else(|| self.until.start_position())?,
                        None.or_else(|| self.until.end_position())
                            .or_else(|| self.until_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.repeat_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.repeat_token.similar(&other.repeat_token)
                    && self.block.similar(&other.block)
                    && self.until_token.similar(&other.until_token)
                    && self.until.similar(&other.until)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.repeat_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.until_token),
                        crate::node::TokenItem::MoreTokens(&self.until),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Repeat<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Repeat<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_repeat(self);
            self.repeat_token.visit(visitor);
            self.block.visit(visitor);
            self.until_token.visit(visitor);
            self.until.visit(visitor);
            visitor.visit_repeat_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Repeat<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_repeat(self);
            self.repeat_token = self.repeat_token.visit_mut(visitor);
            self.block = self.block.visit_mut(visitor);
            self.until_token = self.until_token.visit_mut(visitor);
            self.until = self.until.visit_mut(visitor);
            self = visitor.visit_repeat_end(self);
            self
        }
    }
    impl<P: Plugin> Repeat<P> {
        /// Creates a new Repeat from the given expression to repeat until
        pub fn new(until: Expression<P>) -> Self {
            Self {
                repeat_token: TokenReference::symbol("repeat\n").unwrap(),
                block: Block::new(),
                until_token: TokenReference::symbol("\nuntil ").unwrap(),
                until,
            }
        }
        /// The `repeat` token
        pub fn repeat_token(&self) -> &TokenReference {
            &self.repeat_token
        }
        /// The code inside the `repeat` block
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `until` token
        pub fn until_token(&self) -> &TokenReference {
            &self.until_token
        }
        /// The condition for the `until` part
        pub fn until(&self) -> &Expression<P> {
            &self.until
        }
        /// Returns a new Repeat with the given `repeat` token
        pub fn with_repeat_token(self, repeat_token: TokenReference) -> Self {
            Self {
                repeat_token,
                ..self
            }
        }
        /// Returns a new Repeat with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
        /// Returns a new Repeat with the given `until` token
        pub fn with_until_token(self, until_token: TokenReference) -> Self {
            Self {
                until_token,
                ..self
            }
        }
        /// Returns a new Repeat with the given `until` block
        pub fn with_until(self, until: Expression<P>) -> Self {
            Self { until, ..self }
        }
    }
    /// A method call, such as `x:y()`
    #[display(fmt = "{}{}{}", "colon_token", "name", "args")]
    pub struct MethodCall<P: Plugin = DefaultPlugin> {
        colon_token: TokenReference,
        name: TokenReference,
        args: FunctionArgs<P>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for MethodCall<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "colon_token" => _serde::export::Ok(__Field::__field0),
                            "name" => _serde::export::Ok(__Field::__field1),
                            "args" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"colon_token" => _serde::export::Ok(__Field::__field0),
                            b"name" => _serde::export::Ok(__Field::__field1),
                            b"args" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<MethodCall<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = MethodCall<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct MethodCall")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MethodCall with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MethodCall with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            FunctionArgs<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct MethodCall with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(MethodCall {
                            colon_token: __field0,
                            name: __field1,
                            args: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<FunctionArgs<P>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "colon_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "args",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionArgs<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("colon_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("args") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(MethodCall {
                            colon_token: __field0,
                            name: __field1,
                            args: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["colon_token", "name", "args"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MethodCall",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MethodCall<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for MethodCall<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MethodCall",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "colon_token",
                    &self.colon_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "args",
                    &self.args,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for MethodCall<P> {
        #[inline]
        fn clone(&self) -> MethodCall<P> {
            match *self {
                MethodCall {
                    colon_token: ref __self_0_0,
                    name: ref __self_0_1,
                    args: ref __self_0_2,
                } => MethodCall {
                    colon_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    args: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for MethodCall<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MethodCall {
                    colon_token: ref __self_0_0,
                    name: ref __self_0_1,
                    args: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "MethodCall");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "colon_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "args",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for MethodCall<P>
    where
        FunctionArgs<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                MethodCall {
                    colon_token,
                    name,
                    args,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&colon_token, &name, &args) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for MethodCall<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for MethodCall<P> {
        #[inline]
        fn eq(&self, other: &MethodCall<P>) -> bool {
            match *other {
                MethodCall {
                    colon_token: ref __self_1_0,
                    name: ref __self_1_1,
                    args: ref __self_1_2,
                } => match *self {
                    MethodCall {
                        colon_token: ref __self_0_0,
                        name: ref __self_0_1,
                        args: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MethodCall<P>) -> bool {
            match *other {
                MethodCall {
                    colon_token: ref __self_1_0,
                    name: ref __self_1_1,
                    args: ref __self_1_2,
                } => match *self {
                    MethodCall {
                        colon_token: ref __self_0_0,
                        name: ref __self_0_1,
                        args: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for MethodCall<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.colon_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.args.start_position())?,
                        None.or_else(|| self.args.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.colon_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.colon_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.args.start_position())?,
                        None.or_else(|| self.args.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.colon_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.colon_token.similar(&other.colon_token)
                    && self.name.similar(&other.name)
                    && self.args.similar(&other.args)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.colon_token),
                        crate::node::TokenItem::TokenReference(&self.name),
                        crate::node::TokenItem::MoreTokens(&self.args),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for MethodCall<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for MethodCall<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_method_call(self);
            self.colon_token.visit(visitor);
            self.name.visit(visitor);
            self.args.visit(visitor);
            visitor.visit_method_call_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for MethodCall<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_method_call(self);
            self.colon_token = self.colon_token.visit_mut(visitor);
            self.name = self.name.visit_mut(visitor);
            self.args = self.args.visit_mut(visitor);
            self = visitor.visit_method_call_end(self);
            self
        }
    }
    impl<P: Plugin> MethodCall<P> {
        /// Returns a new MethodCall from the given name and args
        pub fn new(name: TokenReference, args: FunctionArgs<P>) -> Self {
            Self {
                colon_token: TokenReference::symbol(":").unwrap(),
                name,
                args,
            }
        }
        /// The `:` in `x:y()`
        pub fn colon_token(&self) -> &TokenReference {
            &self.colon_token
        }
        /// The arguments of a method call, the `x, y, z` part of `method:call(x, y, z)`
        pub fn args(&self) -> &FunctionArgs<P> {
            &self.args
        }
        /// The method being called, the `call` part of `method:call()`
        pub fn name(&self) -> &TokenReference {
            &self.name
        }
        /// Returns a new MethodCall with the given `:` token
        pub fn with_colon_token(self, colon_token: TokenReference) -> Self {
            Self {
                colon_token,
                ..self
            }
        }
        /// Returns a new MethodCall with the given name
        pub fn with_name(self, name: TokenReference) -> Self {
            Self { name, ..self }
        }
        /// Returns a new MethodCall with the given args
        pub fn with_args(self, args: FunctionArgs<P>) -> Self {
            Self { args, ..self }
        }
    }
    /// Something being called
    #[non_exhaustive]
    pub enum Call<P: Plugin = DefaultPlugin> {
        #[display(fmt = "{}", "_0")]
        /// A function being called directly, such as `x(1)`
        AnonymousCall(FunctionArgs<P>),
        #[display(fmt = "{}", "_0")]
        /// A method call, such as `x:y()`
        MethodCall(MethodCall<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::CallMod as PluginMod<Call<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Call<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "AnonymousCall" => _serde::export::Ok(__Field::__field0),
                            "MethodCall" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"AnonymousCall" => _serde::export::Ok(__Field::__field0),
                            b"MethodCall" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Call<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Call<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Call")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionArgs<P>>(
                                    __variant,
                                ),
                                Call::AnonymousCall,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<MethodCall<P>>(
                                    __variant,
                                ),
                                Call::MethodCall,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::CallMod as PluginMod<Call<P>>>::NodeInfo,
                                >(__variant),
                                Call::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["AnonymousCall", "MethodCall", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Call",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Call<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Call<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Call::AnonymousCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Call",
                            0u32,
                            "AnonymousCall",
                            __field0,
                        )
                    }
                    Call::MethodCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Call",
                            1u32,
                            "MethodCall",
                            __field0,
                        )
                    }
                    Call::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Call",
                        2u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Call<P> {
        #[inline]
        fn clone(&self) -> Call<P> {
            match (&*self,) {
                (&Call::AnonymousCall(ref __self_0),) => {
                    Call::AnonymousCall(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Call::MethodCall(ref __self_0),) => {
                    Call::MethodCall(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Call::Plugin(ref __self_0),) => {
                    Call::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Call<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Call::AnonymousCall(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "AnonymousCall");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Call::MethodCall(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "MethodCall");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Call::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Call<P>
    where
        MethodCall<P>: ::core::fmt::Display,
        FunctionArgs<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Call::AnonymousCall(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Call::MethodCall(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Call::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Call<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Call<P> {
        #[inline]
        fn eq(&self, other: &Call<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Call::AnonymousCall(ref __self_0),
                            &Call::AnonymousCall(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Call::MethodCall(ref __self_0), &Call::MethodCall(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Call::Plugin(ref __self_0), &Call::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Call<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Call::AnonymousCall(ref __self_0),
                            &Call::AnonymousCall(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Call::MethodCall(ref __self_0), &Call::MethodCall(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Call::Plugin(ref __self_0), &Call::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Call<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Call::AnonymousCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Call::MethodCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Call::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Call::AnonymousCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Call::MethodCall(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Call::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Call::AnonymousCall(__self_0) => {
                        if let Call::AnonymousCall(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Call::MethodCall(__self_0) => {
                        if let Call::MethodCall(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Call::Plugin(__self_0) => {
                        if let Call::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Call::AnonymousCall(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Call::MethodCall(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Call::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Call<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Call<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_call(self);
            match self {
                Call::AnonymousCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Call::MethodCall(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_call_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Call<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_call(self);
            self = match self {
                Call::AnonymousCall(__self_0) => Call::AnonymousCall(__self_0.visit_mut(visitor)),
                Call::MethodCall(__self_0) => Call::MethodCall(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_call_end(self);
            self
        }
    }
    /// A function body, everything except `function x` in `function x(a, b, c) call() end`
    pub struct FunctionBody<P: Plugin = DefaultPlugin> {
        parameters_parentheses: ContainedSpan,
        parameters: Punctuated<Parameter<P>>,
        block: Block<P>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for FunctionBody<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parameters_parentheses" => _serde::export::Ok(__Field::__field0),
                            "parameters" => _serde::export::Ok(__Field::__field1),
                            "block" => _serde::export::Ok(__Field::__field2),
                            "end_token" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parameters_parentheses" => _serde::export::Ok(__Field::__field0),
                            b"parameters" => _serde::export::Ok(__Field::__field1),
                            b"block" => _serde::export::Ok(__Field::__field2),
                            b"end_token" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<FunctionBody<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = FunctionBody<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionBody")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            ContainedSpan,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionBody with 4 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Parameter<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionBody with 4 elements",
                                ));
                            }
                        };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct FunctionBody with 4 elements",
                                    ));
                                }
                            };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct FunctionBody with 4 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionBody {
                            parameters_parentheses: __field0,
                            parameters: __field1,
                            block: __field2,
                            end_token: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<ContainedSpan> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Punctuated<Parameter<P>>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field3: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parameters_parentheses",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<ContainedSpan>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parameters",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Parameter<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("parameters_parentheses") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("parameters") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionBody {
                            parameters_parentheses: __field0,
                            parameters: __field1,
                            block: __field2,
                            end_token: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["parameters_parentheses", "parameters", "block", "end_token"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionBody",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionBody<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for FunctionBody<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionBody",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parameters_parentheses",
                    &self.parameters_parentheses,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parameters",
                    &self.parameters,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for FunctionBody<P> {
        #[inline]
        fn clone(&self) -> FunctionBody<P> {
            match *self {
                FunctionBody {
                    parameters_parentheses: ref __self_0_0,
                    parameters: ref __self_0_1,
                    block: ref __self_0_2,
                    end_token: ref __self_0_3,
                } => FunctionBody {
                    parameters_parentheses: ::core::clone::Clone::clone(&(*__self_0_0)),
                    parameters: ::core::clone::Clone::clone(&(*__self_0_1)),
                    block: ::core::clone::Clone::clone(&(*__self_0_2)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for FunctionBody<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                FunctionBody {
                    parameters_parentheses: ref __self_0_0,
                    parameters: ref __self_0_1,
                    block: ref __self_0_2,
                    end_token: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "FunctionBody");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "parameters_parentheses",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "parameters",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for FunctionBody<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for FunctionBody<P> {
        #[inline]
        fn eq(&self, other: &FunctionBody<P>) -> bool {
            match *other {
                FunctionBody {
                    parameters_parentheses: ref __self_1_0,
                    parameters: ref __self_1_1,
                    block: ref __self_1_2,
                    end_token: ref __self_1_3,
                } => match *self {
                    FunctionBody {
                        parameters_parentheses: ref __self_0_0,
                        parameters: ref __self_0_1,
                        block: ref __self_0_2,
                        end_token: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionBody<P>) -> bool {
            match *other {
                FunctionBody {
                    parameters_parentheses: ref __self_1_0,
                    parameters: ref __self_1_1,
                    block: ref __self_1_2,
                    end_token: ref __self_1_3,
                } => match *self {
                    FunctionBody {
                        parameters_parentheses: ref __self_0_0,
                        parameters: ref __self_0_1,
                        block: ref __self_0_2,
                        end_token: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for FunctionBody<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.parameters_parentheses.start_position())
                            .or_else(|| self.parameters.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.parameters.end_position())
                            .or_else(|| self.parameters_parentheses.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.parameters_parentheses.start_position())
                            .or_else(|| self.parameters.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.parameters.end_position())
                            .or_else(|| self.parameters_parentheses.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.parameters_parentheses
                    .similar(&other.parameters_parentheses)
                    && self.parameters.similar(&other.parameters)
                    && self.block.similar(&other.block)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.parameters_parentheses),
                        crate::node::TokenItem::MoreTokens(&self.parameters),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for FunctionBody<P> {}
    impl<P: Plugin> FunctionBody<P> {
        /// Returns a new empty FunctionBody
        pub fn new() -> Self {
            Self {
                parameters_parentheses: ContainedSpan::new(
                    TokenReference::symbol("(").unwrap(),
                    TokenReference::symbol(")").unwrap(),
                ),
                parameters: Punctuated::new(),
                block: Block::new(),
                end_token: TokenReference::symbol("\nend").unwrap(),
            }
        }
        /// The parentheses of the parameters
        pub fn parameters_parentheses(&self) -> &ContainedSpan {
            &self.parameters_parentheses
        }
        /// Returns the [`Punctuated`] sequence of the parameters for the function declaration
        pub fn parameters(&self) -> &Punctuated<Parameter<P>> {
            &self.parameters
        }
        /// The code of a function body
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new FunctionBody with the given parentheses for the parameters
        pub fn with_parameters_parentheses(self, parameters_parentheses: ContainedSpan) -> Self {
            Self {
                parameters_parentheses,
                ..self
            }
        }
        /// Returns a new FunctionBody with the given parameters
        pub fn with_parameters(self, parameters: Punctuated<Parameter<P>>) -> Self {
            Self { parameters, ..self }
        }
        /// Returns a new FunctionBody with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
        /// Returns a new FunctionBody with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    impl Default for FunctionBody {
        fn default() -> Self {
            Self::new()
        }
    }
    impl fmt::Display for FunctionBody {
        #[cfg(not(feature = "roblox"))]
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["", "", "", "", ""],
                &match (
                    &self.parameters_parentheses.tokens().0,
                    &self.parameters,
                    &self.parameters_parentheses.tokens().1,
                    &self.block,
                    &self.end_token,
                ) {
                    (arg0, arg1, arg2, arg3, arg4) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                    ],
                },
            ))
        }
    }
    /// A parameter in a function declaration
    #[non_exhaustive]
    pub enum Parameter<P: Plugin = DefaultPlugin> {
        /// The `...` vararg syntax, such as `function x(...)`
        Ellipse(TokenReference),
        /// A name parameter, such as `function x(a, b, c)`
        Name(TokenReference),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::ParameterMod as PluginMod<Parameter<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Parameter<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Ellipse" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Ellipse" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Parameter<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Parameter<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Parameter")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde :: de :: EnumAccess :: variant (__data) { _serde :: export :: Ok (__val) => __val , _serde :: export :: Err (__err) => { return _serde :: export :: Err (__err) ; } } { (__Field :: __field0 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < TokenReference > (__variant) , Parameter :: Ellipse) , (__Field :: __field1 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < TokenReference > (__variant) , Parameter :: Name) , (__Field :: __field2 , __variant) => _serde :: export :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < < < P as Plugin > :: ParameterMod as PluginMod < Parameter < P > > > :: NodeInfo > (__variant) , Parameter :: Plugin) , }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Ellipse", "Name", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Parameter",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Parameter<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Parameter<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Parameter::Ellipse(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Parameter",
                            0u32,
                            "Ellipse",
                            __field0,
                        )
                    }
                    Parameter::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Parameter",
                        1u32,
                        "Name",
                        __field0,
                    ),
                    Parameter::Plugin(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Parameter",
                            2u32,
                            "Plugin",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Parameter<P> {
        #[inline]
        fn clone(&self) -> Parameter<P> {
            match (&*self,) {
                (&Parameter::Ellipse(ref __self_0),) => {
                    Parameter::Ellipse(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Parameter::Name(ref __self_0),) => {
                    Parameter::Name(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Parameter::Plugin(ref __self_0),) => {
                    Parameter::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Parameter<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Parameter::Ellipse(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Ellipse");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Parameter::Name(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Name");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Parameter::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Parameter<P> {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Parameter::Ellipse(_0) => {
                    ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                }
                Parameter::Name(_0) => {
                    ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                }
                Parameter::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Parameter<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Parameter<P> {
        #[inline]
        fn eq(&self, other: &Parameter<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Parameter::Ellipse(ref __self_0), &Parameter::Ellipse(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Parameter::Name(ref __self_0), &Parameter::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Parameter::Plugin(ref __self_0), &Parameter::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Parameter<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Parameter::Ellipse(ref __self_0), &Parameter::Ellipse(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Parameter::Name(ref __self_0), &Parameter::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Parameter::Plugin(ref __self_0), &Parameter::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Parameter<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Parameter::Ellipse(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Parameter::Name(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Parameter::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Parameter::Ellipse(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Parameter::Name(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Parameter::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Parameter::Ellipse(__self_0) => {
                        if let Parameter::Ellipse(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Parameter::Name(__self_0) => {
                        if let Parameter::Name(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Parameter::Plugin(__self_0) => {
                        if let Parameter::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Parameter::Ellipse(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Parameter::Name(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Parameter::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Parameter<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Parameter<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_parameter(self);
            match self {
                Parameter::Ellipse(__self_0) => {
                    __self_0.visit(visitor);
                }
                Parameter::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_parameter_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Parameter<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_parameter(self);
            self = match self {
                Parameter::Ellipse(__self_0) => Parameter::Ellipse(__self_0.visit_mut(visitor)),
                Parameter::Name(__self_0) => Parameter::Name(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_parameter_end(self);
            self
        }
    }
    /// A suffix in certain cases, such as `:y()` in `x:y()`
    /// Can be stacked on top of each other, such as in `x()()()`
    #[non_exhaustive]
    pub enum Suffix<P: Plugin = DefaultPlugin> {
        #[display(fmt = "{}", "_0")]
        /// A call, including method calls and direct calls
        Call(Call<P>),
        #[display(fmt = "{}", "_0")]
        /// An index, such as `x.y`
        Index(Index<P>),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::SuffixMod as PluginMod<Suffix<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Suffix<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Call" => _serde::export::Ok(__Field::__field0),
                            "Index" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Call" => _serde::export::Ok(__Field::__field0),
                            b"Index" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Suffix<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Suffix<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Suffix")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Call<P>>(__variant),
                                Suffix::Call,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Index<P>>(__variant),
                                Suffix::Index,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::SuffixMod as PluginMod<Suffix<P>>>::NodeInfo,
                                >(__variant),
                                Suffix::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Call", "Index", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Suffix",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Suffix<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Suffix<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Suffix::Call(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Suffix",
                        0u32,
                        "Call",
                        __field0,
                    ),
                    Suffix::Index(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Suffix",
                        1u32,
                        "Index",
                        __field0,
                    ),
                    Suffix::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Suffix",
                        2u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Suffix<P> {
        #[inline]
        fn clone(&self) -> Suffix<P> {
            match (&*self,) {
                (&Suffix::Call(ref __self_0),) => {
                    Suffix::Call(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Suffix::Index(ref __self_0),) => {
                    Suffix::Index(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Suffix::Plugin(ref __self_0),) => {
                    Suffix::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Suffix<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Suffix::Call(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Call");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Suffix::Index(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Index");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Suffix::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Suffix<P>
    where
        Call<P>: ::core::fmt::Display,
        Index<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Suffix::Call(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Suffix::Index(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Suffix::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Suffix<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Suffix<P> {
        #[inline]
        fn eq(&self, other: &Suffix<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Suffix::Call(ref __self_0), &Suffix::Call(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Suffix::Index(ref __self_0), &Suffix::Index(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Suffix::Plugin(ref __self_0), &Suffix::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Suffix<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Suffix::Call(ref __self_0), &Suffix::Call(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Suffix::Index(ref __self_0), &Suffix::Index(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Suffix::Plugin(ref __self_0), &Suffix::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Suffix<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Suffix::Call(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Suffix::Index(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Suffix::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Suffix::Call(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Suffix::Index(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Suffix::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Suffix::Call(__self_0) => {
                        if let Suffix::Call(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Suffix::Index(__self_0) => {
                        if let Suffix::Index(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Suffix::Plugin(__self_0) => {
                        if let Suffix::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Suffix::Call(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Suffix::Index(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Suffix::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Suffix<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Suffix<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_suffix(self);
            match self {
                Suffix::Call(__self_0) => {
                    __self_0.visit(visitor);
                }
                Suffix::Index(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_suffix_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Suffix<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_suffix(self);
            self = match self {
                Suffix::Call(__self_0) => Suffix::Call(__self_0.visit_mut(visitor)),
                Suffix::Index(__self_0) => Suffix::Index(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_suffix_end(self);
            self
        }
    }
    /// A complex expression used by [`Var`], consisting of both a prefix and suffixes
    #[display(fmt = "PLUGIN TODO: VarExpression display")]
    pub struct VarExpression<P: Plugin = DefaultPlugin> {
        prefix: Prefix<P>,
        suffixes: Vec<Suffix<P>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for VarExpression<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prefix" => _serde::export::Ok(__Field::__field0),
                            "suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prefix" => _serde::export::Ok(__Field::__field0),
                            b"suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<VarExpression<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = VarExpression<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct VarExpression")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Prefix<P>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct VarExpression with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Suffix<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct VarExpression with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(VarExpression {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Prefix<P>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Suffix<P>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prefix",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Prefix<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "suffixes",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Suffix<P>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("prefix") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("suffixes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(VarExpression {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["prefix", "suffixes"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "VarExpression",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<VarExpression<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for VarExpression<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "VarExpression",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prefix",
                    &self.prefix,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "suffixes",
                    &self.suffixes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for VarExpression<P> {
        #[inline]
        fn clone(&self) -> VarExpression<P> {
            match *self {
                VarExpression {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => VarExpression {
                    prefix: ::core::clone::Clone::clone(&(*__self_0_0)),
                    suffixes: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for VarExpression<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                VarExpression {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "VarExpression");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "prefix",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "suffixes",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for VarExpression<P> {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                VarExpression { prefix, suffixes } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO: VarExpression display"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for VarExpression<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for VarExpression<P> {
        #[inline]
        fn eq(&self, other: &VarExpression<P>) -> bool {
            match *other {
                VarExpression {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    VarExpression {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &VarExpression<P>) -> bool {
            match *other {
                VarExpression {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    VarExpression {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for VarExpression<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.prefix.start_position())
                            .or_else(|| self.suffixes.start_position())?,
                        None.or_else(|| self.suffixes.end_position())
                            .or_else(|| self.prefix.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.prefix.start_position())
                            .or_else(|| self.suffixes.start_position())?,
                        None.or_else(|| self.suffixes.end_position())
                            .or_else(|| self.prefix.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.prefix.similar(&other.prefix) && self.suffixes.similar(&other.suffixes) && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.prefix),
                        crate::node::TokenItem::MoreTokens(&self.suffixes),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for VarExpression<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for VarExpression<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_var_expression(self);
            self.prefix.visit(visitor);
            self.suffixes.visit(visitor);
            visitor.visit_var_expression_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for VarExpression<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_var_expression(self);
            self.prefix = self.prefix.visit_mut(visitor);
            self.suffixes = self.suffixes.visit_mut(visitor);
            self = visitor.visit_var_expression_end(self);
            self
        }
    }
    impl<P: Plugin> VarExpression<P> {
        /// Returns a new VarExpression from the given prefix
        pub fn new(prefix: Prefix<P>) -> Self {
            Self {
                prefix,
                suffixes: Vec::new(),
            }
        }
        /// The prefix of the expression, such as a name
        pub fn prefix(&self) -> &Prefix<P> {
            &self.prefix
        }
        /// An iter over the suffixes, such as indexing or calling
        pub fn suffixes(&self) -> impl Iterator<Item = &Suffix<P>> {
            self.suffixes.iter()
        }
        /// Returns a new VarExpression with the given prefix
        pub fn with_prefix(self, prefix: Prefix<P>) -> Self {
            Self { prefix, ..self }
        }
        /// Returns a new VarExpression with the given suffixes
        pub fn with_suffixes(self, suffixes: Vec<Suffix<P>>) -> Self {
            Self { suffixes, ..self }
        }
    }
    /// Used in [`Assignment`s](Assignment) and [`Value`s](Value)
    #[non_exhaustive]
    pub enum Var<P: Plugin = DefaultPlugin> {
        /// An expression, such as `x.y.z` or `x()`
        #[display(fmt = "{}", "_0")]
        Expression(VarExpression<P>),
        /// A literal identifier, such as `x`
        #[display(fmt = "{}", "_0")]
        Name(TokenReference),
        #[display(fmt = "PLUGIN TODO")]
        Plugin(<<P as Plugin>::VarMod as PluginMod<Var<P>>>::NodeInfo),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Var<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Expression" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            "Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Expression" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            b"Plugin" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Var<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Var<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Var")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<VarExpression<P>>(
                                    __variant,
                                ),
                                Var::Expression,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                Var::Name,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    <<P as Plugin>::VarMod as PluginMod<Var<P>>>::NodeInfo,
                                >(__variant),
                                Var::Plugin,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Expression", "Name", "Plugin"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Var",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Var<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Var<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Var::Expression(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Var",
                        0u32,
                        "Expression",
                        __field0,
                    ),
                    Var::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Var",
                        1u32,
                        "Name",
                        __field0,
                    ),
                    Var::Plugin(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Var",
                        2u32,
                        "Plugin",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Var<P> {
        #[inline]
        fn clone(&self) -> Var<P> {
            match (&*self,) {
                (&Var::Expression(ref __self_0),) => {
                    Var::Expression(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Var::Name(ref __self_0),) => Var::Name(::core::clone::Clone::clone(&(*__self_0))),
                (&Var::Plugin(ref __self_0),) => {
                    Var::Plugin(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Var<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Var::Expression(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Expression");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Var::Name(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Name");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Var::Plugin(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plugin");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Var<P>
    where
        VarExpression<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Var::Expression(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Var::Name(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_0,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Var::Plugin(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["PLUGIN TODO"],
                        &match () {
                            () => [],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Var<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Var<P> {
        #[inline]
        fn eq(&self, other: &Var<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Var::Expression(ref __self_0), &Var::Expression(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Var::Name(ref __self_0), &Var::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Var::Plugin(ref __self_0), &Var::Plugin(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Var<P>) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Var::Expression(ref __self_0), &Var::Expression(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Var::Name(ref __self_0), &Var::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Var::Plugin(ref __self_0), &Var::Plugin(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Var<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Var::Expression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Var::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Var::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        Var::Expression(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        Var::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        Var::Plugin(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    Var::Expression(__self_0) => {
                        if let Var::Expression(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Var::Name(__self_0) => {
                        if let Var::Name(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    Var::Plugin(__self_0) => {
                        if let Var::Plugin(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    Var::Expression(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                    Var::Name(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    Var::Plugin(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::MoreTokens(
                            &*__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Var<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Var<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_var(self);
            match self {
                Var::Expression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Var::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_var_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Var<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_var(self);
            self = match self {
                Var::Expression(__self_0) => Var::Expression(__self_0.visit_mut(visitor)),
                Var::Name(__self_0) => Var::Name(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_var_end(self);
            self
        }
    }
    /// An assignment, such as `x = y`. Not used for [`LocalAssignment`s](LocalAssignment)
    #[display(fmt = "{}{}{}", "var_list", "equal_token", "expr_list")]
    pub struct Assignment<P: Plugin = DefaultPlugin> {
        var_list: Punctuated<Var<P>>,
        equal_token: TokenReference,
        expr_list: Punctuated<Expression<P>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Assignment<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "var_list" => _serde::export::Ok(__Field::__field0),
                            "equal_token" => _serde::export::Ok(__Field::__field1),
                            "expr_list" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"var_list" => _serde::export::Ok(__Field::__field0),
                            b"equal_token" => _serde::export::Ok(__Field::__field1),
                            b"expr_list" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Assignment<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Assignment<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Assignment")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Var<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Assignment with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Assignment with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Expression<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Assignment with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Assignment {
                            var_list: __field0,
                            equal_token: __field1,
                            expr_list: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Punctuated<Var<P>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<Punctuated<Expression<P>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "var_list",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Punctuated<Var<P>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "equal_token",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Expression<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("var_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("equal_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Assignment {
                            var_list: __field0,
                            equal_token: __field1,
                            expr_list: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["var_list", "equal_token", "expr_list"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Assignment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Assignment<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Assignment<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Assignment",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "var_list",
                    &self.var_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "equal_token",
                    &self.equal_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Assignment<P> {
        #[inline]
        fn clone(&self) -> Assignment<P> {
            match *self {
                Assignment {
                    var_list: ref __self_0_0,
                    equal_token: ref __self_0_1,
                    expr_list: ref __self_0_2,
                } => Assignment {
                    var_list: ::core::clone::Clone::clone(&(*__self_0_0)),
                    equal_token: ::core::clone::Clone::clone(&(*__self_0_1)),
                    expr_list: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Assignment<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Assignment {
                    var_list: ref __self_0_0,
                    equal_token: ref __self_0_1,
                    expr_list: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Assignment");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "var_list",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "equal_token",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expr_list",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Assignment<P>
    where
        Punctuated<Expression<P>>: ::core::fmt::Display,
        Punctuated<Var<P>>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Assignment {
                    var_list,
                    equal_token,
                    expr_list,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&var_list, &equal_token, &expr_list) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Assignment<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Assignment<P> {
        #[inline]
        fn eq(&self, other: &Assignment<P>) -> bool {
            match *other {
                Assignment {
                    var_list: ref __self_1_0,
                    equal_token: ref __self_1_1,
                    expr_list: ref __self_1_2,
                } => match *self {
                    Assignment {
                        var_list: ref __self_0_0,
                        equal_token: ref __self_0_1,
                        expr_list: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Assignment<P>) -> bool {
            match *other {
                Assignment {
                    var_list: ref __self_1_0,
                    equal_token: ref __self_1_1,
                    expr_list: ref __self_1_2,
                } => match *self {
                    Assignment {
                        var_list: ref __self_0_0,
                        equal_token: ref __self_0_1,
                        expr_list: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Assignment<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.var_list.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.expr_list.start_position())?,
                        None.or_else(|| self.expr_list.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.var_list.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.var_list.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.expr_list.start_position())?,
                        None.or_else(|| self.expr_list.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.var_list.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.var_list.similar(&other.var_list)
                    && self.equal_token.similar(&other.equal_token)
                    && self.expr_list.similar(&other.expr_list)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.var_list),
                        crate::node::TokenItem::TokenReference(&self.equal_token),
                        crate::node::TokenItem::MoreTokens(&self.expr_list),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Assignment<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Assignment<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_assignment(self);
            self.var_list.visit(visitor);
            self.equal_token.visit(visitor);
            self.expr_list.visit(visitor);
            visitor.visit_assignment_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Assignment<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_assignment(self);
            self.var_list = self.var_list.visit_mut(visitor);
            self.equal_token = self.equal_token.visit_mut(visitor);
            self.expr_list = self.expr_list.visit_mut(visitor);
            self = visitor.visit_assignment_end(self);
            self
        }
    }
    impl<P: Plugin> Assignment<P> {
        /// Returns a new Assignment from the given variable and expression list
        pub fn new(var_list: Punctuated<Var<P>>, expr_list: Punctuated<Expression<P>>) -> Self {
            Self {
                var_list,
                equal_token: TokenReference::symbol(" = ").unwrap(),
                expr_list,
            }
        }
        /// Returns the punctuated sequence over the expressions being assigned.
        /// This is the the `1, 2` part of `x, y["a"] = 1, 2`
        pub fn expressions(&self) -> &Punctuated<Expression<P>> {
            &self.expr_list
        }
        /// The `=` token in between `x = y`
        pub fn equal_token(&self) -> &TokenReference {
            &self.equal_token
        }
        /// Returns the punctuated sequence over the variables being assigned to.
        /// This is the `x, y["a"]` part of `x, y["a"] = 1, 2`
        pub fn variables(&self) -> &Punctuated<Var<P>> {
            &self.var_list
        }
        /// Returns a new Assignment with the given variables
        pub fn with_variables(self, var_list: Punctuated<Var<P>>) -> Self {
            Self { var_list, ..self }
        }
        /// Returns a new Assignment with the given `=` token
        pub fn with_equal_token(self, equal_token: TokenReference) -> Self {
            Self {
                equal_token,
                ..self
            }
        }
        /// Returns a new Assignment with the given expressions
        pub fn with_expressions(self, expr_list: Punctuated<Expression<P>>) -> Self {
            Self { expr_list, ..self }
        }
    }
    /// A declaration of a local function, such as `local function x() end`
    #[display(fmt = "{}{}{}{}", "local_token", "function_token", "name", "body")]
    pub struct LocalFunction<P: Plugin = DefaultPlugin> {
        local_token: TokenReference,
        function_token: TokenReference,
        name: TokenReference,
        body: FunctionBody<P>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for LocalFunction<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "local_token" => _serde::export::Ok(__Field::__field0),
                            "function_token" => _serde::export::Ok(__Field::__field1),
                            "name" => _serde::export::Ok(__Field::__field2),
                            "body" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"local_token" => _serde::export::Ok(__Field::__field0),
                            b"function_token" => _serde::export::Ok(__Field::__field1),
                            b"name" => _serde::export::Ok(__Field::__field2),
                            b"body" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<LocalFunction<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = LocalFunction<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct LocalFunction")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LocalFunction with 4 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LocalFunction with 4 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct LocalFunction with 4 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            FunctionBody<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct LocalFunction with 4 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(LocalFunction {
                            local_token: __field0,
                            function_token: __field1,
                            name: __field2,
                            body: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<FunctionBody<P>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "local_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "function_token",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "body",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionBody<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("local_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("function_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("body") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(LocalFunction {
                            local_token: __field0,
                            function_token: __field1,
                            name: __field2,
                            body: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["local_token", "function_token", "name", "body"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LocalFunction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LocalFunction<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for LocalFunction<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "LocalFunction",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "local_token",
                    &self.local_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "function_token",
                    &self.function_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "body",
                    &self.body,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for LocalFunction<P> {
        #[inline]
        fn clone(&self) -> LocalFunction<P> {
            match *self {
                LocalFunction {
                    local_token: ref __self_0_0,
                    function_token: ref __self_0_1,
                    name: ref __self_0_2,
                    body: ref __self_0_3,
                } => LocalFunction {
                    local_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    function_token: ::core::clone::Clone::clone(&(*__self_0_1)),
                    name: ::core::clone::Clone::clone(&(*__self_0_2)),
                    body: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for LocalFunction<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                LocalFunction {
                    local_token: ref __self_0_0,
                    function_token: ref __self_0_1,
                    name: ref __self_0_2,
                    body: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "LocalFunction");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "local_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "function_token",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "body",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for LocalFunction<P>
    where
        FunctionBody<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                LocalFunction {
                    local_token,
                    function_token,
                    name,
                    body,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", "", ""],
                    &match (&local_token, &function_token, &name, &body) {
                        (arg0, arg1, arg2, arg3) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for LocalFunction<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for LocalFunction<P> {
        #[inline]
        fn eq(&self, other: &LocalFunction<P>) -> bool {
            match *other {
                LocalFunction {
                    local_token: ref __self_1_0,
                    function_token: ref __self_1_1,
                    name: ref __self_1_2,
                    body: ref __self_1_3,
                } => match *self {
                    LocalFunction {
                        local_token: ref __self_0_0,
                        function_token: ref __self_0_1,
                        name: ref __self_0_2,
                        body: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LocalFunction<P>) -> bool {
            match *other {
                LocalFunction {
                    local_token: ref __self_1_0,
                    function_token: ref __self_1_1,
                    name: ref __self_1_2,
                    body: ref __self_1_3,
                } => match *self {
                    LocalFunction {
                        local_token: ref __self_0_0,
                        function_token: ref __self_0_1,
                        name: ref __self_0_2,
                        body: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for LocalFunction<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.local_token.start_position())
                            .or_else(|| self.function_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.body.start_position())?,
                        None.or_else(|| self.body.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.function_token.end_position())
                            .or_else(|| self.local_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.local_token.start_position())
                            .or_else(|| self.function_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.body.start_position())?,
                        None.or_else(|| self.body.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.function_token.end_position())
                            .or_else(|| self.local_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.local_token.similar(&other.local_token)
                    && self.function_token.similar(&other.function_token)
                    && self.name.similar(&other.name)
                    && self.body.similar(&other.body)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.local_token),
                        crate::node::TokenItem::TokenReference(&self.function_token),
                        crate::node::TokenItem::TokenReference(&self.name),
                        crate::node::TokenItem::MoreTokens(&self.body),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for LocalFunction<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for LocalFunction<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_local_function(self);
            self.local_token.visit(visitor);
            self.function_token.visit(visitor);
            self.name.visit(visitor);
            self.body.visit(visitor);
            visitor.visit_local_function_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for LocalFunction<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_local_function(self);
            self.local_token = self.local_token.visit_mut(visitor);
            self.function_token = self.function_token.visit_mut(visitor);
            self.name = self.name.visit_mut(visitor);
            self.body = self.body.visit_mut(visitor);
            self = visitor.visit_local_function_end(self);
            self
        }
    }
    impl<P: Plugin> LocalFunction<P> {
        /// Returns a new LocalFunction from the given name
        pub fn new(name: TokenReference) -> Self {
            LocalFunction {
                local_token: TokenReference::symbol("local ").unwrap(),
                function_token: TokenReference::symbol("function ").unwrap(),
                name,
                body: FunctionBody::new(),
            }
        }
        /// The `local` token
        pub fn local_token(&self) -> &TokenReference {
            &self.local_token
        }
        /// The `function` token
        pub fn function_token(&self) -> &TokenReference {
            &self.function_token
        }
        /// The function body, everything except `local function x` in `local function x(a, b, c) call() end`
        pub fn body(&self) -> &FunctionBody<P> {
            &self.body
        }
        /// The name of the function, the `x` part of `local function x() end`
        pub fn name(&self) -> &TokenReference {
            &self.name
        }
        /// Returns a new LocalFunction with the given `local` token
        pub fn with_local_token(self, local_token: TokenReference) -> Self {
            Self {
                local_token,
                ..self
            }
        }
        /// Returns a new LocalFunction with the given `function` token
        pub fn with_function_token(self, function_token: TokenReference) -> Self {
            Self {
                function_token,
                ..self
            }
        }
        /// Returns a new LocalFunction with the given name
        pub fn with_name(self, name: TokenReference) -> Self {
            Self { name, ..self }
        }
        /// Returns a new LocalFunction with the given function body
        pub fn with_body(self, body: FunctionBody<P>) -> Self {
            Self { body, ..self }
        }
    }
    /// An assignment to a local variable, such as `local x = 1`
    pub struct LocalAssignment<P: Plugin = DefaultPlugin> {
        local_token: TokenReference,
        name_list: Punctuated<TokenReference>,
        equal_token: Option<TokenReference>,
        expr_list: Punctuated<Expression<P>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for LocalAssignment<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "local_token" => _serde::export::Ok(__Field::__field0),
                            "name_list" => _serde::export::Ok(__Field::__field1),
                            "equal_token" => _serde::export::Ok(__Field::__field2),
                            "expr_list" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"local_token" => _serde::export::Ok(__Field::__field0),
                            b"name_list" => _serde::export::Ok(__Field::__field1),
                            b"equal_token" => _serde::export::Ok(__Field::__field2),
                            b"expr_list" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<LocalAssignment<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = LocalAssignment<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct LocalAssignment")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LocalAssignment with 4 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LocalAssignment with 4 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct LocalAssignment with 4 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<Expression<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct LocalAssignment with 4 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(LocalAssignment {
                            local_token: __field0,
                            name_list: __field1,
                            equal_token: __field2,
                            expr_list: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Punctuated<TokenReference>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<Option<TokenReference>> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Punctuated<Expression<P>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "local_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name_list",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "equal_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<Expression<P>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("local_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("equal_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(LocalAssignment {
                            local_token: __field0,
                            name_list: __field1,
                            equal_token: __field2,
                            expr_list: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["local_token", "name_list", "equal_token", "expr_list"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LocalAssignment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LocalAssignment<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for LocalAssignment<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "LocalAssignment",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "local_token",
                    &self.local_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name_list",
                    &self.name_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "equal_token",
                    &self.equal_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for LocalAssignment<P> {
        #[inline]
        fn clone(&self) -> LocalAssignment<P> {
            match *self {
                LocalAssignment {
                    local_token: ref __self_0_0,
                    name_list: ref __self_0_1,
                    equal_token: ref __self_0_2,
                    expr_list: ref __self_0_3,
                } => LocalAssignment {
                    local_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    name_list: ::core::clone::Clone::clone(&(*__self_0_1)),
                    equal_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                    expr_list: ::core::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for LocalAssignment<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                LocalAssignment {
                    local_token: ref __self_0_0,
                    name_list: ref __self_0_1,
                    equal_token: ref __self_0_2,
                    expr_list: ref __self_0_3,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "LocalAssignment");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "local_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name_list",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "equal_token",
                        &&(*__self_0_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expr_list",
                        &&(*__self_0_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for LocalAssignment<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for LocalAssignment<P> {
        #[inline]
        fn eq(&self, other: &LocalAssignment<P>) -> bool {
            match *other {
                LocalAssignment {
                    local_token: ref __self_1_0,
                    name_list: ref __self_1_1,
                    equal_token: ref __self_1_2,
                    expr_list: ref __self_1_3,
                } => match *self {
                    LocalAssignment {
                        local_token: ref __self_0_0,
                        name_list: ref __self_0_1,
                        equal_token: ref __self_0_2,
                        expr_list: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LocalAssignment<P>) -> bool {
            match *other {
                LocalAssignment {
                    local_token: ref __self_1_0,
                    name_list: ref __self_1_1,
                    equal_token: ref __self_1_2,
                    expr_list: ref __self_1_3,
                } => match *self {
                    LocalAssignment {
                        local_token: ref __self_0_0,
                        name_list: ref __self_0_1,
                        equal_token: ref __self_0_2,
                        expr_list: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for LocalAssignment<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.local_token.start_position())
                            .or_else(|| self.name_list.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.expr_list.start_position())?,
                        None.or_else(|| self.expr_list.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.name_list.end_position())
                            .or_else(|| self.local_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.local_token.start_position())
                            .or_else(|| self.name_list.start_position())
                            .or_else(|| self.equal_token.start_position())
                            .or_else(|| self.expr_list.start_position())?,
                        None.or_else(|| self.expr_list.end_position())
                            .or_else(|| self.equal_token.end_position())
                            .or_else(|| self.name_list.end_position())
                            .or_else(|| self.local_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.local_token.similar(&other.local_token)
                    && self.name_list.similar(&other.name_list)
                    && self.equal_token.similar(&other.equal_token)
                    && self.expr_list.similar(&other.expr_list)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.local_token),
                        crate::node::TokenItem::MoreTokens(&self.name_list),
                        crate::node::TokenItem::MoreTokens(&self.equal_token),
                        crate::node::TokenItem::MoreTokens(&self.expr_list),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for LocalAssignment<P> {}
    impl<P: Plugin> LocalAssignment<P> {
        /// Returns a new LocalAssignment from the given name list
        pub fn new(name_list: Punctuated<TokenReference>) -> Self {
            Self {
                local_token: TokenReference::symbol("local ").unwrap(),
                name_list,
                equal_token: None,
                expr_list: Punctuated::new(),
            }
        }
        /// The `local` token
        pub fn local_token(&self) -> &TokenReference {
            &self.local_token
        }
        /// The `=` token in between `local x = y`, if one exists
        pub fn equal_token(&self) -> Option<&TokenReference> {
            self.equal_token.as_ref()
        }
        /// Returns the punctuated sequence of the expressions being assigned.
        /// This is the `1, 2` part of `local x, y = 1, 2`
        pub fn expressions(&self) -> &Punctuated<Expression<P>> {
            &self.expr_list
        }
        /// Returns the punctuated sequence of names being assigned to.
        /// This is the `x, y` part of `local x, y = 1, 2`
        pub fn names(&self) -> &Punctuated<TokenReference> {
            &self.name_list
        }
        /// Returns a new LocalAssignment with the given `local` token
        pub fn with_local_token(self, local_token: TokenReference) -> Self {
            Self {
                local_token,
                ..self
            }
        }
        /// Returns a new LocalAssignment with the given name list
        pub fn with_names(self, name_list: Punctuated<TokenReference>) -> Self {
            Self { name_list, ..self }
        }
        /// Returns a new LocalAssignment with the given `=` token
        pub fn with_equal_token(self, equal_token: Option<TokenReference>) -> Self {
            Self {
                equal_token,
                ..self
            }
        }
        /// Returns a new LocalAssignment with the given expression list
        pub fn with_expressions(self, expr_list: Punctuated<Expression<P>>) -> Self {
            Self { expr_list, ..self }
        }
    }
    impl fmt::Display for LocalAssignment {
        #[cfg(not(feature = "roblox"))]
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                &["not implemented: "],
                &match (&::core::fmt::Arguments::new_v1(
                    &["PLUGIN TODO: LocalAssignment Display"],
                    &match () {
                        () => [],
                    },
                ),)
                {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ));
        }
    }
    /// A `do` block, such as `do ... end`
    /// This is not used for things like `while true do end`, only those on their own
    #[display(fmt = "{}{}{}", "do_token", "block", "end_token")]
    pub struct Do<P: Plugin = DefaultPlugin> {
        do_token: TokenReference,
        block: Block<P>,
        end_token: TokenReference,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for Do<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "do_token" => _serde::export::Ok(__Field::__field0),
                            "block" => _serde::export::Ok(__Field::__field1),
                            "end_token" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"do_token" => _serde::export::Ok(__Field::__field0),
                            b"block" => _serde::export::Ok(__Field::__field1),
                            b"end_token" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<Do<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = Do<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Do")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Do with 3 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Block<P>>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Do with 3 elements",
                                    ));
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Do with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Do {
                            do_token: __field0,
                            block: __field1,
                            end_token: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Block<P>> = _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "do_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_token",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("do_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Do {
                            do_token: __field0,
                            block: __field1,
                            end_token: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["do_token", "block", "end_token"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Do",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Do<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for Do<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Do",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "do_token",
                    &self.do_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_token",
                    &self.end_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for Do<P> {
        #[inline]
        fn clone(&self) -> Do<P> {
            match *self {
                Do {
                    do_token: ref __self_0_0,
                    block: ref __self_0_1,
                    end_token: ref __self_0_2,
                } => Do {
                    do_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    block: ::core::clone::Clone::clone(&(*__self_0_1)),
                    end_token: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for Do<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Do {
                    do_token: ref __self_0_0,
                    block: ref __self_0_1,
                    end_token: ref __self_0_2,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Do");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "do_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "block",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_token",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for Do<P>
    where
        Block<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Do {
                    do_token,
                    block,
                    end_token,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&do_token, &block, &end_token) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for Do<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for Do<P> {
        #[inline]
        fn eq(&self, other: &Do<P>) -> bool {
            match *other {
                Do {
                    do_token: ref __self_1_0,
                    block: ref __self_1_1,
                    end_token: ref __self_1_2,
                } => match *self {
                    Do {
                        do_token: ref __self_0_0,
                        block: ref __self_0_1,
                        end_token: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Do<P>) -> bool {
            match *other {
                Do {
                    do_token: ref __self_1_0,
                    block: ref __self_1_1,
                    end_token: ref __self_1_2,
                } => match *self {
                    Do {
                        do_token: ref __self_0_0,
                        block: ref __self_0_1,
                        end_token: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for Do<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.do_token.start_position())
                            .or_else(|| self.block.start_position())
                            .or_else(|| self.end_token.start_position())?,
                        None.or_else(|| self.end_token.end_position())
                            .or_else(|| self.block.end_position())
                            .or_else(|| self.do_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.do_token.similar(&other.do_token)
                    && self.block.similar(&other.block)
                    && self.end_token.similar(&other.end_token)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.do_token),
                        crate::node::TokenItem::MoreTokens(&self.block),
                        crate::node::TokenItem::TokenReference(&self.end_token),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for Do<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for Do<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_do(self);
            self.do_token.visit(visitor);
            self.block.visit(visitor);
            self.end_token.visit(visitor);
            visitor.visit_do_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for Do<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_do(self);
            self.do_token = self.do_token.visit_mut(visitor);
            self.block = self.block.visit_mut(visitor);
            self.end_token = self.end_token.visit_mut(visitor);
            self = visitor.visit_do_end(self);
            self
        }
    }
    impl<P: Plugin> Do<P> {
        /// Creates an empty Do
        pub fn new() -> Self {
            Self {
                do_token: TokenReference::symbol("do\n").unwrap(),
                block: Block::new(),
                end_token: TokenReference::symbol("\nend").unwrap(),
            }
        }
        /// The `do` token
        pub fn do_token(&self) -> &TokenReference {
            &self.do_token
        }
        /// The code inside the `do ... end`
        pub fn block(&self) -> &Block<P> {
            &self.block
        }
        /// The `end` token
        pub fn end_token(&self) -> &TokenReference {
            &self.end_token
        }
        /// Returns a new Do with the given `do` token
        pub fn with_do_token(self, do_token: TokenReference) -> Self {
            Self { do_token, ..self }
        }
        /// Returns a new Do with the given block
        pub fn with_block(self, block: Block<P>) -> Self {
            Self { block, ..self }
        }
        /// Returns a new Do with the given `end` token
        pub fn with_end_token(self, end_token: TokenReference) -> Self {
            Self { end_token, ..self }
        }
    }
    impl Default for Do {
        fn default() -> Self {
            Self::new()
        }
    }
    /// A function being called, such as `call()`
    #[display(fmt = "{}{}", "prefix", "join_vec(suffixes)")]
    pub struct FunctionCall<P: Plugin = DefaultPlugin> {
        prefix: Prefix<P>,
        suffixes: Vec<Suffix<P>>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for FunctionCall<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prefix" => _serde::export::Ok(__Field::__field0),
                            "suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prefix" => _serde::export::Ok(__Field::__field0),
                            b"suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<FunctionCall<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = FunctionCall<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionCall")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Prefix<P>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionCall with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Suffix<P>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionCall with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionCall {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Prefix<P>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Suffix<P>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prefix",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Prefix<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "suffixes",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Suffix<P>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("prefix") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("suffixes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionCall {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["prefix", "suffixes"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionCall",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionCall<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for FunctionCall<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionCall",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prefix",
                    &self.prefix,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "suffixes",
                    &self.suffixes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for FunctionCall<P> {
        #[inline]
        fn clone(&self) -> FunctionCall<P> {
            match *self {
                FunctionCall {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => FunctionCall {
                    prefix: ::core::clone::Clone::clone(&(*__self_0_0)),
                    suffixes: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for FunctionCall<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                FunctionCall {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "FunctionCall");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "prefix",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "suffixes",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for FunctionCall<P>
    where
        Prefix<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                FunctionCall { prefix, suffixes } => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["", ""],
                        &match (&prefix, &join_vec(suffixes)) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for FunctionCall<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for FunctionCall<P> {
        #[inline]
        fn eq(&self, other: &FunctionCall<P>) -> bool {
            match *other {
                FunctionCall {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    FunctionCall {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionCall<P>) -> bool {
            match *other {
                FunctionCall {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    FunctionCall {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for FunctionCall<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.prefix.start_position())
                            .or_else(|| self.suffixes.start_position())?,
                        None.or_else(|| self.suffixes.end_position())
                            .or_else(|| self.prefix.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.prefix.start_position())
                            .or_else(|| self.suffixes.start_position())?,
                        None.or_else(|| self.suffixes.end_position())
                            .or_else(|| self.prefix.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.prefix.similar(&other.prefix) && self.suffixes.similar(&other.suffixes) && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.prefix),
                        crate::node::TokenItem::MoreTokens(&self.suffixes),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for FunctionCall<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for FunctionCall<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_function_call(self);
            self.prefix.visit(visitor);
            self.suffixes.visit(visitor);
            visitor.visit_function_call_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for FunctionCall<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_function_call(self);
            self.prefix = self.prefix.visit_mut(visitor);
            self.suffixes = self.suffixes.visit_mut(visitor);
            self = visitor.visit_function_call_end(self);
            self
        }
    }
    impl<P: Plugin> FunctionCall<P> {
        /// Creates a new FunctionCall from the given prefix
        /// Sets the suffixes such that the return is `prefixes()`
        pub fn new(prefix: Prefix<P>) -> Self {
            FunctionCall {
                prefix,
                suffixes: <[_]>::into_vec(box [Suffix::Call(Call::AnonymousCall(
                    FunctionArgs::Parentheses {
                        arguments: Punctuated::new(),
                        parentheses: ContainedSpan::new(
                            TokenReference::symbol("(").unwrap(),
                            TokenReference::symbol(")").unwrap(),
                        ),
                    },
                ))]),
            }
        }
        /// The prefix of a function call, the `call` part of `call()`
        pub fn prefix(&self) -> &Prefix<P> {
            &self.prefix
        }
        /// The suffix of a function call, the `()` part of `call()`
        pub fn suffixes(&self) -> impl Iterator<Item = &Suffix<P>> {
            self.suffixes.iter()
        }
        /// Returns a new FunctionCall with the given prefix
        pub fn with_prefix(self, prefix: Prefix<P>) -> Self {
            Self { prefix, ..self }
        }
        /// Returns a new FunctionCall with the given suffixes
        pub fn with_suffixes(self, suffixes: Vec<Suffix<P>>) -> Self {
            Self { suffixes, ..self }
        }
    }
    /// A function name when being declared as [`FunctionDeclaration`]
    #[display(
        fmt = "{}{}{}",
        "names",
        "display_option(self.method_colon())",
        "display_option(self.method_name())"
    )]
    pub struct FunctionName<P: Plugin = DefaultPlugin> {
        names: Punctuated<TokenReference>,
        colon_name: Option<(TokenReference, TokenReference)>,
        _phantom: std::marker::PhantomData<P>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for FunctionName<P> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "names" => _serde::export::Ok(__Field::__field0),
                            "colon_name" => _serde::export::Ok(__Field::__field1),
                            "_phantom" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"names" => _serde::export::Ok(__Field::__field0),
                            b"colon_name" => _serde::export::Ok(__Field::__field1),
                            b"_phantom" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin> {
                    marker: _serde::export::PhantomData<FunctionName<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P> {
                    type Value = FunctionName<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionName")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Punctuated<TokenReference>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionName with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<(TokenReference, TokenReference)>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionName with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            std::marker::PhantomData<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct FunctionName with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionName {
                            names: __field0,
                            colon_name: __field1,
                            _phantom: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Punctuated<TokenReference>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<
                            Option<(TokenReference, TokenReference)>,
                        > = _serde::export::None;
                        let mut __field2: _serde::export::Option<std::marker::PhantomData<P>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "names",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Punctuated<TokenReference>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "colon_name",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<(TokenReference, TokenReference)>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "_phantom",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            std::marker::PhantomData<P>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("names") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("colon_name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("_phantom") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionName {
                            names: __field0,
                            colon_name: __field1,
                            _phantom: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["names", "colon_name", "_phantom"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionName",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionName<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for FunctionName<P> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionName",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "names",
                    &self.names,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "colon_name",
                    &self.colon_name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "_phantom",
                    &self._phantom,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for FunctionName<P> {
        #[inline]
        fn clone(&self) -> FunctionName<P> {
            match *self {
                FunctionName {
                    names: ref __self_0_0,
                    colon_name: ref __self_0_1,
                    _phantom: ref __self_0_2,
                } => FunctionName {
                    names: ::core::clone::Clone::clone(&(*__self_0_0)),
                    colon_name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    _phantom: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for FunctionName<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                FunctionName {
                    names: ref __self_0_0,
                    colon_name: ref __self_0_1,
                    _phantom: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "FunctionName");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "names",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "colon_name",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "_phantom",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for FunctionName<P> {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                FunctionName {
                    names,
                    colon_name,
                    _phantom,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (
                        &names,
                        &display_option(self.method_colon()),
                        &display_option(self.method_name()),
                    ) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for FunctionName<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for FunctionName<P> {
        #[inline]
        fn eq(&self, other: &FunctionName<P>) -> bool {
            match *other {
                FunctionName {
                    names: ref __self_1_0,
                    colon_name: ref __self_1_1,
                    _phantom: ref __self_1_2,
                } => match *self {
                    FunctionName {
                        names: ref __self_0_0,
                        colon_name: ref __self_0_1,
                        _phantom: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionName<P>) -> bool {
            match *other {
                FunctionName {
                    names: ref __self_1_0,
                    colon_name: ref __self_1_1,
                    _phantom: ref __self_1_2,
                } => match *self {
                    FunctionName {
                        names: ref __self_0_0,
                        colon_name: ref __self_0_1,
                        _phantom: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for FunctionName<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.names.start_position())
                            .or_else(|| self.colon_name.start_position())
                            .or_else(|| self._phantom.start_position())?,
                        None.or_else(|| self._phantom.end_position())
                            .or_else(|| self.colon_name.end_position())
                            .or_else(|| self.names.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.names.start_position())
                            .or_else(|| self.colon_name.start_position())
                            .or_else(|| self._phantom.start_position())?,
                        None.or_else(|| self._phantom.end_position())
                            .or_else(|| self.colon_name.end_position())
                            .or_else(|| self.names.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.names.similar(&other.names)
                    && self.colon_name.similar(&other.colon_name)
                    && self._phantom.similar(&other._phantom)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::MoreTokens(&self.names),
                        crate::node::TokenItem::MoreTokens(&self.colon_name),
                        crate::node::TokenItem::MoreTokens(&self._phantom),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for FunctionName<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for FunctionName<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_function_name(self);
            self.names.visit(visitor);
            self.colon_name.visit(visitor);
            self._phantom.visit(visitor);
            visitor.visit_function_name_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for FunctionName<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_function_name(self);
            self.names = self.names.visit_mut(visitor);
            self.colon_name = self.colon_name.visit_mut(visitor);
            self._phantom = self._phantom.visit_mut(visitor);
            self = visitor.visit_function_name_end(self);
            self
        }
    }
    impl<P: Plugin> FunctionName<P> {
        /// Creates a new FunctionName from the given list of names
        pub fn new(names: Punctuated<TokenReference>) -> Self {
            Self {
                names,
                colon_name: None,
                _phantom: std::marker::PhantomData,
            }
        }
        /// The colon between the name and the method, the `:` part of `function x:y() end`
        pub fn method_colon(&self) -> Option<&TokenReference> {
            Some(&self.colon_name.as_ref()?.0)
        }
        /// A method name if one exists, the `y` part of `function x:y() end`
        pub fn method_name(&self) -> Option<&TokenReference> {
            Some(&self.colon_name.as_ref()?.1)
        }
        /// Returns the punctuated sequence over the names used when defining the function.
        /// This is the `x.y.z` part of `function x.y.z() end`
        pub fn names(&self) -> &Punctuated<TokenReference> {
            &self.names
        }
        /// Returns a new FunctionName with the given names
        pub fn with_names(self, names: Punctuated<TokenReference>) -> Self {
            Self { names, ..self }
        }
        /// Returns a new FunctionName with the given method name
        /// The first token is the colon, and the second token is the method name itself
        pub fn with_method(self, method: Option<(TokenReference, TokenReference)>) -> Self {
            Self {
                colon_name: method,
                ..self
            }
        }
    }
    /// A normal function declaration, supports simple declarations like `function x() end`
    /// as well as complicated declarations such as `function x.y.z:a() end`
    #[display(fmt = "{}{}{}", "function_token", "name", "body")]
    pub struct FunctionDeclaration<P: Plugin = DefaultPlugin> {
        function_token: TokenReference,
        name: FunctionName<P>,
        body: FunctionBody<P>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, P: Plugin> _serde::Deserialize<'de> for FunctionDeclaration<P>
        where
            P: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "function_token" => _serde::export::Ok(__Field::__field0),
                            "name" => _serde::export::Ok(__Field::__field1),
                            "body" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"function_token" => _serde::export::Ok(__Field::__field0),
                            b"name" => _serde::export::Ok(__Field::__field1),
                            b"body" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, P: Plugin>
                where
                    P: _serde::Deserialize<'de>,
                {
                    marker: _serde::export::PhantomData<FunctionDeclaration<P>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de, P: Plugin> _serde::de::Visitor<'de> for __Visitor<'de, P>
                where
                    P: _serde::Deserialize<'de>,
                {
                    type Value = FunctionDeclaration<P>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct FunctionDeclaration",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionDeclaration with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            FunctionName<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionDeclaration with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            FunctionBody<P>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct FunctionDeclaration with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionDeclaration {
                            function_token: __field0,
                            name: __field1,
                            body: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<FunctionName<P>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<FunctionBody<P>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "function_token",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionName<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "body",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionBody<P>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("function_token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("body") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionDeclaration {
                            function_token: __field0,
                            name: __field1,
                            body: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["function_token", "name", "body"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionDeclaration",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionDeclaration<P>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<P: Plugin> _serde::Serialize for FunctionDeclaration<P>
        where
            P: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionDeclaration",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "function_token",
                    &self.function_token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "body",
                    &self.body,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::clone::Clone + Plugin> ::core::clone::Clone for FunctionDeclaration<P> {
        #[inline]
        fn clone(&self) -> FunctionDeclaration<P> {
            match *self {
                FunctionDeclaration {
                    function_token: ref __self_0_0,
                    name: ref __self_0_1,
                    body: ref __self_0_2,
                } => FunctionDeclaration {
                    function_token: ::core::clone::Clone::clone(&(*__self_0_0)),
                    name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    body: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::fmt::Debug + Plugin> ::core::fmt::Debug for FunctionDeclaration<P> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                FunctionDeclaration {
                    function_token: ref __self_0_0,
                    name: ref __self_0_1,
                    body: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "FunctionDeclaration");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "function_token",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "body",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<P: Plugin> ::core::fmt::Display for FunctionDeclaration<P>
    where
        FunctionBody<P>: ::core::fmt::Display,
        FunctionName<P>: ::core::fmt::Display,
    {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                FunctionDeclaration {
                    function_token,
                    name,
                    body,
                } => _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["", "", ""],
                    &match (&function_token, &name, &body) {
                        (arg0, arg1, arg2) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                        ],
                    },
                )),
                _ => Ok(()),
            }
        }
    }
    impl<P: Plugin> ::core::marker::StructuralPartialEq for FunctionDeclaration<P> {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::core::cmp::PartialEq + Plugin> ::core::cmp::PartialEq for FunctionDeclaration<P> {
        #[inline]
        fn eq(&self, other: &FunctionDeclaration<P>) -> bool {
            match *other {
                FunctionDeclaration {
                    function_token: ref __self_1_0,
                    name: ref __self_1_1,
                    body: ref __self_1_2,
                } => match *self {
                    FunctionDeclaration {
                        function_token: ref __self_0_0,
                        name: ref __self_0_1,
                        body: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionDeclaration<P>) -> bool {
            match *other {
                FunctionDeclaration {
                    function_token: ref __self_1_0,
                    name: ref __self_1_1,
                    body: ref __self_1_2,
                } => match *self {
                    FunctionDeclaration {
                        function_token: ref __self_0_0,
                        name: ref __self_0_1,
                        body: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<P: Plugin> crate::node::Node for FunctionDeclaration<P> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.function_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.body.start_position())?,
                        None.or_else(|| self.body.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.function_token.end_position())?,
                    ))
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    Some((
                        None.or_else(|| self.function_token.start_position())
                            .or_else(|| self.name.start_position())
                            .or_else(|| self.body.start_position())?,
                        None.or_else(|| self.body.end_position())
                            .or_else(|| self.name.end_position())
                            .or_else(|| self.function_token.end_position())?,
                    ))
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                self.function_token.similar(&other.function_token)
                    && self.name.similar(&other.name)
                    && self.body.similar(&other.body)
                    && true
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                crate::node::Tokens {
                    items: <[_]>::into_vec(box [
                        crate::node::TokenItem::TokenReference(&self.function_token),
                        crate::node::TokenItem::MoreTokens(&self.name),
                        crate::node::TokenItem::MoreTokens(&self.body),
                    ]),
                }
            }
        }
    }
    impl<P: Plugin> crate::private::Sealed for FunctionDeclaration<P> {}
    impl<P: Plugin> crate::visitors::Visit<P> for FunctionDeclaration<P> {
        fn visit<V: crate::visitors::Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_function_declaration(self);
            self.function_token.visit(visitor);
            self.name.visit(visitor);
            self.body.visit(visitor);
            visitor.visit_function_declaration_end(self);
        }
    }
    impl<P: Plugin> crate::visitors::VisitMut<P> for FunctionDeclaration<P> {
        fn visit_mut<V: crate::visitors::VisitorMut<P>>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_function_declaration(self);
            self.function_token = self.function_token.visit_mut(visitor);
            self.name = self.name.visit_mut(visitor);
            self.body = self.body.visit_mut(visitor);
            self = visitor.visit_function_declaration_end(self);
            self
        }
    }
    impl<P: Plugin> FunctionDeclaration<P> {
        /// Creates a new FunctionDeclaration from the given name
        pub fn new(name: FunctionName<P>) -> Self {
            Self {
                function_token: TokenReference::symbol("function ").unwrap(),
                name,
                body: FunctionBody::new(),
            }
        }
        /// The `function` token
        pub fn function_token(&self) -> &TokenReference {
            &self.function_token
        }
        /// The body of the function
        pub fn body(&self) -> &FunctionBody<P> {
            &self.body
        }
        /// The name of the function
        pub fn name(&self) -> &FunctionName<P> {
            &self.name
        }
        /// Returns a new FunctionDeclaration with the given `function` token
        pub fn with_function_token(self, function_token: TokenReference) -> Self {
            Self {
                function_token,
                ..self
            }
        }
        /// Returns a new FunctionDeclaration with the given function name
        pub fn with_name(self, name: FunctionName<P>) -> Self {
            Self { name, ..self }
        }
        /// Returns a new FunctionDeclaration with the given function body
        pub fn with_body(self, body: FunctionBody<P>) -> Self {
            Self { body, ..self }
        }
    }
    #[non_exhaustive]
    ///Operators that require two operands, such as X + Y or X - Y
    #[visit(skip_visit_self)]
    #[display(fmt = "{}")]
    pub enum BinOp {
        #[allow(missing_docs)]
        And(TokenReference),
        #[allow(missing_docs)]
        Caret(TokenReference),
        #[allow(missing_docs)]
        GreaterThan(TokenReference),
        #[allow(missing_docs)]
        GreaterThanEqual(TokenReference),
        #[allow(missing_docs)]
        LessThan(TokenReference),
        #[allow(missing_docs)]
        LessThanEqual(TokenReference),
        #[allow(missing_docs)]
        Minus(TokenReference),
        #[allow(missing_docs)]
        Or(TokenReference),
        #[allow(missing_docs)]
        Percent(TokenReference),
        #[allow(missing_docs)]
        Plus(TokenReference),
        #[allow(missing_docs)]
        Slash(TokenReference),
        #[allow(missing_docs)]
        Star(TokenReference),
        #[allow(missing_docs)]
        TildeEqual(TokenReference),
        #[allow(missing_docs)]
        TwoDots(TokenReference),
        #[allow(missing_docs)]
        TwoEqual(TokenReference),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for BinOp {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            12u64 => _serde::export::Ok(__Field::__field12),
                            13u64 => _serde::export::Ok(__Field::__field13),
                            14u64 => _serde::export::Ok(__Field::__field14),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 15",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "And" => _serde::export::Ok(__Field::__field0),
                            "Caret" => _serde::export::Ok(__Field::__field1),
                            "GreaterThan" => _serde::export::Ok(__Field::__field2),
                            "GreaterThanEqual" => _serde::export::Ok(__Field::__field3),
                            "LessThan" => _serde::export::Ok(__Field::__field4),
                            "LessThanEqual" => _serde::export::Ok(__Field::__field5),
                            "Minus" => _serde::export::Ok(__Field::__field6),
                            "Or" => _serde::export::Ok(__Field::__field7),
                            "Percent" => _serde::export::Ok(__Field::__field8),
                            "Plus" => _serde::export::Ok(__Field::__field9),
                            "Slash" => _serde::export::Ok(__Field::__field10),
                            "Star" => _serde::export::Ok(__Field::__field11),
                            "TildeEqual" => _serde::export::Ok(__Field::__field12),
                            "TwoDots" => _serde::export::Ok(__Field::__field13),
                            "TwoEqual" => _serde::export::Ok(__Field::__field14),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"And" => _serde::export::Ok(__Field::__field0),
                            b"Caret" => _serde::export::Ok(__Field::__field1),
                            b"GreaterThan" => _serde::export::Ok(__Field::__field2),
                            b"GreaterThanEqual" => _serde::export::Ok(__Field::__field3),
                            b"LessThan" => _serde::export::Ok(__Field::__field4),
                            b"LessThanEqual" => _serde::export::Ok(__Field::__field5),
                            b"Minus" => _serde::export::Ok(__Field::__field6),
                            b"Or" => _serde::export::Ok(__Field::__field7),
                            b"Percent" => _serde::export::Ok(__Field::__field8),
                            b"Plus" => _serde::export::Ok(__Field::__field9),
                            b"Slash" => _serde::export::Ok(__Field::__field10),
                            b"Star" => _serde::export::Ok(__Field::__field11),
                            b"TildeEqual" => _serde::export::Ok(__Field::__field12),
                            b"TwoDots" => _serde::export::Ok(__Field::__field13),
                            b"TwoEqual" => _serde::export::Ok(__Field::__field14),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<BinOp>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = BinOp;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum BinOp")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::And,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Caret,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::GreaterThan,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::GreaterThanEqual,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::LessThan,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::LessThanEqual,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Minus,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Or,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Percent,
                            ),
                            (__Field::__field9, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Plus,
                            ),
                            (__Field::__field10, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Slash,
                            ),
                            (__Field::__field11, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::Star,
                            ),
                            (__Field::__field12, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::TildeEqual,
                            ),
                            (__Field::__field13, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::TwoDots,
                            ),
                            (__Field::__field14, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                BinOp::TwoEqual,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "And",
                    "Caret",
                    "GreaterThan",
                    "GreaterThanEqual",
                    "LessThan",
                    "LessThanEqual",
                    "Minus",
                    "Or",
                    "Percent",
                    "Plus",
                    "Slash",
                    "Star",
                    "TildeEqual",
                    "TwoDots",
                    "TwoEqual",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "BinOp",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<BinOp>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for BinOp {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    BinOp::And(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        0u32,
                        "And",
                        __field0,
                    ),
                    BinOp::Caret(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        1u32,
                        "Caret",
                        __field0,
                    ),
                    BinOp::GreaterThan(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            2u32,
                            "GreaterThan",
                            __field0,
                        )
                    }
                    BinOp::GreaterThanEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            3u32,
                            "GreaterThanEqual",
                            __field0,
                        )
                    }
                    BinOp::LessThan(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        4u32,
                        "LessThan",
                        __field0,
                    ),
                    BinOp::LessThanEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            5u32,
                            "LessThanEqual",
                            __field0,
                        )
                    }
                    BinOp::Minus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        6u32,
                        "Minus",
                        __field0,
                    ),
                    BinOp::Or(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        7u32,
                        "Or",
                        __field0,
                    ),
                    BinOp::Percent(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        8u32,
                        "Percent",
                        __field0,
                    ),
                    BinOp::Plus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        9u32,
                        "Plus",
                        __field0,
                    ),
                    BinOp::Slash(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        10u32,
                        "Slash",
                        __field0,
                    ),
                    BinOp::Star(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        11u32,
                        "Star",
                        __field0,
                    ),
                    BinOp::TildeEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            12u32,
                            "TildeEqual",
                            __field0,
                        )
                    }
                    BinOp::TwoDots(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        13u32,
                        "TwoDots",
                        __field0,
                    ),
                    BinOp::TwoEqual(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        14u32,
                        "TwoEqual",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for BinOp {
        #[inline]
        fn clone(&self) -> BinOp {
            match (&*self,) {
                (&BinOp::And(ref __self_0),) => {
                    BinOp::And(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Caret(ref __self_0),) => {
                    BinOp::Caret(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::GreaterThan(ref __self_0),) => {
                    BinOp::GreaterThan(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::GreaterThanEqual(ref __self_0),) => {
                    BinOp::GreaterThanEqual(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::LessThan(ref __self_0),) => {
                    BinOp::LessThan(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::LessThanEqual(ref __self_0),) => {
                    BinOp::LessThanEqual(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Minus(ref __self_0),) => {
                    BinOp::Minus(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Or(ref __self_0),) => BinOp::Or(::core::clone::Clone::clone(&(*__self_0))),
                (&BinOp::Percent(ref __self_0),) => {
                    BinOp::Percent(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Plus(ref __self_0),) => {
                    BinOp::Plus(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Slash(ref __self_0),) => {
                    BinOp::Slash(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Star(ref __self_0),) => {
                    BinOp::Star(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TildeEqual(ref __self_0),) => {
                    BinOp::TildeEqual(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TwoDots(ref __self_0),) => {
                    BinOp::TwoDots(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TwoEqual(ref __self_0),) => {
                    BinOp::TwoEqual(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BinOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&BinOp::And(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "And");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Caret(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Caret");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::GreaterThan(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "GreaterThan");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::GreaterThanEqual(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "GreaterThanEqual");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::LessThan(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LessThan");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::LessThanEqual(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LessThanEqual");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Minus(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Minus");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Or(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Or");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Percent(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Percent");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Plus(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Plus");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Slash(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Slash");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::Star(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Star");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::TildeEqual(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TildeEqual");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::TwoDots(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TwoDots");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&BinOp::TwoEqual(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TwoEqual");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::fmt::Display for BinOp {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            struct _derive_more_DisplayAs<F>(F)
            where
                F: ::core::ops::Fn(&mut ::core::fmt::Formatter) -> ::core::fmt::Result;
            const _derive_more_DisplayAs_impl: () = {
                impl<F> ::core::fmt::Display for _derive_more_DisplayAs<F>
                where
                    F: ::core::ops::Fn(&mut ::core::fmt::Formatter) -> ::core::fmt::Result,
                {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                        (self.0)(f)
                    }
                }
            };
            match self {
                BinOp::And(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Caret(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::GreaterThan(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::GreaterThanEqual(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::LessThan(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::LessThanEqual(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Minus(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Or(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Percent(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Plus(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Slash(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::Star(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::TildeEqual(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::TwoDots(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                BinOp::TwoEqual(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for BinOp {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for BinOp {
        #[inline]
        fn eq(&self, other: &BinOp) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&BinOp::And(ref __self_0), &BinOp::And(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Caret(ref __self_0), &BinOp::Caret(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::GreaterThan(ref __self_0), &BinOp::GreaterThan(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &BinOp::GreaterThanEqual(ref __self_0),
                            &BinOp::GreaterThanEqual(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&BinOp::LessThan(ref __self_0), &BinOp::LessThan(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &BinOp::LessThanEqual(ref __self_0),
                            &BinOp::LessThanEqual(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&BinOp::Minus(ref __self_0), &BinOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Or(ref __self_0), &BinOp::Or(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Percent(ref __self_0), &BinOp::Percent(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Plus(ref __self_0), &BinOp::Plus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Slash(ref __self_0), &BinOp::Slash(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Star(ref __self_0), &BinOp::Star(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TildeEqual(ref __self_0), &BinOp::TildeEqual(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TwoDots(ref __self_0), &BinOp::TwoDots(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TwoEqual(ref __self_0), &BinOp::TwoEqual(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &BinOp) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&BinOp::And(ref __self_0), &BinOp::And(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Caret(ref __self_0), &BinOp::Caret(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::GreaterThan(ref __self_0), &BinOp::GreaterThan(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &BinOp::GreaterThanEqual(ref __self_0),
                            &BinOp::GreaterThanEqual(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&BinOp::LessThan(ref __self_0), &BinOp::LessThan(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &BinOp::LessThanEqual(ref __self_0),
                            &BinOp::LessThanEqual(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&BinOp::Minus(ref __self_0), &BinOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Or(ref __self_0), &BinOp::Or(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Percent(ref __self_0), &BinOp::Percent(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Plus(ref __self_0), &BinOp::Plus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Slash(ref __self_0), &BinOp::Slash(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Star(ref __self_0), &BinOp::Star(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TildeEqual(ref __self_0), &BinOp::TildeEqual(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TwoDots(ref __self_0), &BinOp::TwoDots(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TwoEqual(ref __self_0), &BinOp::TwoEqual(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl crate::node::Node for BinOp {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        BinOp::And(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        BinOp::Caret(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::GreaterThan(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::GreaterThanEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::LessThan(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::LessThanEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Minus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Or(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        BinOp::Percent(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Plus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Slash(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Star(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TildeEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TwoDots(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TwoEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        BinOp::And(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        BinOp::Caret(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::GreaterThan(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::GreaterThanEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::LessThan(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::LessThanEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Minus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Or(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        BinOp::Percent(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Plus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Slash(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::Star(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TildeEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TwoDots(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        BinOp::TwoEqual(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    BinOp::And(__self_0) => {
                        if let BinOp::And(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Caret(__self_0) => {
                        if let BinOp::Caret(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::GreaterThan(__self_0) => {
                        if let BinOp::GreaterThan(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::GreaterThanEqual(__self_0) => {
                        if let BinOp::GreaterThanEqual(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::LessThan(__self_0) => {
                        if let BinOp::LessThan(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::LessThanEqual(__self_0) => {
                        if let BinOp::LessThanEqual(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Minus(__self_0) => {
                        if let BinOp::Minus(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Or(__self_0) => {
                        if let BinOp::Or(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Percent(__self_0) => {
                        if let BinOp::Percent(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Plus(__self_0) => {
                        if let BinOp::Plus(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Slash(__self_0) => {
                        if let BinOp::Slash(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::Star(__self_0) => {
                        if let BinOp::Star(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::TildeEqual(__self_0) => {
                        if let BinOp::TildeEqual(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::TwoDots(__self_0) => {
                        if let BinOp::TwoDots(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    BinOp::TwoEqual(__self_0) => {
                        if let BinOp::TwoEqual(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    BinOp::And(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Caret(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::GreaterThan(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::GreaterThanEqual(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::LessThan(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::LessThanEqual(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Minus(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Or(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Percent(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Plus(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Slash(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::Star(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::TildeEqual(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::TwoDots(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    BinOp::TwoEqual(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl crate::private::Sealed for BinOp {}
    impl crate::visitors::Visit for BinOp {
        fn visit<V: crate::visitors::Visitor>(&self, visitor: &mut V) {
            match self {
                BinOp::And(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Caret(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::GreaterThan(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::GreaterThanEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::LessThan(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::LessThanEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Minus(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Or(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Percent(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Plus(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Slash(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Star(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TildeEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TwoDots(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TwoEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
        }
    }
    impl crate::visitors::VisitMut for BinOp {
        fn visit_mut<V: crate::visitors::VisitorMut>(mut self, visitor: &mut V) -> Self {
            self = match self {
                BinOp::And(__self_0) => BinOp::And(__self_0.visit_mut(visitor)),
                BinOp::Caret(__self_0) => BinOp::Caret(__self_0.visit_mut(visitor)),
                BinOp::GreaterThan(__self_0) => BinOp::GreaterThan(__self_0.visit_mut(visitor)),
                BinOp::GreaterThanEqual(__self_0) => {
                    BinOp::GreaterThanEqual(__self_0.visit_mut(visitor))
                }
                BinOp::LessThan(__self_0) => BinOp::LessThan(__self_0.visit_mut(visitor)),
                BinOp::LessThanEqual(__self_0) => BinOp::LessThanEqual(__self_0.visit_mut(visitor)),
                BinOp::Minus(__self_0) => BinOp::Minus(__self_0.visit_mut(visitor)),
                BinOp::Or(__self_0) => BinOp::Or(__self_0.visit_mut(visitor)),
                BinOp::Percent(__self_0) => BinOp::Percent(__self_0.visit_mut(visitor)),
                BinOp::Plus(__self_0) => BinOp::Plus(__self_0.visit_mut(visitor)),
                BinOp::Slash(__self_0) => BinOp::Slash(__self_0.visit_mut(visitor)),
                BinOp::Star(__self_0) => BinOp::Star(__self_0.visit_mut(visitor)),
                BinOp::TildeEqual(__self_0) => BinOp::TildeEqual(__self_0.visit_mut(visitor)),
                BinOp::TwoDots(__self_0) => BinOp::TwoDots(__self_0.visit_mut(visitor)),
                BinOp::TwoEqual(__self_0) => BinOp::TwoEqual(__self_0.visit_mut(visitor)),
            };
            self
        }
    }
    impl BinOp {
        /// The precedence of the operator, from a scale of 1 to 8. The larger the number, the higher the precedence.
        /// See more at http://www.lua.org/manual/5.1/manual.html#2.5.6
        pub fn precedence(&self) -> u8 {
            match *self {
                BinOp::Caret(_) => 8,
                BinOp::Star(_) | BinOp::Slash(_) | BinOp::Percent(_) => 6,
                BinOp::Plus(_) | BinOp::Minus(_) => 5,
                BinOp::TwoDots(_) => 4,
                BinOp::GreaterThan(_)
                | BinOp::LessThan(_)
                | BinOp::GreaterThanEqual(_)
                | BinOp::LessThanEqual(_)
                | BinOp::TildeEqual(_)
                | BinOp::TwoEqual(_) => 3,
                BinOp::And(_) => 2,
                BinOp::Or(_) => 1,
            }
        }
        /// Whether the operator is right associative. If not, it is left associative.
        /// See more at https://www.lua.org/pil/3.5.html
        pub fn is_right_associative(&self) -> bool {
            match *self {
                BinOp::Caret(_) | BinOp::TwoDots(_) => true,
                _ => false,
            }
        }
        /// The token associated with the operator
        pub fn token(&self) -> &TokenReference {
            match self {
                BinOp::And(token)
                | BinOp::Caret(token)
                | BinOp::GreaterThan(token)
                | BinOp::GreaterThanEqual(token)
                | BinOp::LessThan(token)
                | BinOp::LessThanEqual(token)
                | BinOp::Minus(token)
                | BinOp::Or(token)
                | BinOp::Percent(token)
                | BinOp::Plus(token)
                | BinOp::Slash(token)
                | BinOp::Star(token)
                | BinOp::TildeEqual(token)
                | BinOp::TwoDots(token)
                | BinOp::TwoEqual(token) => token,
            }
        }
    }
    #[non_exhaustive]
    ///Operators that require just one operand, such as #X
    #[display(fmt = "{}")]
    pub enum UnOp {
        #[allow(missing_docs)]
        Minus(TokenReference),
        #[allow(missing_docs)]
        Not(TokenReference),
        #[allow(missing_docs)]
        Hash(TokenReference),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnOp {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Minus" => _serde::export::Ok(__Field::__field0),
                            "Not" => _serde::export::Ok(__Field::__field1),
                            "Hash" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Minus" => _serde::export::Ok(__Field::__field0),
                            b"Not" => _serde::export::Ok(__Field::__field1),
                            b"Hash" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnOp>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnOp;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum UnOp")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                UnOp::Minus,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                UnOp::Not,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference>(
                                    __variant,
                                ),
                                UnOp::Hash,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Minus", "Not", "Hash"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UnOp",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnOp>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnOp {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UnOp::Minus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        0u32,
                        "Minus",
                        __field0,
                    ),
                    UnOp::Not(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        1u32,
                        "Not",
                        __field0,
                    ),
                    UnOp::Hash(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        2u32,
                        "Hash",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnOp {
        #[inline]
        fn clone(&self) -> UnOp {
            match (&*self,) {
                (&UnOp::Minus(ref __self_0),) => {
                    UnOp::Minus(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&UnOp::Not(ref __self_0),) => UnOp::Not(::core::clone::Clone::clone(&(*__self_0))),
                (&UnOp::Hash(ref __self_0),) => {
                    UnOp::Hash(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnOp {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&UnOp::Minus(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Minus");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&UnOp::Not(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Not");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&UnOp::Hash(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Hash");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::fmt::Display for UnOp {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            struct _derive_more_DisplayAs<F>(F)
            where
                F: ::core::ops::Fn(&mut ::core::fmt::Formatter) -> ::core::fmt::Result;
            const _derive_more_DisplayAs_impl: () = {
                impl<F> ::core::fmt::Display for _derive_more_DisplayAs<F>
                where
                    F: ::core::ops::Fn(&mut ::core::fmt::Formatter) -> ::core::fmt::Result,
                {
                    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                        (self.0)(f)
                    }
                }
            };
            match self {
                UnOp::Minus(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                UnOp::Not(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                UnOp::Hash(_0) => {
                    _derive_more_display_formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&_derive_more_DisplayAs(|_derive_more_display_formatter| {
                            ::core::fmt::Display::fmt(_0, _derive_more_display_formatter)
                        }),)
                        {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                _ => Ok(()),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for UnOp {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnOp {
        #[inline]
        fn eq(&self, other: &UnOp) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&UnOp::Minus(ref __self_0), &UnOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&UnOp::Not(ref __self_0), &UnOp::Not(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&UnOp::Hash(ref __self_0), &UnOp::Hash(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &UnOp) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&UnOp::Minus(ref __self_0), &UnOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&UnOp::Not(ref __self_0), &UnOp::Not(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&UnOp::Hash(ref __self_0), &UnOp::Hash(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl crate::node::Node for UnOp {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        UnOp::Minus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        UnOp::Not(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        UnOp::Hash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                {
                    #[allow(unused)]
                    match self {
                        UnOp::Minus(inner) => {
                            Some((inner.start_position()?, inner.end_position()?))
                        }
                        UnOp::Not(inner) => Some((inner.start_position()?, inner.end_position()?)),
                        UnOp::Hash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    }
                }?
                .1,
            )
        }
        fn similar(&self, other: &Self) -> bool {
            {
                match self {
                    UnOp::Minus(__self_0) => {
                        if let UnOp::Minus(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    UnOp::Not(__self_0) => {
                        if let UnOp::Not(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                    UnOp::Hash(__self_0) => {
                        if let UnOp::Hash(other___self_0) = &other {
                            __self_0.similar(other___self_0) && true
                        } else {
                            false
                        }
                    }
                }
            }
        }
        fn tokens<'a>(&'a self) -> crate::node::Tokens<'a> {
            {
                match *self {
                    UnOp::Minus(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    UnOp::Not(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                    UnOp::Hash(ref __self_0) => crate::node::Tokens {
                        items: <[_]>::into_vec(box [crate::node::TokenItem::TokenReference(
                            &__self_0,
                        )]),
                    },
                }
            }
        }
    }
    impl crate::private::Sealed for UnOp {}
    impl crate::visitors::Visit for UnOp {
        fn visit<V: crate::visitors::Visitor>(&self, visitor: &mut V) {
            visitor.visit_un_op(self);
            match self {
                UnOp::Minus(__self_0) => {
                    __self_0.visit(visitor);
                }
                UnOp::Not(__self_0) => {
                    __self_0.visit(visitor);
                }
                UnOp::Hash(__self_0) => {
                    __self_0.visit(visitor);
                }
            };
            visitor.visit_un_op_end(self);
        }
    }
    impl crate::visitors::VisitMut for UnOp {
        fn visit_mut<V: crate::visitors::VisitorMut>(mut self, visitor: &mut V) -> Self {
            self = visitor.visit_un_op(self);
            self = match self {
                UnOp::Minus(__self_0) => UnOp::Minus(__self_0.visit_mut(visitor)),
                UnOp::Not(__self_0) => UnOp::Not(__self_0.visit_mut(visitor)),
                UnOp::Hash(__self_0) => UnOp::Hash(__self_0.visit_mut(visitor)),
            };
            self = visitor.visit_un_op_end(self);
            self
        }
    }
    impl UnOp {
        /// The precedence of the operator, from a scale of 1 to 8. The larger the number, the higher the precedence.
        /// See more at http://www.lua.org/manual/5.1/manual.html#2.5.6
        pub fn precedence(&self) -> u8 {
            7
        }
        /// The token associated with the operator
        pub fn token(&self) -> &TokenReference {
            match self {
                UnOp::Minus(token) | UnOp::Not(token) | UnOp::Hash(token) => token,
            }
        }
    }
    /// An error that occurs when creating the ast *after* tokenizing
    pub enum AstError {
        /// There were no tokens passed, which shouldn't happen normally
        Empty,
        /// Tokens passed had no end of file token, which shouldn't happen normally
        NoEof,
        /// An unexpected token, the most likely scenario when getting an AstError
        UnexpectedToken {
            /// The token that caused the error
            token: Token,
            /// Any additional information that could be provided for debugging
            additional: Option<Cow<'static, str>>,
        },
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AstError {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Empty" => _serde::export::Ok(__Field::__field0),
                            "NoEof" => _serde::export::Ok(__Field::__field1),
                            "UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Empty" => _serde::export::Ok(__Field::__field0),
                            b"NoEof" => _serde::export::Ok(__Field::__field1),
                            b"UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AstError>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AstError;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum AstError")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(AstError::Empty)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(AstError::NoEof)
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "token" => _serde::export::Ok(__Field::__field0),
                                            "additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"token" => _serde::export::Ok(__Field::__field0),
                                            b"additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::export::PhantomData<AstError>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = AstError;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant AstError::UnexpectedToken",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<Token>(
                                                &mut __seq,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant AstError::UnexpectedToken with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<Cow<'static, str>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant AstError::UnexpectedToken with 2 elements")) ;
                                                }
                                            };
                                        _serde::export::Ok(AstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<Token> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<
                                            Option<Cow<'static, str>>,
                                        > = _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("token")) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Token,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("additional")) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<Cow<'static, str>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("token") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "additional",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(AstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["token", "additional"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<AstError>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Empty", "NoEof", "UnexpectedToken"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AstError",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<AstError>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AstError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AstError::Empty => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AstError",
                        0u32,
                        "Empty",
                    ),
                    AstError::NoEof => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AstError",
                        1u32,
                        "NoEof",
                    ),
                    AstError::UnexpectedToken {
                        ref token,
                        ref additional,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "AstError",
                            2u32,
                            "UnexpectedToken",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token",
                            token,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional",
                            additional,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AstError {
        #[inline]
        fn clone(&self) -> AstError {
            match (&*self,) {
                (&AstError::Empty,) => AstError::Empty,
                (&AstError::NoEof,) => AstError::NoEof,
                (&AstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => AstError::UnexpectedToken {
                    token: ::core::clone::Clone::clone(&(*__self_0)),
                    additional: ::core::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AstError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&AstError::Empty,) => ::core::fmt::Formatter::write_str(f, "Empty"),
                (&AstError::NoEof,) => ::core::fmt::Formatter::write_str(f, "NoEof"),
                (&AstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "UnexpectedToken");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "token",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "additional",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for AstError {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AstError {
        #[inline]
        fn eq(&self, other: &AstError) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &AstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &AstError) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &AstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl fmt::Display for AstError {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match self {
                AstError::Empty => formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["tokens passed was empty, which shouldn\'t happen normally"],
                    &match () {
                        () => [],
                    },
                )),
                AstError::NoEof => formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["tokens passed had no eof token, which shouldn\'t happen normally"],
                    &match () {
                        () => [],
                    },
                )),
                AstError::UnexpectedToken { token, additional } => {
                    formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &[
                            "unexpected token `",
                            "`. (starting from line ",
                            ", character ",
                            " and ending on line ",
                            ", character ",
                            ")",
                        ],
                        &match (
                            &token,
                            &token.start_position().line(),
                            &token.start_position().character(),
                            &token.end_position().line(),
                            &token.end_position().character(),
                            &match additional {
                                Some(additional) => {
                                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                        &["\nadditional information: "],
                                        &match (&additional,) {
                                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            )],
                                        },
                                    ));
                                    res
                                }
                                None => String::new(),
                            },
                        ) {
                            (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg4, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg5, ::core::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
            }
        }
    }
    impl std::error::Error for AstError {}
    /// An abstract syntax tree, contains all the nodes used in the code
    pub struct Ast {
        pub(crate) nodes: Block,
        pub(crate) eof: TokenReference,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Ast {
        #[inline]
        fn clone(&self) -> Ast {
            match *self {
                Ast {
                    nodes: ref __self_0_0,
                    eof: ref __self_0_1,
                } => Ast {
                    nodes: ::core::clone::Clone::clone(&(*__self_0_0)),
                    eof: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Ast {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Ast {
                    nodes: ref __self_0_0,
                    eof: ref __self_0_1,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Ast");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "nodes",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "eof",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Ast {
        /// Create an Ast from the passed tokens. You probably want [`parse`](crate::parse)
        ///
        /// # Errors
        ///
        /// If the tokens passed are impossible to get through normal tokenization,
        /// an error of Empty (if the vector is empty) or NoEof (if there is no eof token)
        /// will be returned.
        ///
        /// More likely, if the tokens pass are invalid Lua 5.1 code, an
        /// UnexpectedToken error will be returned.
        pub fn from_tokens(tokens: Vec<Token>) -> Result<Ast, AstError> {
            if *tokens.last().ok_or(AstError::Empty)?.token_type() != TokenType::Eof {
                Err(AstError::NoEof)
            } else {
                let mut tokens = extract_token_references(tokens);
                let mut state = ParserState::new(&tokens);
                if tokens
                    .iter()
                    .filter(|token| !token.token_type().is_trivia())
                    .count()
                    == 1
                {
                    return Ok(Ast {
                        nodes: Block::new(),
                        eof: tokens.pop().expect(
                            "(internal full-moon error) No EOF in tokens after checking for EOF.",
                        ),
                    });
                }
                if state.peek().token_type().is_trivia() {
                    state = state.advance().unwrap();
                }
                match parsers::ParseBlock.parse(state) {
                    Ok((state, block)) => {
                        if state.index == tokens.len() - 1 {
                            Ok (Ast { nodes : block , eof : tokens . pop () . expect ("(internal full-moon error) No EOF in tokens after checking for EOF.") , })
                        } else {
                            Err(AstError::UnexpectedToken {
                                token: state.peek().token.clone(),
                                additional: Some(Cow::Borrowed("leftover token")),
                            })
                        }
                    }
                    Err(InternalAstError::NoMatch) => Err(AstError::UnexpectedToken {
                        token: state.peek().token.clone(),
                        additional: None,
                    }),
                    Err(InternalAstError::UnexpectedToken { token, additional }) => {
                        Err(AstError::UnexpectedToken {
                            token: token.token,
                            additional,
                        })
                    }
                }
            }
        }
        /// Returns a new Ast with the given nodes
        pub fn with_nodes(self, nodes: Block) -> Self {
            Self { nodes, ..self }
        }
        /// Returns a new Ast with the given EOF token
        pub fn with_eof(self, eof: TokenReference) -> Self {
            Self { eof, ..self }
        }
        /// The entire code of the function
        ///
        /// ```rust
        /// # fn main() -> Result<(), Box<std::error::Error>> {
        /// assert_eq!(full_moon::parse("local x = 1; local y = 2")?.nodes().stmts().count(), 2);
        /// # Ok(())
        /// # }
        /// ```
        pub fn nodes(&self) -> &Block {
            &self.nodes
        }
        /// The entire code of the function, but mutable
        pub fn nodes_mut(&mut self) -> &mut Block {
            &mut self.nodes
        }
        /// The EOF token at the end of every Ast
        pub fn eof(&self) -> &TokenReference {
            &self.eof
        }
    }
    /// Extracts leading and trailing trivia from tokens
    pub(crate) fn extract_token_references(mut tokens: Vec<Token>) -> Vec<TokenReference> {
        let mut references = Vec::new();
        let (mut leading_trivia, mut trailing_trivia) = (Vec::new(), Vec::new());
        let mut tokens = tokens.drain(..).peekable();
        while let Some(token) = tokens.next() {
            if token.token_type().is_trivia() {
                leading_trivia.push(token);
            } else {
                while let Some(token) = tokens.peek() {
                    if token.token_type().is_trivia() {
                        let should_break = if let TokenType::Whitespace { ref characters } =
                            &*token.token_type()
                        {
                            characters.contains('\n')
                        } else {
                            false
                        };
                        trailing_trivia.push(tokens.next().unwrap());
                        if should_break {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                references.push(TokenReference {
                    leading_trivia: leading_trivia.drain(..).collect(),
                    trailing_trivia: trailing_trivia.drain(..).collect(),
                    token,
                });
            }
        }
        references
    }
}
/// Contains the `Node` trait, implemented on all nodes
pub mod node {
    use crate::{
        ast::Ast,
        private,
        tokenizer::{Position, Token, TokenReference},
    };
    use std::fmt;
    /// Used to represent nodes such as tokens or function definitions
    ///
    /// This trait is sealed and cannot be implemented for types outside of `full-moon`
    pub trait Node: private::Sealed {
        /// The start position of a node. None if can't be determined
        fn start_position(&self) -> Option<Position>;
        /// The end position of a node. None if it can't be determined
        fn end_position(&self) -> Option<Position>;
        /// Whether another node of the same type is the same as this one semantically, ignoring position
        fn similar(&self, other: &Self) -> bool
        where
            Self: Sized;
        /// The token references that comprise a node
        fn tokens(&self) -> Tokens;
        /// The full range of a node, if it has both start and end positions
        fn range(&self) -> Option<(Position, Position)> {
            Some((self.start_position()?, self.end_position()?))
        }
        /// The tokens surrounding a node that are ignored and not accessible through the node's own accessors.
        /// Use this if you want to get surrounding comments or whitespace.
        /// Returns a tuple of the leading and trailing trivia.
        fn surrounding_trivia(&self) -> (Vec<&Token>, Vec<&Token>) {
            let mut tokens = self.tokens();
            let leading = tokens.next();
            let trailing = tokens.next_back();
            (
                match leading {
                    Some(token) => token.leading_trivia().collect(),
                    None => Vec::new(),
                },
                match trailing {
                    Some(token) => token.trailing_trivia().collect(),
                    None => Vec::new(),
                },
            )
        }
    }
    pub(crate) enum TokenItem<'a> {
        MoreTokens(&'a dyn Node),
        TokenReference(&'a TokenReference),
    }
    impl fmt::Debug for TokenItem<'_> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                TokenItem::MoreTokens(_) => f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TokenItem::MoreTokens"],
                    &match () {
                        () => [],
                    },
                )),
                TokenItem::TokenReference(token) => f.write_fmt(::core::fmt::Arguments::new_v1(
                    &["TokenItem::TokenReference(", ")"],
                    &match (&token,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                )),
            }
        }
    }
    /// An iterator that iterates over the tokens of a node
    /// Returned by [`Node::tokens`]
    pub struct Tokens<'a> {
        pub(crate) items: Vec<TokenItem<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::default::Default for Tokens<'a> {
        #[inline]
        fn default() -> Tokens<'a> {
            Tokens {
                items: ::core::default::Default::default(),
            }
        }
    }
    impl<'a> Iterator for Tokens<'a> {
        type Item = &'a TokenReference;
        fn next(&mut self) -> Option<Self::Item> {
            if self.items.is_empty() {
                return None;
            }
            match self.items.remove(0) {
                TokenItem::TokenReference(reference) => Some(reference),
                TokenItem::MoreTokens(node) => {
                    let mut tokens = node.tokens();
                    tokens.items.append(&mut self.items);
                    self.items = tokens.items;
                    self.next()
                }
            }
        }
    }
    impl<'a> DoubleEndedIterator for Tokens<'a> {
        fn next_back(&mut self) -> Option<Self::Item> {
            if self.items.is_empty() {
                return None;
            }
            match self.items.pop()? {
                TokenItem::TokenReference(reference) => Some(reference),
                TokenItem::MoreTokens(node) => {
                    let mut tokens = node.tokens();
                    self.items.append(&mut tokens.items);
                    self.next_back()
                }
            }
        }
    }
    impl Node for Ast {
        fn start_position(&self) -> Option<Position> {
            self.nodes().start_position()
        }
        fn end_position(&self) -> Option<Position> {
            self.nodes().end_position()
        }
        fn similar(&self, other: &Self) -> bool {
            self.nodes().similar(other.nodes())
        }
        fn tokens(&self) -> Tokens {
            self.nodes().tokens()
        }
    }
    impl Node for () {
        fn start_position(&self) -> Option<Position> {
            None
        }
        fn end_position(&self) -> Option<Position> {
            None
        }
        fn similar(&self, _other: &Self) -> bool
        where
            Self: Sized,
        {
            true
        }
        fn tokens(&self) -> Tokens {
            Tokens { items: Vec::new() }
        }
    }
    impl<T: Node> Node for Box<T> {
        fn start_position(&self) -> Option<Position> {
            (**self).start_position()
        }
        fn end_position(&self) -> Option<Position> {
            (**self).end_position()
        }
        fn similar(&self, other: &Self) -> bool {
            (**self).similar(other)
        }
        fn tokens(&self) -> Tokens {
            (**self).tokens()
        }
    }
    impl<T: Node> Node for &T {
        fn start_position(&self) -> Option<Position> {
            (**self).start_position()
        }
        fn end_position(&self) -> Option<Position> {
            (**self).end_position()
        }
        fn similar(&self, other: &Self) -> bool {
            (**self).similar(other)
        }
        fn tokens(&self) -> Tokens {
            (**self).tokens()
        }
    }
    impl<T: Node> Node for &mut T {
        fn start_position(&self) -> Option<Position> {
            (**self).start_position()
        }
        fn end_position(&self) -> Option<Position> {
            (**self).end_position()
        }
        fn similar(&self, other: &Self) -> bool {
            (**self).similar(other)
        }
        fn tokens(&self) -> Tokens {
            (**self).tokens()
        }
    }
    impl Node for TokenReference {
        fn start_position(&self) -> Option<Position> {
            Some((**self).start_position())
        }
        fn end_position(&self) -> Option<Position> {
            Some((**self).end_position())
        }
        fn similar(&self, other: &Self) -> bool {
            *self.token_type() == *other.token_type()
        }
        fn tokens(&self) -> Tokens {
            Tokens {
                items: <[_]>::into_vec(box [TokenItem::TokenReference(self)]),
            }
        }
    }
    impl<T: Node> Node for Option<T> {
        fn start_position(&self) -> Option<Position> {
            self.as_ref().and_then(Node::start_position)
        }
        fn end_position(&self) -> Option<Position> {
            self.as_ref().and_then(Node::end_position)
        }
        fn similar(&self, other: &Self) -> bool {
            match (self.as_ref(), other.as_ref()) {
                (Some(x), Some(y)) => x.similar(y),
                (None, None) => true,
                _ => false,
            }
        }
        fn tokens(&self) -> Tokens {
            match self {
                Some(node) => node.tokens(),
                None => Tokens::default(),
            }
        }
    }
    impl<T: Node> Node for Vec<T> {
        fn start_position(&self) -> Option<Position> {
            self.first()?.start_position()
        }
        fn end_position(&self) -> Option<Position> {
            self.last()?.end_position()
        }
        fn similar(&self, other: &Self) -> bool {
            if self.len() == other.len() {
                self.iter().zip(other.iter()).all(|(x, y)| x.similar(y))
            } else {
                false
            }
        }
        fn tokens(&self) -> Tokens {
            Tokens {
                items: self
                    .iter()
                    .map(|node| node.tokens().items)
                    .flatten()
                    .collect(),
            }
        }
    }
    impl<'a, A: Node, B: Node> Node for (A, B) {
        fn start_position(&self) -> Option<Position> {
            match (self.0.start_position(), self.1.start_position()) {
                (Some(x), Some(y)) => Some(std::cmp::min(x, y)),
                (Some(x), None) => Some(x),
                (None, Some(y)) => Some(y),
                (None, None) => None,
            }
        }
        fn end_position(&self) -> Option<Position> {
            match (self.0.end_position(), self.1.end_position()) {
                (Some(x), Some(y)) => Some(std::cmp::max(x, y)),
                (Some(x), None) => Some(x),
                (None, Some(y)) => Some(y),
                (None, None) => None,
            }
        }
        fn similar(&self, other: &Self) -> bool {
            self.0.similar(&other.0) && self.1.similar(&other.1)
        }
        fn tokens(&self) -> Tokens {
            let mut items = self.0.tokens().items;
            items.append(&mut self.1.tokens().items);
            Tokens { items }
        }
    }
}
pub mod plugins {
    use crate::node::Node;
    mod default {
        use crate::{ast::*, node::Node, private};
        use super::{Plugin, PluginMod};
        use serde::{Deserialize, Serialize};
        pub struct DefaultPlugin;
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DefaultPlugin {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    struct __Visitor;
                    impl<'de> _serde::de::Visitor<'de> for __Visitor {
                        type Value = DefaultPlugin;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "unit struct DefaultPlugin",
                            )
                        }
                        #[inline]
                        fn visit_unit<__E>(self) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            _serde::export::Ok(DefaultPlugin)
                        }
                    }
                    _serde::Deserializer::deserialize_unit_struct(
                        __deserializer,
                        "DefaultPlugin",
                        __Visitor,
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DefaultPlugin {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    _serde::Serializer::serialize_unit_struct(__serializer, "DefaultPlugin")
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DefaultPlugin {
            #[inline]
            fn clone(&self) -> DefaultPlugin {
                match *self {
                    DefaultPlugin => DefaultPlugin,
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DefaultPlugin {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    DefaultPlugin => ::core::fmt::Formatter::write_str(f, "DefaultPlugin"),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for DefaultPlugin {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for DefaultPlugin {
            #[inline]
            fn eq(&self, other: &DefaultPlugin) -> bool {
                match *other {
                    DefaultPlugin => match *self {
                        DefaultPlugin => true,
                    },
                }
            }
        }
        pub enum Never {}
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Never {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {}
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "variant identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 0",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => {
                                    let __value = &_serde::export::from_utf8_lossy(__value);
                                    _serde::export::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Never>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Never;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "enum Never")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            _serde::export::Result::map(
                                _serde::de::EnumAccess::variant::<__Field>(__data),
                                |(__impossible, _)| match __impossible {},
                            )
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "Never",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Never>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Never {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {}
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Never {
            #[inline]
            fn clone(&self) -> Never {
                unsafe { ::core::intrinsics::unreachable() }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Never {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                unsafe { ::core::intrinsics::unreachable() }
            }
        }
        impl ::core::marker::StructuralPartialEq for Never {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Never {
            #[inline]
            fn eq(&self, other: &Never) -> bool {
                unsafe { ::core::intrinsics::unreachable() }
            }
        }
        impl private::Sealed for Never {}
        impl Default for Never {
            fn default() -> Self {
                {
                    ::core::panicking::panic("internal error: entered unreachable code")
                }
            }
        }
        impl Node for Never {
            fn start_position(&self) -> Option<crate::tokenizer::Position> {
                None
            }
            fn end_position(&self) -> Option<crate::tokenizer::Position> {
                None
            }
            fn similar(&self, other: &Self) -> bool
            where
                Self: Sized,
            {
                true
            }
            fn tokens(&self) -> crate::node::Tokens {
                crate::node::Tokens { items: Vec::new() }
            }
        }
        impl Plugin for DefaultPlugin {
            type BlockMod = DefaultBlockInfo;
            type CallMod = DefaultCallInfo;
            type ElseIfMod = DefaultElseIfInfo;
            type ExpressionMod = DefaultExpressionInfo;
            type FieldMod = DefaultFieldInfo;
            type LastStmtMod = DefaultLastStmtInfo;
            type ParameterMod = DefaultParameterInfo;
            type PrefixMod = DefaultPrefixInfo;
            type ReturnMod = DefaultReturnInfo;
            type SuffixMod = DefaultSuffixInfo;
            type ValueMod = DefaultValueInfo;
            type VarMod = DefaultVarInfo;
        }
        pub struct DefaultBlockInfo;
        impl PluginMod<Block<DefaultPlugin>> for DefaultBlockInfo {
            type NodeInfo = ();
        }
        pub struct DefaultCallInfo;
        impl PluginMod<Call<DefaultPlugin>> for DefaultCallInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultElseIfInfo;
        impl PluginMod<ElseIf<DefaultPlugin>> for DefaultElseIfInfo {
            type NodeInfo = ();
        }
        pub struct DefaultExpressionInfo;
        impl PluginMod<Expression<DefaultPlugin>> for DefaultExpressionInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultFieldInfo;
        impl PluginMod<Field<DefaultPlugin>> for DefaultFieldInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultLastStmtInfo;
        impl PluginMod<LastStmt<DefaultPlugin>> for DefaultLastStmtInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultParameterInfo;
        impl PluginMod<Parameter<DefaultPlugin>> for DefaultParameterInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultPrefixInfo;
        impl PluginMod<Prefix<DefaultPlugin>> for DefaultPrefixInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultReturnInfo;
        impl PluginMod<Return<DefaultPlugin>> for DefaultReturnInfo {
            type NodeInfo = ();
        }
        pub struct DefaultSuffixInfo;
        impl PluginMod<Suffix<DefaultPlugin>> for DefaultSuffixInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultValueInfo;
        impl PluginMod<Value<DefaultPlugin>> for DefaultValueInfo {
            type NodeInfo = Never;
        }
        pub struct DefaultVarInfo;
        impl PluginMod<Var<DefaultPlugin>> for DefaultVarInfo {
            type NodeInfo = Never;
        }
    }
    mod plugin {
        use std::fmt::Debug;
        use crate::{ast::*, node::Node};
        #[cfg(feature = "serde")]
        pub trait ConditionalSerialize: serde::Serialize {}
        #[cfg(feature = "serde")]
        impl<T> ConditionalSerialize for T where T: serde::Serialize {}
        #[cfg(feature = "serde")]
        pub trait ConditionalDeserialize: serde::de::DeserializeOwned {}
        #[cfg(feature = "serde")]
        impl<T> ConditionalDeserialize for T where T: serde::de::DeserializeOwned {}
        pub trait Plugin: Clone + Debug + PartialEq {
            type BlockMod: PluginMod<Block<Self>>;
            type CallMod: PluginMod<Call<Self>>;
            type ElseIfMod: PluginMod<ElseIf<Self>>;
            type ExpressionMod: PluginMod<Expression<Self>>;
            type FieldMod: PluginMod<Field<Self>>;
            type FunctionArgsMod: PluginMod<FunctionArgs<Self>>;
            type IndexMod: PluginMod<Index<Self>>;
            type LastStmtMod: PluginMod<LastStmt<Self>>;
            type ParameterMod: PluginMod<Parameter<Self>>;
            type PrefixMod: PluginMod<Prefix<Self>>;
            type ReturnMod: PluginMod<Return<Self>>;
            type StmtMod: PluginMod<Stmt<Self>>;
            type SuffixMod: PluginMod<Suffix<Self>>;
            type ValueMod: PluginMod<Value<Self>>;
            type VarMod: PluginMod<Var<Self>>;
        }
        pub trait PluginInfo:
            Clone
            + Debug
            + Default
            + PartialEq
            + Node
            + ConditionalDeserialize
            + ConditionalSerialize
        {
        }
        impl<T> PluginInfo for T where
            T: Clone
                + Debug
                + Default
                + PartialEq
                + Node
                + ConditionalDeserialize
                + ConditionalSerialize
        {
        }
        pub trait PluginMod<T> {
            type NodeInfo: PluginInfo;
        }
    }
    pub use default::DefaultPlugin;
    pub use plugin::*;
}
/// Used for tokenizing, the process of converting the code to individual tokens.
/// Useful for getting symbols and manually tokenizing without going using an AST.
pub mod tokenizer {
    use crate::{
        plugins::Plugin,
        visitors::{Visit, VisitMut, Visitor, VisitorMut},
        ShortString,
    };
    use full_moon_derive::symbols;
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};
    use std::{cmp::Ordering, fmt, str::FromStr};
    /// A literal symbol, used for both words important to syntax (like while) and operators (like +)
    #[non_exhaustive]
    pub enum Symbol {
        #[serde(rename = "and")]
        #[allow(missing_docs)]
        And,
        #[serde(rename = "break")]
        #[allow(missing_docs)]
        Break,
        #[serde(rename = "do")]
        #[allow(missing_docs)]
        Do,
        #[serde(rename = "elseif")]
        #[allow(missing_docs)]
        ElseIf,
        #[serde(rename = "else")]
        #[allow(missing_docs)]
        Else,
        #[serde(rename = "end")]
        #[allow(missing_docs)]
        End,
        #[serde(rename = "false")]
        #[allow(missing_docs)]
        False,
        #[serde(rename = "for")]
        #[allow(missing_docs)]
        For,
        #[serde(rename = "function")]
        #[allow(missing_docs)]
        Function,
        #[serde(rename = "if")]
        #[allow(missing_docs)]
        If,
        #[serde(rename = "in")]
        #[allow(missing_docs)]
        In,
        #[serde(rename = "local")]
        #[allow(missing_docs)]
        Local,
        #[serde(rename = "nil")]
        #[allow(missing_docs)]
        Nil,
        #[serde(rename = "not")]
        #[allow(missing_docs)]
        Not,
        #[serde(rename = "or")]
        #[allow(missing_docs)]
        Or,
        #[serde(rename = "repeat")]
        #[allow(missing_docs)]
        Repeat,
        #[serde(rename = "return")]
        #[allow(missing_docs)]
        Return,
        #[serde(rename = "then")]
        #[allow(missing_docs)]
        Then,
        #[serde(rename = "true")]
        #[allow(missing_docs)]
        True,
        #[serde(rename = "until")]
        #[allow(missing_docs)]
        Until,
        #[serde(rename = "while")]
        #[allow(missing_docs)]
        While,
        #[serde(rename = "-=")]
        #[allow(missing_docs)]
        MinusEqual,
        #[serde(rename = "*=")]
        #[allow(missing_docs)]
        StarEqual,
        #[serde(rename = "/=")]
        #[allow(missing_docs)]
        SlashEqual,
        #[serde(rename = "%=")]
        #[allow(missing_docs)]
        PercentEqual,
        #[serde(rename = "^=")]
        #[allow(missing_docs)]
        CaretEqual,
        #[serde(rename = "..=")]
        #[allow(missing_docs)]
        TwoDotsEqual,
        #[serde(rename = "^")]
        #[allow(missing_docs)]
        Caret,
        #[serde(rename = ":")]
        #[allow(missing_docs)]
        Colon,
        #[serde(rename = ",")]
        #[allow(missing_docs)]
        Comma,
        #[serde(rename = "...")]
        #[allow(missing_docs)]
        Ellipse,
        #[serde(rename = "..")]
        #[allow(missing_docs)]
        TwoDots,
        #[serde(rename = ".")]
        #[allow(missing_docs)]
        Dot,
        #[serde(rename = "==")]
        #[allow(missing_docs)]
        TwoEqual,
        #[serde(rename = "=")]
        #[allow(missing_docs)]
        Equal,
        #[serde(rename = ">=")]
        #[allow(missing_docs)]
        GreaterThanEqual,
        #[serde(rename = ">")]
        #[allow(missing_docs)]
        GreaterThan,
        #[serde(rename = "#")]
        #[allow(missing_docs)]
        Hash,
        #[serde(rename = "{")]
        #[allow(missing_docs)]
        LeftBrace,
        #[serde(rename = "[")]
        #[allow(missing_docs)]
        LeftBracket,
        #[serde(rename = "(")]
        #[allow(missing_docs)]
        LeftParen,
        #[serde(rename = "<=")]
        #[allow(missing_docs)]
        LessThanEqual,
        #[serde(rename = "<")]
        #[allow(missing_docs)]
        LessThan,
        #[serde(rename = "-")]
        #[allow(missing_docs)]
        Minus,
        #[serde(rename = "%")]
        #[allow(missing_docs)]
        Percent,
        #[serde(rename = "+")]
        #[allow(missing_docs)]
        Plus,
        #[serde(rename = "}")]
        #[allow(missing_docs)]
        RightBrace,
        #[serde(rename = "]")]
        #[allow(missing_docs)]
        RightBracket,
        #[serde(rename = ")")]
        #[allow(missing_docs)]
        RightParen,
        #[serde(rename = ";")]
        #[allow(missing_docs)]
        Semicolon,
        #[serde(rename = "/")]
        #[allow(missing_docs)]
        Slash,
        #[serde(rename = "*")]
        #[allow(missing_docs)]
        Star,
        #[serde(rename = "~=")]
        #[allow(missing_docs)]
        TildeEqual,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Symbol {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __field32,
                    __field33,
                    __field34,
                    __field35,
                    __field36,
                    __field37,
                    __field38,
                    __field39,
                    __field40,
                    __field41,
                    __field42,
                    __field43,
                    __field44,
                    __field45,
                    __field46,
                    __field47,
                    __field48,
                    __field49,
                    __field50,
                    __field51,
                    __field52,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            12u64 => _serde::export::Ok(__Field::__field12),
                            13u64 => _serde::export::Ok(__Field::__field13),
                            14u64 => _serde::export::Ok(__Field::__field14),
                            15u64 => _serde::export::Ok(__Field::__field15),
                            16u64 => _serde::export::Ok(__Field::__field16),
                            17u64 => _serde::export::Ok(__Field::__field17),
                            18u64 => _serde::export::Ok(__Field::__field18),
                            19u64 => _serde::export::Ok(__Field::__field19),
                            20u64 => _serde::export::Ok(__Field::__field20),
                            21u64 => _serde::export::Ok(__Field::__field21),
                            22u64 => _serde::export::Ok(__Field::__field22),
                            23u64 => _serde::export::Ok(__Field::__field23),
                            24u64 => _serde::export::Ok(__Field::__field24),
                            25u64 => _serde::export::Ok(__Field::__field25),
                            26u64 => _serde::export::Ok(__Field::__field26),
                            27u64 => _serde::export::Ok(__Field::__field27),
                            28u64 => _serde::export::Ok(__Field::__field28),
                            29u64 => _serde::export::Ok(__Field::__field29),
                            30u64 => _serde::export::Ok(__Field::__field30),
                            31u64 => _serde::export::Ok(__Field::__field31),
                            32u64 => _serde::export::Ok(__Field::__field32),
                            33u64 => _serde::export::Ok(__Field::__field33),
                            34u64 => _serde::export::Ok(__Field::__field34),
                            35u64 => _serde::export::Ok(__Field::__field35),
                            36u64 => _serde::export::Ok(__Field::__field36),
                            37u64 => _serde::export::Ok(__Field::__field37),
                            38u64 => _serde::export::Ok(__Field::__field38),
                            39u64 => _serde::export::Ok(__Field::__field39),
                            40u64 => _serde::export::Ok(__Field::__field40),
                            41u64 => _serde::export::Ok(__Field::__field41),
                            42u64 => _serde::export::Ok(__Field::__field42),
                            43u64 => _serde::export::Ok(__Field::__field43),
                            44u64 => _serde::export::Ok(__Field::__field44),
                            45u64 => _serde::export::Ok(__Field::__field45),
                            46u64 => _serde::export::Ok(__Field::__field46),
                            47u64 => _serde::export::Ok(__Field::__field47),
                            48u64 => _serde::export::Ok(__Field::__field48),
                            49u64 => _serde::export::Ok(__Field::__field49),
                            50u64 => _serde::export::Ok(__Field::__field50),
                            51u64 => _serde::export::Ok(__Field::__field51),
                            52u64 => _serde::export::Ok(__Field::__field52),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 53",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "and" => _serde::export::Ok(__Field::__field0),
                            "break" => _serde::export::Ok(__Field::__field1),
                            "do" => _serde::export::Ok(__Field::__field2),
                            "elseif" => _serde::export::Ok(__Field::__field3),
                            "else" => _serde::export::Ok(__Field::__field4),
                            "end" => _serde::export::Ok(__Field::__field5),
                            "false" => _serde::export::Ok(__Field::__field6),
                            "for" => _serde::export::Ok(__Field::__field7),
                            "function" => _serde::export::Ok(__Field::__field8),
                            "if" => _serde::export::Ok(__Field::__field9),
                            "in" => _serde::export::Ok(__Field::__field10),
                            "local" => _serde::export::Ok(__Field::__field11),
                            "nil" => _serde::export::Ok(__Field::__field12),
                            "not" => _serde::export::Ok(__Field::__field13),
                            "or" => _serde::export::Ok(__Field::__field14),
                            "repeat" => _serde::export::Ok(__Field::__field15),
                            "return" => _serde::export::Ok(__Field::__field16),
                            "then" => _serde::export::Ok(__Field::__field17),
                            "true" => _serde::export::Ok(__Field::__field18),
                            "until" => _serde::export::Ok(__Field::__field19),
                            "while" => _serde::export::Ok(__Field::__field20),
                            "-=" => _serde::export::Ok(__Field::__field21),
                            "*=" => _serde::export::Ok(__Field::__field22),
                            "/=" => _serde::export::Ok(__Field::__field23),
                            "%=" => _serde::export::Ok(__Field::__field24),
                            "^=" => _serde::export::Ok(__Field::__field25),
                            "..=" => _serde::export::Ok(__Field::__field26),
                            "^" => _serde::export::Ok(__Field::__field27),
                            ":" => _serde::export::Ok(__Field::__field28),
                            "," => _serde::export::Ok(__Field::__field29),
                            "..." => _serde::export::Ok(__Field::__field30),
                            ".." => _serde::export::Ok(__Field::__field31),
                            "." => _serde::export::Ok(__Field::__field32),
                            "==" => _serde::export::Ok(__Field::__field33),
                            "=" => _serde::export::Ok(__Field::__field34),
                            ">=" => _serde::export::Ok(__Field::__field35),
                            ">" => _serde::export::Ok(__Field::__field36),
                            "#" => _serde::export::Ok(__Field::__field37),
                            "{" => _serde::export::Ok(__Field::__field38),
                            "[" => _serde::export::Ok(__Field::__field39),
                            "(" => _serde::export::Ok(__Field::__field40),
                            "<=" => _serde::export::Ok(__Field::__field41),
                            "<" => _serde::export::Ok(__Field::__field42),
                            "-" => _serde::export::Ok(__Field::__field43),
                            "%" => _serde::export::Ok(__Field::__field44),
                            "+" => _serde::export::Ok(__Field::__field45),
                            "}" => _serde::export::Ok(__Field::__field46),
                            "]" => _serde::export::Ok(__Field::__field47),
                            ")" => _serde::export::Ok(__Field::__field48),
                            ";" => _serde::export::Ok(__Field::__field49),
                            "/" => _serde::export::Ok(__Field::__field50),
                            "*" => _serde::export::Ok(__Field::__field51),
                            "~=" => _serde::export::Ok(__Field::__field52),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"and" => _serde::export::Ok(__Field::__field0),
                            b"break" => _serde::export::Ok(__Field::__field1),
                            b"do" => _serde::export::Ok(__Field::__field2),
                            b"elseif" => _serde::export::Ok(__Field::__field3),
                            b"else" => _serde::export::Ok(__Field::__field4),
                            b"end" => _serde::export::Ok(__Field::__field5),
                            b"false" => _serde::export::Ok(__Field::__field6),
                            b"for" => _serde::export::Ok(__Field::__field7),
                            b"function" => _serde::export::Ok(__Field::__field8),
                            b"if" => _serde::export::Ok(__Field::__field9),
                            b"in" => _serde::export::Ok(__Field::__field10),
                            b"local" => _serde::export::Ok(__Field::__field11),
                            b"nil" => _serde::export::Ok(__Field::__field12),
                            b"not" => _serde::export::Ok(__Field::__field13),
                            b"or" => _serde::export::Ok(__Field::__field14),
                            b"repeat" => _serde::export::Ok(__Field::__field15),
                            b"return" => _serde::export::Ok(__Field::__field16),
                            b"then" => _serde::export::Ok(__Field::__field17),
                            b"true" => _serde::export::Ok(__Field::__field18),
                            b"until" => _serde::export::Ok(__Field::__field19),
                            b"while" => _serde::export::Ok(__Field::__field20),
                            b"-=" => _serde::export::Ok(__Field::__field21),
                            b"*=" => _serde::export::Ok(__Field::__field22),
                            b"/=" => _serde::export::Ok(__Field::__field23),
                            b"%=" => _serde::export::Ok(__Field::__field24),
                            b"^=" => _serde::export::Ok(__Field::__field25),
                            b"..=" => _serde::export::Ok(__Field::__field26),
                            b"^" => _serde::export::Ok(__Field::__field27),
                            b":" => _serde::export::Ok(__Field::__field28),
                            b"," => _serde::export::Ok(__Field::__field29),
                            b"..." => _serde::export::Ok(__Field::__field30),
                            b".." => _serde::export::Ok(__Field::__field31),
                            b"." => _serde::export::Ok(__Field::__field32),
                            b"==" => _serde::export::Ok(__Field::__field33),
                            b"=" => _serde::export::Ok(__Field::__field34),
                            b">=" => _serde::export::Ok(__Field::__field35),
                            b">" => _serde::export::Ok(__Field::__field36),
                            b"#" => _serde::export::Ok(__Field::__field37),
                            b"{" => _serde::export::Ok(__Field::__field38),
                            b"[" => _serde::export::Ok(__Field::__field39),
                            b"(" => _serde::export::Ok(__Field::__field40),
                            b"<=" => _serde::export::Ok(__Field::__field41),
                            b"<" => _serde::export::Ok(__Field::__field42),
                            b"-" => _serde::export::Ok(__Field::__field43),
                            b"%" => _serde::export::Ok(__Field::__field44),
                            b"+" => _serde::export::Ok(__Field::__field45),
                            b"}" => _serde::export::Ok(__Field::__field46),
                            b"]" => _serde::export::Ok(__Field::__field47),
                            b")" => _serde::export::Ok(__Field::__field48),
                            b";" => _serde::export::Ok(__Field::__field49),
                            b"/" => _serde::export::Ok(__Field::__field50),
                            b"*" => _serde::export::Ok(__Field::__field51),
                            b"~=" => _serde::export::Ok(__Field::__field52),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Symbol>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Symbol;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Symbol")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::And)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Break)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Do)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::ElseIf)
                            }
                            (__Field::__field4, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Else)
                            }
                            (__Field::__field5, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::End)
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::False)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::For)
                            }
                            (__Field::__field8, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Function)
                            }
                            (__Field::__field9, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::If)
                            }
                            (__Field::__field10, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::In)
                            }
                            (__Field::__field11, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Local)
                            }
                            (__Field::__field12, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Nil)
                            }
                            (__Field::__field13, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Not)
                            }
                            (__Field::__field14, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Or)
                            }
                            (__Field::__field15, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Repeat)
                            }
                            (__Field::__field16, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Return)
                            }
                            (__Field::__field17, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Then)
                            }
                            (__Field::__field18, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::True)
                            }
                            (__Field::__field19, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Until)
                            }
                            (__Field::__field20, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::While)
                            }
                            (__Field::__field21, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::MinusEqual)
                            }
                            (__Field::__field22, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::StarEqual)
                            }
                            (__Field::__field23, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::SlashEqual)
                            }
                            (__Field::__field24, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::PercentEqual)
                            }
                            (__Field::__field25, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::CaretEqual)
                            }
                            (__Field::__field26, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TwoDotsEqual)
                            }
                            (__Field::__field27, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Caret)
                            }
                            (__Field::__field28, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Colon)
                            }
                            (__Field::__field29, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Comma)
                            }
                            (__Field::__field30, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Ellipse)
                            }
                            (__Field::__field31, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TwoDots)
                            }
                            (__Field::__field32, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Dot)
                            }
                            (__Field::__field33, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TwoEqual)
                            }
                            (__Field::__field34, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Equal)
                            }
                            (__Field::__field35, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::GreaterThanEqual)
                            }
                            (__Field::__field36, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::GreaterThan)
                            }
                            (__Field::__field37, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Hash)
                            }
                            (__Field::__field38, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftBrace)
                            }
                            (__Field::__field39, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftBracket)
                            }
                            (__Field::__field40, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftParen)
                            }
                            (__Field::__field41, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LessThanEqual)
                            }
                            (__Field::__field42, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LessThan)
                            }
                            (__Field::__field43, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Minus)
                            }
                            (__Field::__field44, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Percent)
                            }
                            (__Field::__field45, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Plus)
                            }
                            (__Field::__field46, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightBrace)
                            }
                            (__Field::__field47, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightBracket)
                            }
                            (__Field::__field48, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightParen)
                            }
                            (__Field::__field49, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Semicolon)
                            }
                            (__Field::__field50, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Slash)
                            }
                            (__Field::__field51, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Star)
                            }
                            (__Field::__field52, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TildeEqual)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "and", "break", "do", "elseif", "else", "end", "false", "for", "function",
                    "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true",
                    "until", "while", "-=", "*=", "/=", "%=", "^=", "..=", "^", ":", ",", "...",
                    "..", ".", "==", "=", ">=", ">", "#", "{", "[", "(", "<=", "<", "-", "%", "+",
                    "}", "]", ")", ";", "/", "*", "~=",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Symbol",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Symbol>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Symbol {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Symbol::And => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        0u32,
                        "and",
                    ),
                    Symbol::Break => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        1u32,
                        "break",
                    ),
                    Symbol::Do => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        2u32,
                        "do",
                    ),
                    Symbol::ElseIf => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        3u32,
                        "elseif",
                    ),
                    Symbol::Else => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        4u32,
                        "else",
                    ),
                    Symbol::End => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        5u32,
                        "end",
                    ),
                    Symbol::False => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        6u32,
                        "false",
                    ),
                    Symbol::For => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        7u32,
                        "for",
                    ),
                    Symbol::Function => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        8u32,
                        "function",
                    ),
                    Symbol::If => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        9u32,
                        "if",
                    ),
                    Symbol::In => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        10u32,
                        "in",
                    ),
                    Symbol::Local => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        11u32,
                        "local",
                    ),
                    Symbol::Nil => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        12u32,
                        "nil",
                    ),
                    Symbol::Not => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        13u32,
                        "not",
                    ),
                    Symbol::Or => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        14u32,
                        "or",
                    ),
                    Symbol::Repeat => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        15u32,
                        "repeat",
                    ),
                    Symbol::Return => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        16u32,
                        "return",
                    ),
                    Symbol::Then => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        17u32,
                        "then",
                    ),
                    Symbol::True => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        18u32,
                        "true",
                    ),
                    Symbol::Until => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        19u32,
                        "until",
                    ),
                    Symbol::While => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        20u32,
                        "while",
                    ),
                    Symbol::MinusEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        21u32,
                        "-=",
                    ),
                    Symbol::StarEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        22u32,
                        "*=",
                    ),
                    Symbol::SlashEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        23u32,
                        "/=",
                    ),
                    Symbol::PercentEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        24u32,
                        "%=",
                    ),
                    Symbol::CaretEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        25u32,
                        "^=",
                    ),
                    Symbol::TwoDotsEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        26u32,
                        "..=",
                    ),
                    Symbol::Caret => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        27u32,
                        "^",
                    ),
                    Symbol::Colon => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        28u32,
                        ":",
                    ),
                    Symbol::Comma => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        29u32,
                        ",",
                    ),
                    Symbol::Ellipse => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        30u32,
                        "...",
                    ),
                    Symbol::TwoDots => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        31u32,
                        "..",
                    ),
                    Symbol::Dot => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        32u32,
                        ".",
                    ),
                    Symbol::TwoEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        33u32,
                        "==",
                    ),
                    Symbol::Equal => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        34u32,
                        "=",
                    ),
                    Symbol::GreaterThanEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        35u32,
                        ">=",
                    ),
                    Symbol::GreaterThan => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        36u32,
                        ">",
                    ),
                    Symbol::Hash => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        37u32,
                        "#",
                    ),
                    Symbol::LeftBrace => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        38u32,
                        "{",
                    ),
                    Symbol::LeftBracket => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        39u32,
                        "[",
                    ),
                    Symbol::LeftParen => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        40u32,
                        "(",
                    ),
                    Symbol::LessThanEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        41u32,
                        "<=",
                    ),
                    Symbol::LessThan => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        42u32,
                        "<",
                    ),
                    Symbol::Minus => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        43u32,
                        "-",
                    ),
                    Symbol::Percent => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        44u32,
                        "%",
                    ),
                    Symbol::Plus => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        45u32,
                        "+",
                    ),
                    Symbol::RightBrace => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        46u32,
                        "}",
                    ),
                    Symbol::RightBracket => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        47u32,
                        "]",
                    ),
                    Symbol::RightParen => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        48u32,
                        ")",
                    ),
                    Symbol::Semicolon => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        49u32,
                        ";",
                    ),
                    Symbol::Slash => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        50u32,
                        "/",
                    ),
                    Symbol::Star => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        51u32,
                        "*",
                    ),
                    Symbol::TildeEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        52u32,
                        "~=",
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Symbol {
        #[inline]
        fn clone(&self) -> Symbol {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Symbol {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Symbol {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Symbol::And,) => ::core::fmt::Formatter::write_str(f, "And"),
                (&Symbol::Break,) => ::core::fmt::Formatter::write_str(f, "Break"),
                (&Symbol::Do,) => ::core::fmt::Formatter::write_str(f, "Do"),
                (&Symbol::ElseIf,) => ::core::fmt::Formatter::write_str(f, "ElseIf"),
                (&Symbol::Else,) => ::core::fmt::Formatter::write_str(f, "Else"),
                (&Symbol::End,) => ::core::fmt::Formatter::write_str(f, "End"),
                (&Symbol::False,) => ::core::fmt::Formatter::write_str(f, "False"),
                (&Symbol::For,) => ::core::fmt::Formatter::write_str(f, "For"),
                (&Symbol::Function,) => ::core::fmt::Formatter::write_str(f, "Function"),
                (&Symbol::If,) => ::core::fmt::Formatter::write_str(f, "If"),
                (&Symbol::In,) => ::core::fmt::Formatter::write_str(f, "In"),
                (&Symbol::Local,) => ::core::fmt::Formatter::write_str(f, "Local"),
                (&Symbol::Nil,) => ::core::fmt::Formatter::write_str(f, "Nil"),
                (&Symbol::Not,) => ::core::fmt::Formatter::write_str(f, "Not"),
                (&Symbol::Or,) => ::core::fmt::Formatter::write_str(f, "Or"),
                (&Symbol::Repeat,) => ::core::fmt::Formatter::write_str(f, "Repeat"),
                (&Symbol::Return,) => ::core::fmt::Formatter::write_str(f, "Return"),
                (&Symbol::Then,) => ::core::fmt::Formatter::write_str(f, "Then"),
                (&Symbol::True,) => ::core::fmt::Formatter::write_str(f, "True"),
                (&Symbol::Until,) => ::core::fmt::Formatter::write_str(f, "Until"),
                (&Symbol::While,) => ::core::fmt::Formatter::write_str(f, "While"),
                (&Symbol::MinusEqual,) => ::core::fmt::Formatter::write_str(f, "MinusEqual"),
                (&Symbol::StarEqual,) => ::core::fmt::Formatter::write_str(f, "StarEqual"),
                (&Symbol::SlashEqual,) => ::core::fmt::Formatter::write_str(f, "SlashEqual"),
                (&Symbol::PercentEqual,) => ::core::fmt::Formatter::write_str(f, "PercentEqual"),
                (&Symbol::CaretEqual,) => ::core::fmt::Formatter::write_str(f, "CaretEqual"),
                (&Symbol::TwoDotsEqual,) => ::core::fmt::Formatter::write_str(f, "TwoDotsEqual"),
                (&Symbol::Caret,) => ::core::fmt::Formatter::write_str(f, "Caret"),
                (&Symbol::Colon,) => ::core::fmt::Formatter::write_str(f, "Colon"),
                (&Symbol::Comma,) => ::core::fmt::Formatter::write_str(f, "Comma"),
                (&Symbol::Ellipse,) => ::core::fmt::Formatter::write_str(f, "Ellipse"),
                (&Symbol::TwoDots,) => ::core::fmt::Formatter::write_str(f, "TwoDots"),
                (&Symbol::Dot,) => ::core::fmt::Formatter::write_str(f, "Dot"),
                (&Symbol::TwoEqual,) => ::core::fmt::Formatter::write_str(f, "TwoEqual"),
                (&Symbol::Equal,) => ::core::fmt::Formatter::write_str(f, "Equal"),
                (&Symbol::GreaterThanEqual,) => {
                    ::core::fmt::Formatter::write_str(f, "GreaterThanEqual")
                }
                (&Symbol::GreaterThan,) => ::core::fmt::Formatter::write_str(f, "GreaterThan"),
                (&Symbol::Hash,) => ::core::fmt::Formatter::write_str(f, "Hash"),
                (&Symbol::LeftBrace,) => ::core::fmt::Formatter::write_str(f, "LeftBrace"),
                (&Symbol::LeftBracket,) => ::core::fmt::Formatter::write_str(f, "LeftBracket"),
                (&Symbol::LeftParen,) => ::core::fmt::Formatter::write_str(f, "LeftParen"),
                (&Symbol::LessThanEqual,) => ::core::fmt::Formatter::write_str(f, "LessThanEqual"),
                (&Symbol::LessThan,) => ::core::fmt::Formatter::write_str(f, "LessThan"),
                (&Symbol::Minus,) => ::core::fmt::Formatter::write_str(f, "Minus"),
                (&Symbol::Percent,) => ::core::fmt::Formatter::write_str(f, "Percent"),
                (&Symbol::Plus,) => ::core::fmt::Formatter::write_str(f, "Plus"),
                (&Symbol::RightBrace,) => ::core::fmt::Formatter::write_str(f, "RightBrace"),
                (&Symbol::RightBracket,) => ::core::fmt::Formatter::write_str(f, "RightBracket"),
                (&Symbol::RightParen,) => ::core::fmt::Formatter::write_str(f, "RightParen"),
                (&Symbol::Semicolon,) => ::core::fmt::Formatter::write_str(f, "Semicolon"),
                (&Symbol::Slash,) => ::core::fmt::Formatter::write_str(f, "Slash"),
                (&Symbol::Star,) => ::core::fmt::Formatter::write_str(f, "Star"),
                (&Symbol::TildeEqual,) => ::core::fmt::Formatter::write_str(f, "TildeEqual"),
            }
        }
    }
    impl ::core::marker::StructuralEq for Symbol {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Symbol {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for Symbol {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Symbol {
        #[inline]
        fn eq(&self, other: &Symbol) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl<'a> fmt::Display for Symbol {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                Symbol::And => "and",
                Symbol::Break => "break",
                Symbol::Do => "do",
                Symbol::ElseIf => "elseif",
                Symbol::Else => "else",
                Symbol::End => "end",
                Symbol::False => "false",
                Symbol::For => "for",
                Symbol::Function => "function",
                Symbol::If => "if",
                Symbol::In => "in",
                Symbol::Local => "local",
                Symbol::Nil => "nil",
                Symbol::Not => "not",
                Symbol::Or => "or",
                Symbol::Repeat => "repeat",
                Symbol::Return => "return",
                Symbol::Then => "then",
                Symbol::True => "true",
                Symbol::Until => "until",
                Symbol::While => "while",
                Symbol::MinusEqual => "-=",
                Symbol::StarEqual => "*=",
                Symbol::SlashEqual => "/=",
                Symbol::PercentEqual => "%=",
                Symbol::CaretEqual => "^=",
                Symbol::TwoDotsEqual => "..=",
                Symbol::Caret => "^",
                Symbol::Colon => ":",
                Symbol::Comma => ",",
                Symbol::Ellipse => "...",
                Symbol::TwoDots => "..",
                Symbol::Dot => ".",
                Symbol::TwoEqual => "==",
                Symbol::Equal => "=",
                Symbol::GreaterThanEqual => ">=",
                Symbol::GreaterThan => ">",
                Symbol::Hash => "#",
                Symbol::LeftBrace => "{",
                Symbol::LeftBracket => "[",
                Symbol::LeftParen => "(",
                Symbol::LessThanEqual => "<=",
                Symbol::LessThan => "<",
                Symbol::Minus => "-",
                Symbol::Percent => "%",
                Symbol::Plus => "+",
                Symbol::RightBrace => "}",
                Symbol::RightBracket => "]",
                Symbol::RightParen => ")",
                Symbol::Semicolon => ";",
                Symbol::Slash => "/",
                Symbol::Star => "*",
                Symbol::TildeEqual => "~=",
            }
            .fmt(formatter)
        }
    }
    impl FromStr for Symbol {
        type Err = ();
        fn from_str(string: &str) -> Result<Self, Self::Err> {
            Ok(match string {
                "and" => Symbol::And,
                "break" => Symbol::Break,
                "do" => Symbol::Do,
                "elseif" => Symbol::ElseIf,
                "else" => Symbol::Else,
                "end" => Symbol::End,
                "false" => Symbol::False,
                "for" => Symbol::For,
                "function" => Symbol::Function,
                "if" => Symbol::If,
                "in" => Symbol::In,
                "local" => Symbol::Local,
                "nil" => Symbol::Nil,
                "not" => Symbol::Not,
                "or" => Symbol::Or,
                "repeat" => Symbol::Repeat,
                "return" => Symbol::Return,
                "then" => Symbol::Then,
                "true" => Symbol::True,
                "until" => Symbol::Until,
                "while" => Symbol::While,
                "-=" => Symbol::MinusEqual,
                "*=" => Symbol::StarEqual,
                "/=" => Symbol::SlashEqual,
                "%=" => Symbol::PercentEqual,
                "^=" => Symbol::CaretEqual,
                "..=" => Symbol::TwoDotsEqual,
                "^" => Symbol::Caret,
                ":" => Symbol::Colon,
                "," => Symbol::Comma,
                "..." => Symbol::Ellipse,
                ".." => Symbol::TwoDots,
                "." => Symbol::Dot,
                "==" => Symbol::TwoEqual,
                "=" => Symbol::Equal,
                ">=" => Symbol::GreaterThanEqual,
                ">" => Symbol::GreaterThan,
                "#" => Symbol::Hash,
                "{" => Symbol::LeftBrace,
                "[" => Symbol::LeftBracket,
                "(" => Symbol::LeftParen,
                "<=" => Symbol::LessThanEqual,
                "<" => Symbol::LessThan,
                "-" => Symbol::Minus,
                "%" => Symbol::Percent,
                "+" => Symbol::Plus,
                "}" => Symbol::RightBrace,
                "]" => Symbol::RightBracket,
                ")" => Symbol::RightParen,
                ";" => Symbol::Semicolon,
                "/" => Symbol::Slash,
                "*" => Symbol::Star,
                "~=" => Symbol::TildeEqual,
                _ => return Err(()),
            })
        }
    }
    fn parse_keyword(identifier: &str) -> Option<Symbol> {
        Some(match identifier {
            "and" => Symbol::And,
            "break" => Symbol::Break,
            "do" => Symbol::Do,
            "elseif" => Symbol::ElseIf,
            "else" => Symbol::Else,
            "end" => Symbol::End,
            "false" => Symbol::False,
            "for" => Symbol::For,
            "function" => Symbol::Function,
            "if" => Symbol::If,
            "in" => Symbol::In,
            "local" => Symbol::Local,
            "nil" => Symbol::Nil,
            "not" => Symbol::Not,
            "or" => Symbol::Or,
            "repeat" => Symbol::Repeat,
            "return" => Symbol::Return,
            "then" => Symbol::Then,
            "true" => Symbol::True,
            "until" => Symbol::Until,
            "while" => Symbol::While,
            _ => return None,
        })
    }
    trait ParseSymbol<'input> {
        fn parse_symbol(self, pos: usize) -> peg::RuleResult<Symbol>;
    }
    impl<'input> ParseSymbol<'input> for &'input str {
        fn parse_symbol(self: Self, pos: usize) -> peg::RuleResult<Symbol> {
            for (symbol, string) in &[
                { (Symbol::MinusEqual, "-=") },
                { (Symbol::StarEqual, "*=") },
                { (Symbol::SlashEqual, "/=") },
                { (Symbol::PercentEqual, "%=") },
                { (Symbol::CaretEqual, "^=") },
                { (Symbol::TwoDotsEqual, "..=") },
                { (Symbol::Caret, "^") },
                { (Symbol::Colon, ":") },
                { (Symbol::Comma, ",") },
                { (Symbol::Ellipse, "...") },
                { (Symbol::TwoDots, "..") },
                { (Symbol::Dot, ".") },
                { (Symbol::TwoEqual, "==") },
                { (Symbol::Equal, "=") },
                { (Symbol::GreaterThanEqual, ">=") },
                { (Symbol::GreaterThan, ">") },
                { (Symbol::Hash, "#") },
                { (Symbol::LeftBrace, "{") },
                { (Symbol::LeftBracket, "[") },
                { (Symbol::LeftParen, "(") },
                { (Symbol::LessThanEqual, "<=") },
                { (Symbol::LessThan, "<") },
                { (Symbol::Minus, "-") },
                { (Symbol::Percent, "%") },
                { (Symbol::Plus, "+") },
                { (Symbol::RightBrace, "}") },
                { (Symbol::RightBracket, "]") },
                { (Symbol::RightParen, ")") },
                { (Symbol::Semicolon, ";") },
                { (Symbol::Slash, "/") },
                { (Symbol::Star, "*") },
                { (Symbol::TildeEqual, "~=") },
            ] {
                if self[pos..].starts_with(string) {
                    return peg::RuleResult::Matched(pos + string.len(), *symbol);
                }
            }
            peg::RuleResult::Failed
        }
    }
    /// The possible errors that can happen while tokenizing.
    pub enum TokenizerErrorType {
        /// An unclosed multi-line comment was found
        UnclosedComment,
        /// An unclosed string was found
        UnclosedString,
        /// An unexpected #! was found
        UnexpectedShebang,
        /// An unexpected token was found
        UnexpectedToken(char),
        /// Symbol passed is not valid
        /// Returned from [`TokenReference::symbol`]
        InvalidSymbol(String),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenizerErrorType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UnclosedComment" => _serde::export::Ok(__Field::__field0),
                            "UnclosedString" => _serde::export::Ok(__Field::__field1),
                            "UnexpectedShebang" => _serde::export::Ok(__Field::__field2),
                            "UnexpectedToken" => _serde::export::Ok(__Field::__field3),
                            "InvalidSymbol" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UnclosedComment" => _serde::export::Ok(__Field::__field0),
                            b"UnclosedString" => _serde::export::Ok(__Field::__field1),
                            b"UnexpectedShebang" => _serde::export::Ok(__Field::__field2),
                            b"UnexpectedToken" => _serde::export::Ok(__Field::__field3),
                            b"InvalidSymbol" => _serde::export::Ok(__Field::__field4),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TokenizerErrorType>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenizerErrorType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum TokenizerErrorType")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TokenizerErrorType::UnclosedComment)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TokenizerErrorType::UnclosedString)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TokenizerErrorType::UnexpectedShebang)
                            }
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<char>(__variant),
                                TokenizerErrorType::UnexpectedToken,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                                TokenizerErrorType::InvalidSymbol,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "UnclosedComment",
                    "UnclosedString",
                    "UnexpectedShebang",
                    "UnexpectedToken",
                    "InvalidSymbol",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TokenizerErrorType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TokenizerErrorType>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenizerErrorType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TokenizerErrorType::UnclosedComment => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TokenizerErrorType",
                            0u32,
                            "UnclosedComment",
                        )
                    }
                    TokenizerErrorType::UnclosedString => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TokenizerErrorType",
                            1u32,
                            "UnclosedString",
                        )
                    }
                    TokenizerErrorType::UnexpectedShebang => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TokenizerErrorType",
                            2u32,
                            "UnexpectedShebang",
                        )
                    }
                    TokenizerErrorType::UnexpectedToken(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TokenizerErrorType",
                            3u32,
                            "UnexpectedToken",
                            __field0,
                        )
                    }
                    TokenizerErrorType::InvalidSymbol(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TokenizerErrorType",
                            4u32,
                            "InvalidSymbol",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenizerErrorType {
        #[inline]
        fn clone(&self) -> TokenizerErrorType {
            match (&*self,) {
                (&TokenizerErrorType::UnclosedComment,) => TokenizerErrorType::UnclosedComment,
                (&TokenizerErrorType::UnclosedString,) => TokenizerErrorType::UnclosedString,
                (&TokenizerErrorType::UnexpectedShebang,) => TokenizerErrorType::UnexpectedShebang,
                (&TokenizerErrorType::UnexpectedToken(ref __self_0),) => {
                    TokenizerErrorType::UnexpectedToken(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&TokenizerErrorType::InvalidSymbol(ref __self_0),) => {
                    TokenizerErrorType::InvalidSymbol(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenizerErrorType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenizerErrorType::UnclosedComment,) => {
                    ::core::fmt::Formatter::write_str(f, "UnclosedComment")
                }
                (&TokenizerErrorType::UnclosedString,) => {
                    ::core::fmt::Formatter::write_str(f, "UnclosedString")
                }
                (&TokenizerErrorType::UnexpectedShebang,) => {
                    ::core::fmt::Formatter::write_str(f, "UnexpectedShebang")
                }
                (&TokenizerErrorType::UnexpectedToken(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UnexpectedToken");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&TokenizerErrorType::InvalidSymbol(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidSymbol");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenizerErrorType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenizerErrorType {
        #[inline]
        fn eq(&self, other: &TokenizerErrorType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenizerErrorType::UnexpectedToken(ref __self_0),
                            &TokenizerErrorType::UnexpectedToken(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenizerErrorType::InvalidSymbol(ref __self_0),
                            &TokenizerErrorType::InvalidSymbol(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &TokenizerErrorType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenizerErrorType::UnexpectedToken(ref __self_0),
                            &TokenizerErrorType::UnexpectedToken(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenizerErrorType::InvalidSymbol(ref __self_0),
                            &TokenizerErrorType::InvalidSymbol(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    /// The type of tokens in parsed code
    #[serde(tag = "type")]
    #[non_exhaustive]
    pub enum TokenType {
        /// End of file, should always be the very last token
        Eof,
        /// An identifier, such as `foo`
        Identifier {
            /// The identifier itself
            identifier: ShortString,
        },
        /// A multi line comment in the format of `--[[ comment ]]`
        MultiLineComment {
            /// Number of equals signs, if any, for the multi line comment
            /// For example, `--[=[` would have a `blocks` value of `1`
            blocks: usize,
            /// The comment itself, ignoring opening and closing tags
            comment: ShortString,
        },
        /// A literal number, such as `3.3`
        Number {
            /// The text representing the number, includes details such as `0x`
            text: ShortString,
        },
        /// A shebang line
        Shebang {
            /// The shebang line itself
            line: ShortString,
        },
        /// A single line comment, such as `-- comment`
        SingleLineComment {
            /// The comment, ignoring initial `--`
            comment: ShortString,
        },
        /// A literal string, such as "Hello, world"
        StringLiteral {
            /// The literal itself, ignoring quotation marks
            literal: ShortString,
            #[serde(skip_serializing_if = "Option::is_none")]
            /// Number of equals signs used for a multi line string, if it is one
            /// For example, `[=[string]=]` would have a `multi_line` value of Some(1)
            /// `[[string]]` would have a `multi_line` value of Some(0)
            /// A string such as `"string"` would have a `multi_line` value of None
            multi_line: Option<usize>,
            /// The type of quotation mark used to make the string
            quote_type: StringLiteralQuoteType,
        },
        /// A [`Symbol`], such as `local` or `+`
        Symbol {
            /// The symbol itself
            symbol: Symbol,
        },
        /// Whitespace, such as tabs or new lines
        Whitespace {
            /// Characters consisting of the whitespace
            characters: ShortString,
        },
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 9",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Eof" => _serde::export::Ok(__Field::__field0),
                            "Identifier" => _serde::export::Ok(__Field::__field1),
                            "MultiLineComment" => _serde::export::Ok(__Field::__field2),
                            "Number" => _serde::export::Ok(__Field::__field3),
                            "Shebang" => _serde::export::Ok(__Field::__field4),
                            "SingleLineComment" => _serde::export::Ok(__Field::__field5),
                            "StringLiteral" => _serde::export::Ok(__Field::__field6),
                            "Symbol" => _serde::export::Ok(__Field::__field7),
                            "Whitespace" => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Eof" => _serde::export::Ok(__Field::__field0),
                            b"Identifier" => _serde::export::Ok(__Field::__field1),
                            b"MultiLineComment" => _serde::export::Ok(__Field::__field2),
                            b"Number" => _serde::export::Ok(__Field::__field3),
                            b"Shebang" => _serde::export::Ok(__Field::__field4),
                            b"SingleLineComment" => _serde::export::Ok(__Field::__field5),
                            b"StringLiteral" => _serde::export::Ok(__Field::__field6),
                            b"Symbol" => _serde::export::Ok(__Field::__field7),
                            b"Whitespace" => _serde::export::Ok(__Field::__field8),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Eof",
                    "Identifier",
                    "MultiLineComment",
                    "Number",
                    "Shebang",
                    "SingleLineComment",
                    "StringLiteral",
                    "Symbol",
                    "Whitespace",
                ];
                let __tagged = match _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::private::de::TaggedContentVisitor::<__Field>::new("type"),
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match __tagged.tag {
                    __Field::__field0 => {
                        match _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            _serde::private::de::InternallyTaggedUnitVisitor::new(
                                "TokenType",
                                "Eof",
                            ),
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::export::Ok(TokenType::Eof)
                    }
                    __Field::__field1 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "identifier" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"identifier" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Identifier",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant TokenType::Identifier with 1 element")) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::Identifier {
                                    identifier: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("identifier")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("identifier") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Identifier {
                                    identifier: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["identifier"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field2 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    1u64 => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 2",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "blocks" => _serde::export::Ok(__Field::__field0),
                                    "comment" => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"blocks" => _serde::export::Ok(__Field::__field0),
                                    b"comment" => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::MultiLineComment",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    usize,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant TokenType::MultiLineComment with 2 elements")) ;
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant TokenType::MultiLineComment with 2 elements")) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::MultiLineComment {
                                    blocks: __field0,
                                    comment: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<usize> =
                                    _serde::export::None;
                                let mut __field1: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("blocks")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<usize>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("comment")) ;
                                            }
                                            __field1 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("blocks") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::export::Some(__field1) => __field1,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("comment") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::MultiLineComment {
                                    blocks: __field0,
                                    comment: __field1,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["blocks", "comment"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field3 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "text" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"text" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Number",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant TokenType::Number with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::export::Ok(TokenType::Number { text: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("text")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("text") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Number { text: __field0 })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["text"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field4 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "line" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"line" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Shebang",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant TokenType::Shebang with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::export::Ok(TokenType::Shebang { line: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("line")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("line") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Shebang { line: __field0 })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["line"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field5 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "comment" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"comment" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::SingleLineComment",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant TokenType::SingleLineComment with 1 element")) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::SingleLineComment {
                                    comment: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("comment")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("comment") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::SingleLineComment {
                                    comment: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["comment"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field6 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    1u64 => _serde::export::Ok(__Field::__field1),
                                    2u64 => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 3",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "literal" => _serde::export::Ok(__Field::__field0),
                                    "multi_line" => _serde::export::Ok(__Field::__field1),
                                    "quote_type" => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"literal" => _serde::export::Ok(__Field::__field0),
                                    b"multi_line" => _serde::export::Ok(__Field::__field1),
                                    b"quote_type" => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::StringLiteral",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant TokenType::StringLiteral with 3 elements")) ;
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Option<usize>,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant TokenType::StringLiteral with 3 elements")) ;
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    StringLiteralQuoteType,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant TokenType::StringLiteral with 3 elements")) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::StringLiteral {
                                    literal: __field0,
                                    multi_line: __field1,
                                    quote_type: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                let mut __field1: _serde::export::Option<Option<usize>> =
                                    _serde::export::None;
                                let mut __field2: _serde::export::Option<StringLiteralQuoteType> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("literal")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("multi_line")) ;
                                            }
                                            __field1 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<usize>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("quote_type")) ;
                                            }
                                            __field2 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    StringLiteralQuoteType,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("literal") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::export::Some(__field1) => __field1,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("multi_line") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::export::Some(__field2) => __field2,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("quote_type") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::StringLiteral {
                                    literal: __field0,
                                    multi_line: __field1,
                                    quote_type: __field2,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["literal", "multi_line", "quote_type"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field7 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "symbol" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"symbol" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Symbol",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Symbol,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant TokenType::Symbol with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::export::Ok(TokenType::Symbol { symbol: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Symbol> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("symbol")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<Symbol>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("symbol") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Symbol { symbol: __field0 })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["symbol"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field8 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "characters" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"characters" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::export::PhantomData<TokenType>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = TokenType;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Whitespace",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    ShortString,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant TokenType::Whitespace with 1 element")) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::Whitespace {
                                    characters: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<ShortString> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("characters")) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<ShortString>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("characters") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Whitespace {
                                    characters: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["characters"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TokenType::Eof => {
                        let mut __struct = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __struct,
                            "type",
                            "Eof",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__struct)
                    }
                    TokenType::Identifier { ref identifier } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Identifier",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "identifier",
                            identifier,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::MultiLineComment {
                        ref blocks,
                        ref comment,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "MultiLineComment",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "blocks",
                            blocks,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "comment",
                            comment,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Number { ref text } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Number",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "text",
                            text,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Shebang { ref line } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Shebang",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "line",
                            line,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::SingleLineComment { ref comment } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "SingleLineComment",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "comment",
                            comment,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::StringLiteral {
                        ref literal,
                        ref multi_line,
                        ref quote_type,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + if Option::is_none(multi_line) { 0 } else { 1 } + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "StringLiteral",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "literal",
                            literal,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        if !Option::is_none(multi_line) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "multi_line",
                                multi_line,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "multi_line",
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "quote_type",
                            quote_type,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Symbol { ref symbol } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Symbol",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "symbol",
                            symbol,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Whitespace { ref characters } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Whitespace",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "characters",
                            characters,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenType {
        #[inline]
        fn clone(&self) -> TokenType {
            match (&*self,) {
                (&TokenType::Eof,) => TokenType::Eof,
                (&TokenType::Identifier {
                    identifier: ref __self_0,
                },) => TokenType::Identifier {
                    identifier: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::MultiLineComment {
                    blocks: ref __self_0,
                    comment: ref __self_1,
                },) => TokenType::MultiLineComment {
                    blocks: ::core::clone::Clone::clone(&(*__self_0)),
                    comment: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&TokenType::Number { text: ref __self_0 },) => TokenType::Number {
                    text: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::Shebang { line: ref __self_0 },) => TokenType::Shebang {
                    line: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::SingleLineComment {
                    comment: ref __self_0,
                },) => TokenType::SingleLineComment {
                    comment: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::StringLiteral {
                    literal: ref __self_0,
                    multi_line: ref __self_1,
                    quote_type: ref __self_2,
                },) => TokenType::StringLiteral {
                    literal: ::core::clone::Clone::clone(&(*__self_0)),
                    multi_line: ::core::clone::Clone::clone(&(*__self_1)),
                    quote_type: ::core::clone::Clone::clone(&(*__self_2)),
                },
                (&TokenType::Symbol {
                    symbol: ref __self_0,
                },) => TokenType::Symbol {
                    symbol: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::Whitespace {
                    characters: ref __self_0,
                },) => TokenType::Whitespace {
                    characters: ::core::clone::Clone::clone(&(*__self_0)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenType::Eof,) => ::core::fmt::Formatter::write_str(f, "Eof"),
                (&TokenType::Identifier {
                    identifier: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Identifier");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "identifier",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::MultiLineComment {
                    blocks: ref __self_0,
                    comment: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "MultiLineComment");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "blocks",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "comment",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::Number { text: ref __self_0 },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Number");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "text", &&(*__self_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::Shebang { line: ref __self_0 },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Shebang");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "line", &&(*__self_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::SingleLineComment {
                    comment: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "SingleLineComment");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "comment",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::StringLiteral {
                    literal: ref __self_0,
                    multi_line: ref __self_1,
                    quote_type: ref __self_2,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "StringLiteral");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "literal",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "multi_line",
                        &&(*__self_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "quote_type",
                        &&(*__self_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::Symbol {
                    symbol: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Symbol");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "symbol",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&TokenType::Whitespace {
                    characters: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Whitespace");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "characters",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<usize>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
                let _: ::core::cmp::AssertParamIsEq<Option<usize>>;
                let _: ::core::cmp::AssertParamIsEq<StringLiteralQuoteType>;
                let _: ::core::cmp::AssertParamIsEq<Symbol>;
                let _: ::core::cmp::AssertParamIsEq<ShortString>;
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenType {
        #[inline]
        fn eq(&self, other: &TokenType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenType::Identifier {
                                identifier: ref __self_0,
                            },
                            &TokenType::Identifier {
                                identifier: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::MultiLineComment {
                                blocks: ref __self_0,
                                comment: ref __self_1,
                            },
                            &TokenType::MultiLineComment {
                                blocks: ref __arg_1_0,
                                comment: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &TokenType::Number { text: ref __self_0 },
                            &TokenType::Number {
                                text: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::Shebang { line: ref __self_0 },
                            &TokenType::Shebang {
                                line: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::SingleLineComment {
                                comment: ref __self_0,
                            },
                            &TokenType::SingleLineComment {
                                comment: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::StringLiteral {
                                literal: ref __self_0,
                                multi_line: ref __self_1,
                                quote_type: ref __self_2,
                            },
                            &TokenType::StringLiteral {
                                literal: ref __arg_1_0,
                                multi_line: ref __arg_1_1,
                                quote_type: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        (
                            &TokenType::Symbol {
                                symbol: ref __self_0,
                            },
                            &TokenType::Symbol {
                                symbol: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::Whitespace {
                                characters: ref __self_0,
                            },
                            &TokenType::Whitespace {
                                characters: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &TokenType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenType::Identifier {
                                identifier: ref __self_0,
                            },
                            &TokenType::Identifier {
                                identifier: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::MultiLineComment {
                                blocks: ref __self_0,
                                comment: ref __self_1,
                            },
                            &TokenType::MultiLineComment {
                                blocks: ref __arg_1_0,
                                comment: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &TokenType::Number { text: ref __self_0 },
                            &TokenType::Number {
                                text: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::Shebang { line: ref __self_0 },
                            &TokenType::Shebang {
                                line: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::SingleLineComment {
                                comment: ref __self_0,
                            },
                            &TokenType::SingleLineComment {
                                comment: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::StringLiteral {
                                literal: ref __self_0,
                                multi_line: ref __self_1,
                                quote_type: ref __self_2,
                            },
                            &TokenType::StringLiteral {
                                literal: ref __arg_1_0,
                                multi_line: ref __arg_1_1,
                                quote_type: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        (
                            &TokenType::Symbol {
                                symbol: ref __self_0,
                            },
                            &TokenType::Symbol {
                                symbol: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::Whitespace {
                                characters: ref __self_0,
                            },
                            &TokenType::Whitespace {
                                characters: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl TokenType {
        /// Returns whether a token can be practically ignored in most cases
        /// Comments and whitespace will return `true`, everything else will return `false`
        pub fn is_trivia(&self) -> bool {
            match self {
                TokenType::Shebang { .. }
                | TokenType::SingleLineComment { .. }
                | TokenType::MultiLineComment { .. }
                | TokenType::Whitespace { .. } => true,
                _ => false,
            }
        }
        /// Returns the kind of the token type.
        ///
        /// ```rust
        /// use full_moon::{ShortString, tokenizer::{TokenKind, TokenType}};
        ///
        /// assert_eq!(
        ///     TokenType::Identifier {
        ///         identifier: ShortString::new("hello")
        ///     }.kind(),
        ///     TokenKind::Identifier,
        /// );
        /// ```
        pub fn kind(&self) -> TokenKind {
            match self {
                TokenType::Eof => TokenKind::Eof,
                TokenType::Identifier { .. } => TokenKind::Identifier,
                TokenType::MultiLineComment { .. } => TokenKind::MultiLineComment,
                TokenType::Number { .. } => TokenKind::Number,
                TokenType::Shebang { .. } => TokenKind::Shebang,
                TokenType::SingleLineComment { .. } => TokenKind::SingleLineComment,
                TokenType::StringLiteral { .. } => TokenKind::StringLiteral,
                TokenType::Symbol { .. } => TokenKind::Symbol,
                TokenType::Whitespace { .. } => TokenKind::Whitespace,
            }
        }
        /// Returns a whitespace `TokenType` consisting of spaces
        pub fn spaces(spaces: usize) -> Self {
            TokenType::Whitespace {
                characters: " ".repeat(spaces).into(),
            }
        }
        /// Returns a whitespace `TokenType` consisting of tabs
        pub fn tabs(tabs: usize) -> Self {
            TokenType::Whitespace {
                characters: "\t".repeat(tabs).into(),
            }
        }
    }
    /// The kind of token. Contains no additional data.
    #[non_exhaustive]
    pub enum TokenKind {
        /// End of file, should always be the very last token
        Eof,
        /// An identifier, such as `foo`
        Identifier,
        /// A multi line comment in the format of `--[[ comment ]]`
        MultiLineComment,
        /// A literal number, such as `3.3`
        Number,
        /// The shebang line
        Shebang,
        /// A single line comment, such as `-- comment`
        SingleLineComment,
        /// A literal string, such as "Hello, world"
        StringLiteral,
        /// A [`Symbol`], such as `local` or `+`
        Symbol,
        /// Whitespace, such as tabs or new lines
        Whitespace,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenKind {
        #[inline]
        fn clone(&self) -> TokenKind {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for TokenKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&TokenKind::Eof,) => ::core::fmt::Formatter::write_str(f, "Eof"),
                (&TokenKind::Identifier,) => ::core::fmt::Formatter::write_str(f, "Identifier"),
                (&TokenKind::MultiLineComment,) => {
                    ::core::fmt::Formatter::write_str(f, "MultiLineComment")
                }
                (&TokenKind::Number,) => ::core::fmt::Formatter::write_str(f, "Number"),
                (&TokenKind::Shebang,) => ::core::fmt::Formatter::write_str(f, "Shebang"),
                (&TokenKind::SingleLineComment,) => {
                    ::core::fmt::Formatter::write_str(f, "SingleLineComment")
                }
                (&TokenKind::StringLiteral,) => {
                    ::core::fmt::Formatter::write_str(f, "StringLiteral")
                }
                (&TokenKind::Symbol,) => ::core::fmt::Formatter::write_str(f, "Symbol"),
                (&TokenKind::Whitespace,) => ::core::fmt::Formatter::write_str(f, "Whitespace"),
            }
        }
    }
    impl ::core::marker::StructuralEq for TokenKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for TokenKind {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenKind {
        #[inline]
        fn eq(&self, other: &TokenKind) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    /// A token such consisting of its [`Position`] and a [`TokenType`]
    pub struct Token {
        pub(crate) start_position: Position,
        pub(crate) end_position: Position,
        pub(crate) token_type: TokenType,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Token {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "start_position" => _serde::export::Ok(__Field::__field0),
                            "end_position" => _serde::export::Ok(__Field::__field1),
                            "token_type" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"start_position" => _serde::export::Ok(__Field::__field0),
                            b"end_position" => _serde::export::Ok(__Field::__field1),
                            b"token_type" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Token>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Token;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Token")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Position>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Token with 3 elements",
                                    ));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Position>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Token with 3 elements",
                                    ));
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<TokenType>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Token with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Token {
                            start_position: __field0,
                            end_position: __field1,
                            token_type: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Position> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Position> = _serde::export::None;
                        let mut __field2: _serde::export::Option<TokenType> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start_position",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Position>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_position",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Position>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_type",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenType>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("start_position") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("end_position") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("token_type") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Token {
                            start_position: __field0,
                            end_position: __field1,
                            token_type: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["start_position", "end_position", "token_type"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Token",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Token>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Token {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Token",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start_position",
                    &self.start_position,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_position",
                    &self.end_position,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_type",
                    &self.token_type,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Token {
        #[inline]
        fn clone(&self) -> Token {
            match *self {
                Token {
                    start_position: ref __self_0_0,
                    end_position: ref __self_0_1,
                    token_type: ref __self_0_2,
                } => Token {
                    start_position: ::core::clone::Clone::clone(&(*__self_0_0)),
                    end_position: ::core::clone::Clone::clone(&(*__self_0_1)),
                    token_type: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Token {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Token {
                    start_position: ref __self_0_0,
                    end_position: ref __self_0_1,
                    token_type: ref __self_0_2,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Token");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "start_position",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "end_position",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "token_type",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Token {
        /// Creates a token with a zero position
        pub fn new(token_type: TokenType) -> Token {
            Token {
                start_position: Position::default(),
                end_position: Position::default(),
                token_type,
            }
        }
        /// The position a token begins at
        pub fn start_position(&self) -> Position {
            self.start_position
        }
        /// The position a token ends at
        pub fn end_position(&self) -> Position {
            self.end_position
        }
        /// The type of token as well as the data needed to represent it
        /// If you don't need any other information, use [`token_kind`](Token::token_kind) instead.
        pub fn token_type(&self) -> &TokenType {
            &self.token_type
        }
        /// The kind of token with no additional data.
        /// If you need any information such as idenitfier names, use [`token_type`](Token::token_type) instead.
        pub fn token_kind(&self) -> TokenKind {
            self.token_type().kind()
        }
    }
    impl fmt::Display for Token {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            use self::TokenType::*;
            match &*self.token_type() {
                Eof => "".to_string(),
                Number { text } => text.to_string(),
                Identifier { identifier } => identifier.to_string(),
                MultiLineComment { blocks, comment } => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                        &["--[", "[", "]", "]"],
                        &match (&"=".repeat(*blocks), &comment) {
                            (arg0, arg1) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: 0usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 1usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 0usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                        unsafe { ::core::fmt::UnsafeArg::new() },
                    ));
                    res
                }
                Shebang { line } => line.to_string(),
                SingleLineComment { comment } => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["--"],
                        &match (&comment,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                StringLiteral {
                    literal,
                    multi_line,
                    quote_type,
                } => {
                    if let Some(blocks) = multi_line {
                        {
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                                    &["[", "[", "]", "]"],
                                    &match (&"=".repeat(*blocks), &literal.to_string()) {
                                        (arg0, arg1) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                    &[
                                        ::core::fmt::rt::v1::Argument {
                                            position: 0usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                        ::core::fmt::rt::v1::Argument {
                                            position: 1usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                        ::core::fmt::rt::v1::Argument {
                                            position: 0usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                    ],
                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                ));
                            res
                        }
                    } else {
                        {
                            let res =
                                ::alloc::fmt::format(::core::fmt::Arguments::new_v1_formatted(
                                    &["", "", ""],
                                    &match (&quote_type.to_string(), &literal.to_string()) {
                                        (arg0, arg1) => [
                                            ::core::fmt::ArgumentV1::new(
                                                arg0,
                                                ::core::fmt::Display::fmt,
                                            ),
                                            ::core::fmt::ArgumentV1::new(
                                                arg1,
                                                ::core::fmt::Display::fmt,
                                            ),
                                        ],
                                    },
                                    &[
                                        ::core::fmt::rt::v1::Argument {
                                            position: 0usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                        ::core::fmt::rt::v1::Argument {
                                            position: 1usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                        ::core::fmt::rt::v1::Argument {
                                            position: 0usize,
                                            format: ::core::fmt::rt::v1::FormatSpec {
                                                fill: ' ',
                                                align: ::core::fmt::rt::v1::Alignment::Unknown,
                                                flags: 0u32,
                                                precision: ::core::fmt::rt::v1::Count::Implied,
                                                width: ::core::fmt::rt::v1::Count::Implied,
                                            },
                                        },
                                    ],
                                    unsafe { ::core::fmt::UnsafeArg::new() },
                                ));
                            res
                        }
                    }
                }
                Symbol { symbol } => symbol.to_string(),
                Whitespace { characters } => characters.to_string(),
            }
            .fmt(formatter)
        }
    }
    impl PartialEq<Self> for Token {
        fn eq(&self, rhs: &Self) -> bool {
            self.start_position() == rhs.start_position()
                && self.end_position() == rhs.end_position()
                && self.token_type == rhs.token_type
        }
    }
    impl Eq for Token {}
    impl Ord for Token {
        fn cmp(&self, other: &Self) -> Ordering {
            self.start_position().cmp(&other.start_position())
        }
    }
    impl PartialOrd for Token {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    impl<P: Plugin> Visit<P> for Token {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_token(self);
            match self.token_kind() {
                TokenKind::Eof => {}
                TokenKind::Identifier => visitor.visit_identifier(self),
                TokenKind::MultiLineComment => visitor.visit_multi_line_comment(self),
                TokenKind::Number => visitor.visit_number(self),
                TokenKind::Shebang => {}
                TokenKind::SingleLineComment => visitor.visit_single_line_comment(self),
                TokenKind::StringLiteral => visitor.visit_string_literal(self),
                TokenKind::Symbol => visitor.visit_symbol(self),
                TokenKind::Whitespace => visitor.visit_whitespace(self),
            }
        }
    }
    impl<P: Plugin> VisitMut<P> for Token {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            let token = visitor.visit_token(self);
            match token.token_kind() {
                TokenKind::Eof => token,
                TokenKind::Identifier => visitor.visit_identifier(token),
                TokenKind::MultiLineComment => visitor.visit_multi_line_comment(token),
                TokenKind::Number => visitor.visit_number(token),
                TokenKind::Shebang => token,
                TokenKind::SingleLineComment => visitor.visit_single_line_comment(token),
                TokenKind::StringLiteral => visitor.visit_string_literal(token),
                TokenKind::Symbol => visitor.visit_symbol(token),
                TokenKind::Whitespace => visitor.visit_whitespace(token),
            }
        }
    }
    /// A reference to a token used by Ast's.
    /// Dereferences to a [`Token`]
    pub struct TokenReference {
        pub(crate) leading_trivia: Vec<Token>,
        pub(crate) token: Token,
        pub(crate) trailing_trivia: Vec<Token>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenReference {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "leading_trivia" => _serde::export::Ok(__Field::__field0),
                            "token" => _serde::export::Ok(__Field::__field1),
                            "trailing_trivia" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"leading_trivia" => _serde::export::Ok(__Field::__field0),
                            b"token" => _serde::export::Ok(__Field::__field1),
                            b"trailing_trivia" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TokenReference>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenReference;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TokenReference")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Vec<Token>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TokenReference with 3 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Token>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenReference with 3 elements",
                                    ));
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Vec<Token>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct TokenReference with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(TokenReference {
                            leading_trivia: __field0,
                            token: __field1,
                            trailing_trivia: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<Token>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Token> = _serde::export::None;
                        let mut __field2: _serde::export::Option<Vec<Token>> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "leading_trivia",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Token>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Token>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "trailing_trivia",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Token>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("leading_trivia") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("token") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("trailing_trivia") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(TokenReference {
                            leading_trivia: __field0,
                            token: __field1,
                            trailing_trivia: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["leading_trivia", "token", "trailing_trivia"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenReference",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TokenReference>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenReference {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenReference",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "leading_trivia",
                    &self.leading_trivia,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token",
                    &self.token,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "trailing_trivia",
                    &self.trailing_trivia,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenReference {
        #[inline]
        fn clone(&self) -> TokenReference {
            match *self {
                TokenReference {
                    leading_trivia: ref __self_0_0,
                    token: ref __self_0_1,
                    trailing_trivia: ref __self_0_2,
                } => TokenReference {
                    leading_trivia: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token: ::core::clone::Clone::clone(&(*__self_0_1)),
                    trailing_trivia: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenReference {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TokenReference {
                    leading_trivia: ref __self_0_0,
                    token: ref __self_0_1,
                    trailing_trivia: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "TokenReference");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "leading_trivia",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "token",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "trailing_trivia",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl TokenReference {
        /// Creates a TokenReference from leading/trailing trivia as well as the leading token
        pub fn new(leading_trivia: Vec<Token>, token: Token, trailing_trivia: Vec<Token>) -> Self {
            Self {
                leading_trivia,
                token,
                trailing_trivia,
            }
        }
        /// Returns a symbol with the leading and trailing whitespace
        /// Only whitespace is supported
        /// ```rust
        /// # use full_moon::tokenizer::{Symbol, TokenReference, TokenType, TokenizerErrorType};
        /// # fn main() -> Result<(), Box<TokenizerErrorType>> {
        /// let symbol = TokenReference::symbol("\nreturn ")?;
        /// assert_eq!(symbol.leading_trivia().next().unwrap().to_string(), "\n");
        /// assert_eq!(symbol.token().token_type(), &TokenType::Symbol {
        ///     symbol: Symbol::Return,
        /// });
        /// assert_eq!(symbol.trailing_trivia().next().unwrap().to_string(), " ");
        /// assert!(TokenReference::symbol("isnt whitespace").is_err());
        /// assert!(TokenReference::symbol(" notasymbol ").is_err());
        /// # Ok(())
        /// # }
        /// ```
        pub fn symbol(text: &str) -> Result<Self, TokenizerErrorType> {
            let mut chars = text.chars().peekable();
            let mut leading_trivia = String::new();
            while let Some(character) = chars.peek() {
                if character.is_ascii_whitespace() {
                    leading_trivia.push(chars.next().unwrap());
                } else {
                    break;
                }
            }
            let mut symbol_text = String::new();
            while let Some(character) = chars.peek() {
                if !character.is_ascii_whitespace() {
                    symbol_text.push(chars.next().unwrap());
                } else {
                    break;
                }
            }
            let symbol = Symbol::from_str(&symbol_text)
                .map_err(|_| TokenizerErrorType::InvalidSymbol(symbol_text))?;
            let mut trailing_trivia = String::new();
            while let Some(character) = chars.peek() {
                if character.is_ascii_whitespace() {
                    trailing_trivia.push(chars.next().unwrap());
                } else {
                    return Err(TokenizerErrorType::UnexpectedToken(*character));
                }
            }
            Ok(Self {
                leading_trivia: <[_]>::into_vec(box [Token::new(TokenType::Whitespace {
                    characters: leading_trivia.into(),
                })]),
                token: Token::new(TokenType::Symbol { symbol }),
                trailing_trivia: <[_]>::into_vec(box [Token::new(TokenType::Whitespace {
                    characters: trailing_trivia.into(),
                })]),
            })
        }
        /// Returns the inner token.
        pub fn token(&self) -> &Token {
            &self.token
        }
        /// Returns the leading trivia
        pub fn leading_trivia(&self) -> impl Iterator<Item = &Token> {
            self.leading_trivia.iter()
        }
        /// Returns the trailing trivia
        pub fn trailing_trivia(&self) -> impl Iterator<Item = &Token> {
            self.trailing_trivia.iter()
        }
        /// Creates a clone of the current TokenReference with the new inner token, preserving trivia.
        pub fn with_token(&self, token: Token) -> Self {
            Self {
                token,
                leading_trivia: self.leading_trivia.clone(),
                trailing_trivia: self.trailing_trivia.clone(),
            }
        }
    }
    impl std::borrow::Borrow<Token> for &TokenReference {
        fn borrow(&self) -> &Token {
            &**self
        }
    }
    impl std::ops::Deref for TokenReference {
        type Target = Token;
        fn deref(&self) -> &Self::Target {
            &self.token
        }
    }
    impl fmt::Display for TokenReference {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            for trivia in &self.leading_trivia {
                formatter.write_str(&trivia.to_string())?;
            }
            formatter.write_str(&self.token.to_string())?;
            for trivia in &self.trailing_trivia {
                formatter.write_str(&trivia.to_string())?;
            }
            Ok(())
        }
    }
    impl PartialEq<Self> for TokenReference {
        fn eq(&self, other: &Self) -> bool {
            (**self).eq(other)
                && self.leading_trivia == other.leading_trivia
                && self.trailing_trivia == other.trailing_trivia
        }
    }
    impl Eq for TokenReference {}
    impl Ord for TokenReference {
        fn cmp(&self, other: &Self) -> Ordering {
            (**self).cmp(&**other)
        }
    }
    impl PartialOrd for TokenReference {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    impl<P: Plugin> Visit<P> for TokenReference {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            visitor.visit_token(self);
            if match self.token().token_kind() {
                TokenKind::Eof => true,
                _ => false,
            } {
                visitor.visit_eof(self);
            }
            self.leading_trivia.visit(visitor);
            self.token.visit(visitor);
            self.trailing_trivia.visit(visitor);
        }
    }
    impl<P: Plugin> VisitMut<P> for TokenReference {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            let mut token_reference = visitor.visit_token_reference(self);
            if match token_reference.token().token_kind() {
                TokenKind::Eof => true,
                _ => false,
            } {
                token_reference = visitor.visit_eof(token_reference);
            }
            token_reference.leading_trivia = token_reference.leading_trivia.visit_mut(visitor);
            token_reference.token = token_reference.token.visit_mut(visitor);
            token_reference.trailing_trivia = token_reference.trailing_trivia.visit_mut(visitor);
            token_reference
        }
    }
    /// Used to represent exact positions of tokens in code
    pub struct Position {
        pub(crate) bytes: usize,
        pub(crate) line: usize,
        pub(crate) character: usize,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Position {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bytes" => _serde::export::Ok(__Field::__field0),
                            "line" => _serde::export::Ok(__Field::__field1),
                            "character" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bytes" => _serde::export::Ok(__Field::__field0),
                            b"line" => _serde::export::Ok(__Field::__field1),
                            b"character" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Position>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Position;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Position")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        _serde::export::Ok(Position {
                            bytes: __field0,
                            line: __field1,
                            character: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<usize> = _serde::export::None;
                        let mut __field1: _serde::export::Option<usize> = _serde::export::None;
                        let mut __field2: _serde::export::Option<usize> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bytes",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "line",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("bytes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("line") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("character") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Position {
                            bytes: __field0,
                            line: __field1,
                            character: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["bytes", "line", "character"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Position",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Position>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Position {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Position",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bytes",
                    &self.bytes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "line",
                    &self.line,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character",
                    &self.character,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Position {
        #[inline]
        fn clone(&self) -> Position {
            {
                let _: ::core::clone::AssertParamIsClone<usize>;
                let _: ::core::clone::AssertParamIsClone<usize>;
                let _: ::core::clone::AssertParamIsClone<usize>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Position {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Position {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Position {
                    bytes: ref __self_0_0,
                    line: ref __self_0_1,
                    character: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Position");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "bytes",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "line",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "character",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for Position {
        #[inline]
        fn default() -> Position {
            Position {
                bytes: ::core::default::Default::default(),
                line: ::core::default::Default::default(),
                character: ::core::default::Default::default(),
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Position {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Position {
        #[inline]
        fn eq(&self, other: &Position) -> bool {
            match *other {
                Position {
                    bytes: ref __self_1_0,
                    line: ref __self_1_1,
                    character: ref __self_1_2,
                } => match *self {
                    Position {
                        bytes: ref __self_0_0,
                        line: ref __self_0_1,
                        character: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Position) -> bool {
            match *other {
                Position {
                    bytes: ref __self_1_0,
                    line: ref __self_1_1,
                    character: ref __self_1_2,
                } => match *self {
                    Position {
                        bytes: ref __self_0_0,
                        line: ref __self_0_1,
                        character: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Position {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Position {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<usize>;
                let _: ::core::cmp::AssertParamIsEq<usize>;
                let _: ::core::cmp::AssertParamIsEq<usize>;
            }
        }
    }
    impl Position {
        /// How many bytes, ignoring lines, it would take to find this position
        pub fn bytes(self) -> usize {
            self.bytes
        }
        /// Index of the character on the line for this position
        pub fn character(self) -> usize {
            self.character
        }
        /// Line the position lies on
        pub fn line(self) -> usize {
            self.line
        }
    }
    impl Ord for Position {
        fn cmp(&self, other: &Self) -> Ordering {
            self.bytes.cmp(&other.bytes)
        }
    }
    impl PartialOrd for Position {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    struct TokenAdvancement {
        pub advance: usize,
        pub token_type: TokenType,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenAdvancement {
        #[inline]
        fn clone(&self) -> TokenAdvancement {
            match *self {
                TokenAdvancement {
                    advance: ref __self_0_0,
                    token_type: ref __self_0_1,
                } => TokenAdvancement {
                    advance: ::core::clone::Clone::clone(&(*__self_0_0)),
                    token_type: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenAdvancement {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TokenAdvancement {
                    advance: ref __self_0_0,
                    token_type: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "TokenAdvancement");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "advance",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "token_type",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenAdvancement {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenAdvancement {
        #[inline]
        fn eq(&self, other: &TokenAdvancement) -> bool {
            match *other {
                TokenAdvancement {
                    advance: ref __self_1_0,
                    token_type: ref __self_1_1,
                } => match *self {
                    TokenAdvancement {
                        advance: ref __self_0_0,
                        token_type: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenAdvancement) -> bool {
            match *other {
                TokenAdvancement {
                    advance: ref __self_1_0,
                    token_type: ref __self_1_1,
                } => match *self {
                    TokenAdvancement {
                        advance: ref __self_0_0,
                        token_type: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    /// The types of quotes used in a Lua string
    #[non_exhaustive]
    pub enum StringLiteralQuoteType {
        /// Strings formatted \[\[with brackets\]\]
        Brackets,
        /// Strings formatted "with double quotes"
        Double,
        /// Strings formatted 'with single quotes'
        Single,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StringLiteralQuoteType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Brackets" => _serde::export::Ok(__Field::__field0),
                            "Double" => _serde::export::Ok(__Field::__field1),
                            "Single" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Brackets" => _serde::export::Ok(__Field::__field0),
                            b"Double" => _serde::export::Ok(__Field::__field1),
                            b"Single" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StringLiteralQuoteType>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StringLiteralQuoteType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "enum StringLiteralQuoteType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Brackets)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Double)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Single)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Brackets", "Double", "Single"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "StringLiteralQuoteType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StringLiteralQuoteType>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StringLiteralQuoteType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    StringLiteralQuoteType::Brackets => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        0u32,
                        "Brackets",
                    ),
                    StringLiteralQuoteType::Double => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        1u32,
                        "Double",
                    ),
                    StringLiteralQuoteType::Single => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        2u32,
                        "Single",
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for StringLiteralQuoteType {
        #[inline]
        fn clone(&self) -> StringLiteralQuoteType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for StringLiteralQuoteType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for StringLiteralQuoteType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&StringLiteralQuoteType::Brackets,) => {
                    ::core::fmt::Formatter::write_str(f, "Brackets")
                }
                (&StringLiteralQuoteType::Double,) => {
                    ::core::fmt::Formatter::write_str(f, "Double")
                }
                (&StringLiteralQuoteType::Single,) => {
                    ::core::fmt::Formatter::write_str(f, "Single")
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for StringLiteralQuoteType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for StringLiteralQuoteType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::marker::StructuralPartialEq for StringLiteralQuoteType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for StringLiteralQuoteType {
        #[inline]
        fn eq(&self, other: &StringLiteralQuoteType) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl fmt::Display for StringLiteralQuoteType {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                StringLiteralQuoteType::Brackets => {
                    ::core::panicking::panic("internal error: entered unreachable code")
                }
                StringLiteralQuoteType::Double => "\"",
                StringLiteralQuoteType::Single => "'",
            }
            .fmt(formatter)
        }
    }
    type RawToken = Result<TokenType, TokenizerErrorType>;
    impl From<TokenType> for RawToken {
        fn from(token_type: TokenType) -> RawToken {
            Ok(token_type)
        }
    }
    impl From<TokenizerErrorType> for RawToken {
        fn from(error: TokenizerErrorType) -> RawToken {
            Err(error)
        }
    }
    mod tokens {
        #[allow(unused_imports)]
        use super::*;
        type Input = str;
        type PositionRepr = <Input as ::peg::Parse>::PositionRepr;
        struct ParseState<'input> {
            _phantom: ::std::marker::PhantomData<&'input ()>,
        }
        impl<'input> ParseState<'input> {
            fn new() -> ParseState<'input> {
                ParseState {
                    _phantom: ::std::marker::PhantomData,
                }
            }
        }
        use super::ParseSymbol;
        use peg::ParseLiteral;
        use super::StringLiteralQuoteType as QuoteType;
        fn __parse_line_ending<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\n") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"\\n\"");
                            ::peg::RuleResult::Failed
                        }
                    };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\r\n") {
                            ::peg::RuleResult::Matched(__pos, __val) => {
                                ::peg::RuleResult::Matched(__pos, __val)
                            }
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "\"\\r\\n\"");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                }
            }
        }
        fn __parse_space<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            match ::peg::ParseElem::parse_elem(__input, __pos) {
                ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                    ' ' | '\t' => ::peg::RuleResult::Matched(__next, ()),
                    _ => {
                        __err_state.mark_failure(__pos, "[\' \' | \'\\t\']");
                        ::peg::RuleResult::Failed
                    }
                },
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "[\' \' | \'\\t\']");
                    ::peg::RuleResult::Failed
                }
            }
        }
        pub(super) fn whitespace<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_whitespace(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_whitespace(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_whitespace<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let __choice_res = {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = ::alloc::vec::Vec::new();
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res =
                                        match __parse_space(__input, __state, __err_state, __pos) {
                                            ::peg::RuleResult::Matched(pos, _) => {
                                                ::peg::RuleResult::Matched(pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        };
                                    match __step_res {
                                        ::peg::RuleResult::Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        ::peg::RuleResult::Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    ::peg::RuleResult::Matched(__repeat_pos, ())
                                } else {
                                    ::peg::RuleResult::Failed
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = match match __parse_line_ending(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __choice_res {
                            ::peg::RuleResult::Matched(__pos, __value) => {
                                ::peg::RuleResult::Matched(__pos, __value)
                            }
                            ::peg::RuleResult::Failed => {
                                match __parse_line_ending(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                        }
                    } {
                        ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                            __newpos,
                            ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, chars) => ::peg::RuleResult::Matched(
                        __pos,
                        (|| {
                            TokenType::Whitespace {
                                characters: chars.into(),
                            }
                            .into()
                        })(),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_multi_line_start<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    let __seq_res = {
                        let str_start = __pos;
                        match {
                            let mut __repeat_pos = __pos;
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "=",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        ::peg::RuleResult::Matched(__pos, __val)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"=\"");
                                        ::peg::RuleResult::Failed
                                    }
                                };
                                match __step_res {
                                    ::peg::RuleResult::Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                    }
                                    ::peg::RuleResult::Failed => {
                                        break;
                                    }
                                }
                            }
                            ::peg::RuleResult::Matched(__repeat_pos, ())
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, block) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "[") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, (|| block)())
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"[\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"[\"");
                    ::peg::RuleResult::Failed
                }
            }
        }
        fn __parse_multi_line_end<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
            block: &'input str,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "]") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    let __seq_res = __input.parse_string_literal(__pos, block);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "]") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    ::peg::RuleResult::Matched(__pos, ())
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"]\"");
                                    ::peg::RuleResult::Failed
                                }
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"]\"");
                    ::peg::RuleResult::Failed
                }
            }
        }
        fn __parse_multi_line_block<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<(usize, &'input str)> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = __parse_multi_line_start(__input, __state, __err_state, __pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, block) => {
                        let __seq_res = {
                            let str_start = __pos;
                            match {
                                let mut __repeat_pos = __pos;
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = {
                                        let __seq_res = {
                                            __err_state.suppress_fail += 1;
                                            let __assert_res = match __parse_multi_line_end(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                                block,
                                            ) {
                                                ::peg::RuleResult::Matched(pos, _) => {
                                                    ::peg::RuleResult::Matched(pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                            __err_state.suppress_fail -= 1;
                                            match __assert_res {
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Matched(__pos, ())
                                                }
                                                ::peg::RuleResult::Matched(..) => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                match ::peg::ParseElem::parse_elem(__input, __pos) {
                                                    ::peg::RuleResult::Matched(__next, __ch) => {
                                                        match __ch {
                                                            _ => {
                                                                let __pos = __next;
                                                                let _ = ();
                                                                {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        (),
                                                                    )
                                                                }
                                                            }
                                                            _ => {
                                                                __err_state
                                                                    .mark_failure(__pos, "[_]");
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "[_]");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __step_res {
                                        ::peg::RuleResult::Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                        }
                                        ::peg::RuleResult::Failed => {
                                            break;
                                        }
                                    }
                                }
                                ::peg::RuleResult::Matched(__repeat_pos, ())
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(
                                        __newpos,
                                        ::peg::ParseSlice::parse_slice(
                                            __input, str_start, __newpos,
                                        ),
                                    )
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, content) => {
                                let __seq_res = match __parse_multi_line_end(
                                    __input,
                                    __state,
                                    __err_state,
                                    __pos,
                                    block,
                                ) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| (block.len(), content))(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_multi_line_quote<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = {
                    let __seq_res = __parse_multi_line_block(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, v) => ::peg::RuleResult::Matched(
                            __pos,
                            (|| {
                                TokenType::StringLiteral {
                                    multi_line: Some(v.0),
                                    literal: v.1.into(),
                                    quote_type: QuoteType::Brackets,
                                }
                                .into()
                            })(),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __seq_res = {
                            __err_state.suppress_fail += 1;
                            let __assert_res = match __parse_multi_line_start(
                                __input,
                                __state,
                                __err_state,
                                __pos,
                            ) {
                                ::peg::RuleResult::Matched(pos, _) => {
                                    ::peg::RuleResult::Matched(pos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            };
                            __err_state.suppress_fail -= 1;
                            match __assert_res {
                                ::peg::RuleResult::Matched(_, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = ::alloc::vec::Vec::new();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res =
                                            match ::peg::ParseElem::parse_elem(__input, __pos) {
                                                ::peg::RuleResult::Matched(__next, __ch) => {
                                                    match __ch {
                                                        _ => ::peg::RuleResult::Matched(__next, ()),
                                                        _ => {
                                                            __err_state.mark_failure(__pos, "[_]");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "[_]");
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                        match __step_res {
                                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            ::peg::RuleResult::Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    if __repeat_value.len() >= 1 {
                                        ::peg::RuleResult::Matched(__repeat_pos, ())
                                    } else {
                                        ::peg::RuleResult::Failed
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| TokenizerErrorType::UnclosedString.into())(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            }
        }
        fn __parse_escape<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "\\") {
                ::peg::RuleResult::Matched(__pos, __val) => {
                    match ::peg::ParseElem::parse_elem(__input, __pos) {
                        ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                            _ => {
                                let __pos = __next;
                                let _ = ();
                                {
                                    ::peg::RuleResult::Matched(__pos, ())
                                }
                            }
                            _ => {
                                __err_state.mark_failure(__pos, "[_]");
                                ::peg::RuleResult::Failed
                            }
                        },
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "[_]");
                            ::peg::RuleResult::Failed
                        }
                    }
                }
                ::peg::RuleResult::Failed => {
                    __err_state.mark_failure(__pos, "\"\\\\\"");
                    ::peg::RuleResult::Failed
                }
            }
        }
        fn __parse_quote_char<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
            quote: &str,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = {
                    __err_state.suppress_fail += 1;
                    let __assert_res = {
                        let __choice_res = __input.parse_string_literal(__pos, quote);
                        match __choice_res {
                            ::peg::RuleResult::Matched(__pos, __value) => {
                                ::peg::RuleResult::Matched(__pos, __value)
                            }
                            ::peg::RuleResult::Failed => {
                                match ::peg::ParseElem::parse_elem(__input, __pos) {
                                    ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                                        '\r' | '\n' | '\\' => {
                                            ::peg::RuleResult::Matched(__next, ())
                                        }
                                        _ => {
                                            __err_state.mark_failure(
                                                __pos,
                                                "[\'\\r\' | \'\\n\' | \'\\\\\']",
                                            );
                                            ::peg::RuleResult::Failed
                                        }
                                    },
                                    ::peg::RuleResult::Failed => {
                                        __err_state
                                            .mark_failure(__pos, "[\'\\r\' | \'\\n\' | \'\\\\\']");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                        }
                    };
                    __err_state.suppress_fail -= 1;
                    match __assert_res {
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                        ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        match ::peg::ParseElem::parse_elem(__input, __pos) {
                            ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                                _ => {
                                    let __pos = __next;
                                    let _ = ();
                                    {
                                        ::peg::RuleResult::Matched(__pos, ())
                                    }
                                }
                                _ => {
                                    __err_state.mark_failure(__pos, "[_]");
                                    ::peg::RuleResult::Failed
                                }
                            },
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(__pos, "[_]");
                                ::peg::RuleResult::Failed
                            }
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_quoted<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
            quote: &str,
            quote_type: QuoteType,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = {
                    let __seq_res = __input.parse_string_literal(__pos, quote);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match {
                                    let __choice_res = {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = ::alloc::vec::Vec::new();
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = {
                                                let __choice_res = match __parse_quote_char(
                                                    __input,
                                                    __state,
                                                    __err_state,
                                                    __pos,
                                                    quote,
                                                ) {
                                                    ::peg::RuleResult::Matched(pos, _) => {
                                                        ::peg::RuleResult::Matched(pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __choice_res {
                                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                                        ::peg::RuleResult::Matched(__pos, __value)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        match __parse_escape(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(pos, _) => {
                                                                ::peg::RuleResult::Matched(pos, ())
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                            match __step_res {
                                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 {
                                            ::peg::RuleResult::Matched(__repeat_pos, ())
                                        } else {
                                            ::peg::RuleResult::Failed
                                        }
                                    };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, literal) => {
                                    let __seq_res = __input.parse_string_literal(__pos, quote);
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(
                                                __pos,
                                                (|| {
                                                    TokenType::StringLiteral {
                                                        multi_line: None,
                                                        literal: literal.into(),
                                                        quote_type,
                                                    }
                                                    .into()
                                                })(
                                                ),
                                            )
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __seq_res = __input.parse_string_literal(__pos, quote);
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res =
                                            match ::peg::ParseElem::parse_elem(__input, __pos) {
                                                ::peg::RuleResult::Matched(__next, __ch) => {
                                                    match __ch {
                                                        _ => ::peg::RuleResult::Matched(__next, ()),
                                                        _ => {
                                                            __err_state.mark_failure(__pos, "[_]");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "[_]");
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                        match __step_res {
                                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                            }
                                            ::peg::RuleResult::Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Matched(__repeat_pos, ())
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| TokenizerErrorType::UnclosedString.into())(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            }
        }
        fn __parse_single_line_quote<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = __parse_quoted(
                    __input,
                    __state,
                    __err_state,
                    __pos,
                    "\"",
                    (QuoteType::Double),
                );
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => __parse_quoted(
                        __input,
                        __state,
                        __err_state,
                        __pos,
                        "\'",
                        (QuoteType::Single),
                    ),
                }
            }
        }
        pub(super) fn string_literal<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_string_literal(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_string_literal(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_string_literal<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = __parse_multi_line_quote(__input, __state, __err_state, __pos);
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        __parse_single_line_quote(__input, __state, __err_state, __pos)
                    }
                }
            }
        }
        pub(super) fn shebang<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_shebang(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_shebang(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_shebang<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = {
                    let str_start = __pos;
                    match match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "#!") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            let __seq_res = {
                                let mut __repeat_pos = __pos;
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = {
                                        let __seq_res = {
                                            __err_state.suppress_fail += 1;
                                            let __assert_res = match __parse_line_ending(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(pos, _) => {
                                                    ::peg::RuleResult::Matched(pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                            __err_state.suppress_fail -= 1;
                                            match __assert_res {
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Matched(__pos, ())
                                                }
                                                ::peg::RuleResult::Matched(..) => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                match ::peg::ParseElem::parse_elem(__input, __pos) {
                                                    ::peg::RuleResult::Matched(__next, __ch) => {
                                                        match __ch {
                                                            _ => {
                                                                let __pos = __next;
                                                                let _ = ();
                                                                {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        (),
                                                                    )
                                                                }
                                                            }
                                                            _ => {
                                                                __err_state
                                                                    .mark_failure(__pos, "[_]");
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "[_]");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    };
                                    match __step_res {
                                        ::peg::RuleResult::Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                        }
                                        ::peg::RuleResult::Failed => {
                                            break;
                                        }
                                    }
                                }
                                ::peg::RuleResult::Matched(__repeat_pos, ())
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = match __parse_line_ending(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"#!\"");
                            ::peg::RuleResult::Failed
                        }
                    } {
                        ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                            __newpos,
                            ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, line) => ::peg::RuleResult::Matched(
                        __pos,
                        (|| TokenType::Shebang { line: line.into() }.into())(),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        pub(super) fn utf8_bom<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_utf8_bom(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_utf8_bom(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_utf8_bom<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = {
                    let str_start = __pos;
                    match match ::peg::ParseLiteral::parse_string_literal(
                        __input, __pos, "\u{feff}",
                    ) {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            ::peg::RuleResult::Matched(__pos, __val)
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"\\u{feff}\"");
                            ::peg::RuleResult::Failed
                        }
                    } {
                        ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                            __newpos,
                            ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, chars) => ::peg::RuleResult::Matched(
                        __pos,
                        (|| {
                            TokenType::Whitespace {
                                characters: chars.into(),
                            }
                            .into()
                        })(),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        pub(super) fn identifier<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_identifier(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_identifier(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_identifier<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = {
                    let __seq_res = {
                        let str_start = __pos;
                        match match ::peg::ParseElem::parse_elem(__input, __pos) {
                            ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                                '_' | 'a'..='z' | 'A'..='Z' => {
                                    let __pos = __next;
                                    let _ = ();
                                    {
                                        {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res =
                                                        match ::peg::ParseElem::parse_elem(
                                                            __input, __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(
                                                                __next,
                                                                __ch,
                                                            ) => match __ch {
                                                                '_'
                                                                | 'a'..='z'
                                                                | 'A'..='Z'
                                                                | '0'..='9' => {
                                                                    ::peg::RuleResult::Matched(
                                                                        __next,
                                                                        (),
                                                                    )
                                                                }
                                                                _ => {
                                                                    __err_state . mark_failure (__pos , "[\'_\' | \'a\' ..= \'z\' | \'A\' ..= \'Z\' | \'0\' ..= \'9\']") ;
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            },
                                                            ::peg::RuleResult::Failed => {
                                                                __err_state . mark_failure (__pos , "[\'_\' | \'a\' ..= \'z\' | \'A\' ..= \'Z\' | \'0\' ..= \'9\']") ;
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                    match __step_res {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => {
                                                            __repeat_pos = __newpos;
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Matched(__repeat_pos, ())
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    ::peg::RuleResult::Matched(__pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                    }
                                }
                                _ => {
                                    __err_state.mark_failure(
                                        __pos,
                                        "[\'_\' | \'a\' ..= \'z\' | \'A\' ..= \'Z\']",
                                    );
                                    ::peg::RuleResult::Failed
                                }
                            },
                            ::peg::RuleResult::Failed => {
                                __err_state.mark_failure(
                                    __pos,
                                    "[\'_\' | \'a\' ..= \'z\' | \'A\' ..= \'Z\']",
                                );
                                ::peg::RuleResult::Failed
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                                __newpos,
                                ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                            ),
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, id) => ::peg::RuleResult::Matched(
                            __pos,
                            (|| match parse_keyword(id) {
                                Some(symbol) => TokenType::Symbol { symbol }.into(),
                                None => TokenType::Identifier {
                                    identifier: id.into(),
                                }
                                .into(),
                            })(),
                        ),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "identifier");
                        ::peg::RuleResult::Failed
                    }
                }
            }
        }
        pub(super) fn comment<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_comment(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_comment(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_comment<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res =
                    match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "--") {
                        ::peg::RuleResult::Matched(__pos, __val) => {
                            let __seq_res =
                                __parse_multi_line_block(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, v) => ::peg::RuleResult::Matched(
                                    __pos,
                                    (|| {
                                        TokenType::MultiLineComment {
                                            blocks: v.0,
                                            comment: v.1.into(),
                                        }
                                        .into()
                                    })(),
                                ),
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => {
                            __err_state.mark_failure(__pos, "\"--\"");
                            ::peg::RuleResult::Failed
                        }
                    };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __choice_res =
                            match ::peg::ParseLiteral::parse_string_literal(__input, __pos, "--") {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    let __seq_res = match __parse_multi_line_start(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res =
                                                        match ::peg::ParseElem::parse_elem(
                                                            __input, __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(
                                                                __next,
                                                                __ch,
                                                            ) => match __ch {
                                                                _ => ::peg::RuleResult::Matched(
                                                                    __next,
                                                                    (),
                                                                ),
                                                                _ => {
                                                                    __err_state
                                                                        .mark_failure(__pos, "[_]");
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            },
                                                            ::peg::RuleResult::Failed => {
                                                                __err_state
                                                                    .mark_failure(__pos, "[_]");
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                    match __step_res {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => {
                                                            __repeat_pos = __newpos;
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Matched(__repeat_pos, ())
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    ::peg::RuleResult::Matched(
                                                        __pos,
                                                        (|| {
                                                            TokenizerErrorType::UnclosedComment
                                                                .into()
                                                        })(
                                                        ),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\"--\"");
                                    ::peg::RuleResult::Failed
                                }
                            };
                        match __choice_res {
                            ::peg::RuleResult::Matched(__pos, __value) => {
                                ::peg::RuleResult::Matched(__pos, __value)
                            }
                            ::peg::RuleResult::Failed => {
                                match ::peg::ParseLiteral::parse_string_literal(
                                    __input, __pos, "--",
                                ) {
                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                        let __seq_res = {
                                            let str_start = __pos;
                                            match {
                                                let mut __repeat_pos = __pos;
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res =
                                                        match ::peg::ParseElem::parse_elem(
                                                            __input, __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(
                                                                __next,
                                                                __ch,
                                                            ) => match __ch {
                                                                '\r' | '\n' => {
                                                                    __err_state.mark_failure(
                                                                        __pos,
                                                                        "[^ \'\\r\' | \'\\n\']",
                                                                    );
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                                _ => ::peg::RuleResult::Matched(
                                                                    __next,
                                                                    (),
                                                                ),
                                                            },
                                                            ::peg::RuleResult::Failed => {
                                                                __err_state.mark_failure(
                                                                    __pos,
                                                                    "[^ \'\\r\' | \'\\n\']",
                                                                );
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                    match __step_res {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => {
                                                            __repeat_pos = __newpos;
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Matched(__repeat_pos, ())
                                            } {
                                                ::peg::RuleResult::Matched(__newpos, _) => {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        ::peg::ParseSlice::parse_slice(
                                                            __input, str_start, __newpos,
                                                        ),
                                                    )
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, comment) => {
                                                ::peg::RuleResult::Matched(
                                                    __pos,
                                                    (|| {
                                                        TokenType::SingleLineComment {
                                                            comment: comment.into(),
                                                        }
                                                        .into()
                                                    })(
                                                    ),
                                                )
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "\"--\"");
                                        ::peg::RuleResult::Failed
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        fn __parse_roblox<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<()> {
            #![allow(non_snake_case, unused)]
            match (|| {
                if false {
                    Ok(())
                } else {
                    Err("roblox not enabled")
                }
            })() {
                Ok(res) => ::peg::RuleResult::Matched(__pos, res),
                Err(expected) => {
                    __err_state.mark_failure(__pos, expected);
                    ::peg::RuleResult::Failed
                }
            }
        }
        fn __parse_roblox_number<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = match __parse_roblox(__input, __state, __err_state, __pos) {
                    ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, _) => {
                        let __seq_res = {
                            let str_start = __pos;
                            match {
                                let __seq_res = {
                                    let __choice_res =
                                        match ::peg::ParseLiteral::parse_string_literal(
                                            __input, __pos, "0b",
                                        ) {
                                            ::peg::RuleResult::Matched(__pos, __val) => {
                                                ::peg::RuleResult::Matched(__pos, __val)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                __err_state.mark_failure(__pos, "\"0b\"");
                                                ::peg::RuleResult::Failed
                                            }
                                        };
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "0B",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"0B\"");
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        let __seq_res = {
                                            let mut __repeat_pos = __pos;
                                            let mut __repeat_value = ::alloc::vec::Vec::new();
                                            loop {
                                                let __pos = __repeat_pos;
                                                let __step_res = match ::peg::ParseElem::parse_elem(
                                                    __input, __pos,
                                                ) {
                                                    ::peg::RuleResult::Matched(__next, __ch) => {
                                                        match __ch {
                                                            '0' | '1' | '_' => {
                                                                ::peg::RuleResult::Matched(
                                                                    __next,
                                                                    (),
                                                                )
                                                            }
                                                            _ => {
                                                                __err_state.mark_failure(
                                                                    __pos,
                                                                    "[\'0\' | \'1\' | \'_\']",
                                                                );
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(
                                                            __pos,
                                                            "[\'0\' | \'1\' | \'_\']",
                                                        );
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __step_res {
                                                    ::peg::RuleResult::Matched(
                                                        __newpos,
                                                        __value,
                                                    ) => {
                                                        __repeat_pos = __newpos;
                                                        __repeat_value.push(__value);
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        break;
                                                    }
                                                }
                                            }
                                            if __repeat_value.len() >= 1 {
                                                ::peg::RuleResult::Matched(__repeat_pos, ())
                                            } else {
                                                ::peg::RuleResult::Failed
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                ::peg::RuleResult::Matched(__pos, ())
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(
                                        __newpos,
                                        ::peg::ParseSlice::parse_slice(
                                            __input, str_start, __newpos,
                                        ),
                                    )
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, n) => {
                                ::peg::RuleResult::Matched(__pos, (|| n)())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_hex_number<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = {
                    let __seq_res = match __parse_roblox(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match {
                                    let __seq_res = {
                                        let __choice_res =
                                            match ::peg::ParseLiteral::parse_string_literal(
                                                __input, __pos, "0x",
                                            ) {
                                                ::peg::RuleResult::Matched(__pos, __val) => {
                                                    ::peg::RuleResult::Matched(__pos, __val)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state.mark_failure(__pos, "\"0x\"");
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                        match __choice_res {
                                            ::peg::RuleResult::Matched(__pos, __value) => {
                                                ::peg::RuleResult::Matched(__pos, __value)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "0X",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"0X\"");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            let __seq_res = {
                                                let mut __repeat_pos = __pos;
                                                let mut __repeat_value = ::alloc::vec::Vec::new();
                                                loop {
                                                    let __pos = __repeat_pos;
                                                    let __step_res =
                                                        match ::peg::ParseElem::parse_elem(
                                                            __input, __pos,
                                                        ) {
                                                            ::peg::RuleResult::Matched(
                                                                __next,
                                                                __ch,
                                                            ) => match __ch {
                                                                '0'..='9'
                                                                | 'a'..='f'
                                                                | 'A'..='F'
                                                                | '_' => {
                                                                    ::peg::RuleResult::Matched(
                                                                        __next,
                                                                        (),
                                                                    )
                                                                }
                                                                _ => {
                                                                    __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'a\' ..= \'f\' | \'A\' ..= \'F\' | \'_\']") ;
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            },
                                                            ::peg::RuleResult::Failed => {
                                                                __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'a\' ..= \'f\' | \'A\' ..= \'F\' | \'_\']") ;
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        };
                                                    match __step_res {
                                                        ::peg::RuleResult::Matched(
                                                            __newpos,
                                                            __value,
                                                        ) => {
                                                            __repeat_pos = __newpos;
                                                            __repeat_value.push(__value);
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            break;
                                                        }
                                                    }
                                                }
                                                if __repeat_value.len() >= 1 {
                                                    ::peg::RuleResult::Matched(__repeat_pos, ())
                                                } else {
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, _) => {
                                                    ::peg::RuleResult::Matched(__pos, ())
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, n) => {
                                    ::peg::RuleResult::Matched(__pos, (|| n)())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __seq_res = {
                            __err_state.suppress_fail += 1;
                            let __assert_res =
                                match __parse_roblox(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            __err_state.suppress_fail -= 1;
                            match __assert_res {
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                                ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = {
                                    let str_start = __pos;
                                    match {
                                        let __seq_res = {
                                            let __choice_res =
                                                match ::peg::ParseLiteral::parse_string_literal(
                                                    __input, __pos, "0x",
                                                ) {
                                                    ::peg::RuleResult::Matched(__pos, __val) => {
                                                        ::peg::RuleResult::Matched(__pos, __val)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        __err_state.mark_failure(__pos, "\"0x\"");
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                            match __choice_res {
                                                ::peg::RuleResult::Matched(__pos, __value) => {
                                                    ::peg::RuleResult::Matched(__pos, __value)
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "0X",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => {
                                                            ::peg::RuleResult::Matched(__pos, __val)
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state
                                                                .mark_failure(__pos, "\"0X\"");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                            }
                                        };
                                        match __seq_res {
                                            ::peg::RuleResult::Matched(__pos, _) => {
                                                let __seq_res = {
                                                    let mut __repeat_pos = __pos;
                                                    let mut __repeat_value =
                                                        ::alloc::vec::Vec::new();
                                                    loop {
                                                        let __pos = __repeat_pos;
                                                        let __step_res =
                                                            match ::peg::ParseElem::parse_elem(
                                                                __input, __pos,
                                                            ) {
                                                                ::peg::RuleResult::Matched(
                                                                    __next,
                                                                    __ch,
                                                                ) => match __ch {
                                                                    '0'..='9'
                                                                    | 'a'..='f'
                                                                    | 'A'..='F' => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __next,
                                                                            (),
                                                                        )
                                                                    }
                                                                    _ => {
                                                                        __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'a\' ..= \'f\' | \'A\' ..= \'F\']") ;
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                },
                                                                ::peg::RuleResult::Failed => {
                                                                    __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'a\' ..= \'f\' | \'A\' ..= \'F\']") ;
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            };
                                                        match __step_res {
                                                            ::peg::RuleResult::Matched(
                                                                __newpos,
                                                                __value,
                                                            ) => {
                                                                __repeat_pos = __newpos;
                                                                __repeat_value.push(__value);
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if __repeat_value.len() >= 1 {
                                                        ::peg::RuleResult::Matched(__repeat_pos, ())
                                                    } else {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                };
                                                match __seq_res {
                                                    ::peg::RuleResult::Matched(__pos, _) => {
                                                        ::peg::RuleResult::Matched(__pos, ())
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        ::peg::RuleResult::Failed
                                                    }
                                                }
                                            }
                                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(
                                                __newpos,
                                                ::peg::ParseSlice::parse_slice(
                                                    __input, str_start, __newpos,
                                                ),
                                            )
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, n) => {
                                        ::peg::RuleResult::Matched(__pos, (|| n)())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            }
        }
        fn __parse_digit_with_separator<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = {
                    let __seq_res = match __parse_roblox(__input, __state, __err_state, __pos) {
                        ::peg::RuleResult::Matched(pos, _) => ::peg::RuleResult::Matched(pos, ()),
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match match ::peg::ParseElem::parse_elem(__input, __pos) {
                                    ::peg::RuleResult::Matched(__next, __ch) => match __ch {
                                        '0'..='9' => {
                                            let __pos = __next;
                                            let _ = ();
                                            {
                                                {
                                                    let __seq_res = {
                                                        let mut __repeat_pos = __pos;
                                                        loop {
                                                            let __pos = __repeat_pos;
                                                            let __step_res = match :: peg :: ParseElem :: parse_elem (__input , __pos) { :: peg :: RuleResult :: Matched (__next , __ch) => match __ch { '0' ..= '9' | '_' => :: peg :: RuleResult :: Matched (__next , ()) , _ => { __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'_\']") ; :: peg :: RuleResult :: Failed } } , :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "[\'0\' ..= \'9\' | \'_\']") ; :: peg :: RuleResult :: Failed } } ;
                                                            match __step_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __newpos,
                                                                    __value,
                                                                ) => {
                                                                    __repeat_pos = __newpos;
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        ::peg::RuleResult::Matched(__repeat_pos, ())
                                                    };
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, _) => {
                                                            ::peg::RuleResult::Matched(__pos, ())
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        _ => {
                                            __err_state.mark_failure(__pos, "[\'0\' ..= \'9\']");
                                            ::peg::RuleResult::Failed
                                        }
                                    },
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "[\'0\' ..= \'9\']");
                                        ::peg::RuleResult::Failed
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(
                                            __newpos,
                                            ::peg::ParseSlice::parse_slice(
                                                __input, str_start, __newpos,
                                            ),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, n) => {
                                    ::peg::RuleResult::Matched(__pos, (|| n)())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                };
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __seq_res = {
                            __err_state.suppress_fail += 1;
                            let __assert_res =
                                match __parse_roblox(__input, __state, __err_state, __pos) {
                                    ::peg::RuleResult::Matched(pos, _) => {
                                        ::peg::RuleResult::Matched(pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                };
                            __err_state.suppress_fail -= 1;
                            match __assert_res {
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                                ::peg::RuleResult::Matched(..) => ::peg::RuleResult::Failed,
                            }
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = {
                                    let str_start = __pos;
                                    match {
                                        let mut __repeat_pos = __pos;
                                        let mut __repeat_value = ::alloc::vec::Vec::new();
                                        loop {
                                            let __pos = __repeat_pos;
                                            let __step_res = match ::peg::ParseElem::parse_elem(
                                                __input, __pos,
                                            ) {
                                                ::peg::RuleResult::Matched(__next, __ch) => {
                                                    match __ch {
                                                        '0'..='9' => {
                                                            ::peg::RuleResult::Matched(__next, ())
                                                        }
                                                        _ => {
                                                            __err_state.mark_failure(
                                                                __pos,
                                                                "[\'0\' ..= \'9\']",
                                                            );
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    __err_state
                                                        .mark_failure(__pos, "[\'0\' ..= \'9\']");
                                                    ::peg::RuleResult::Failed
                                                }
                                            };
                                            match __step_res {
                                                ::peg::RuleResult::Matched(__newpos, __value) => {
                                                    __repeat_pos = __newpos;
                                                    __repeat_value.push(__value);
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    break;
                                                }
                                            }
                                        }
                                        if __repeat_value.len() >= 1 {
                                            ::peg::RuleResult::Matched(__repeat_pos, ())
                                        } else {
                                            ::peg::RuleResult::Failed
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(
                                                __newpos,
                                                ::peg::ParseSlice::parse_slice(
                                                    __input, str_start, __newpos,
                                                ),
                                            )
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, n) => {
                                        ::peg::RuleResult::Matched(__pos, (|| n)())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                }
            }
        }
        fn __parse_basic_number<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            {
                let str_start = __pos;
                match {
                    let __seq_res =
                        match __parse_digit_with_separator(__input, __state, __err_state, __pos) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        };
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, _) => {
                            let __seq_res = match match ::peg::ParseLiteral::parse_string_literal(
                                __input, __pos, ".",
                            ) {
                                ::peg::RuleResult::Matched(__pos, __val) => {
                                    let __seq_res = match match __parse_digit_with_separator(
                                        __input,
                                        __state,
                                        __err_state,
                                        __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(pos, _) => {
                                            ::peg::RuleResult::Matched(pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => {
                                    __err_state.mark_failure(__pos, "\".\"");
                                    ::peg::RuleResult::Failed
                                }
                            } {
                                ::peg::RuleResult::Matched(__newpos, _) => {
                                    ::peg::RuleResult::Matched(__newpos, ())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, ()),
                            };
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, _) => {
                                    let __seq_res = match match ::peg::ParseElem::parse_elem(
                                        __input, __pos,
                                    ) {
                                        ::peg::RuleResult::Matched(__next, __ch) => {
                                            match __ch {
                                                'e' | 'E' => {
                                                    let __pos = __next;
                                                    let _ = ();
                                                    {
                                                        {
                                                            let __seq_res = match match :: peg :: ParseElem :: parse_elem (__input , __pos) { :: peg :: RuleResult :: Matched (__next , __ch) => match __ch { '-' | '+' => :: peg :: RuleResult :: Matched (__next , ()) , _ => { __err_state . mark_failure (__pos , "[\'-\' | \'+\']") ; :: peg :: RuleResult :: Failed } } , :: peg :: RuleResult :: Failed => { __err_state . mark_failure (__pos , "[\'-\' | \'+\']") ; :: peg :: RuleResult :: Failed } } { :: peg :: RuleResult :: Matched (__newpos , _) => { :: peg :: RuleResult :: Matched (__newpos , ()) } :: peg :: RuleResult :: Failed => { :: peg :: RuleResult :: Matched (__pos , ()) } } ;
                                                            match __seq_res {
                                                                ::peg::RuleResult::Matched(
                                                                    __pos,
                                                                    _,
                                                                ) => {
                                                                    let __seq_res = match __parse_digit_with_separator (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                    match __seq_res { :: peg :: RuleResult :: Matched (__pos , _) => { :: peg :: RuleResult :: Matched (__pos , ()) } :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , }
                                                                }
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                _ => {
                                                    __err_state
                                                        .mark_failure(__pos, "[\'e\' | \'E\']");
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __err_state.mark_failure(__pos, "[\'e\' | \'E\']");
                                            ::peg::RuleResult::Failed
                                        }
                                    } {
                                        ::peg::RuleResult::Matched(__newpos, _) => {
                                            ::peg::RuleResult::Matched(__newpos, ())
                                        }
                                        ::peg::RuleResult::Failed => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                    };
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, _) => {
                                            ::peg::RuleResult::Matched(__pos, ())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                        __newpos,
                        ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_no_int_fractional_number<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<&'input str> {
            #![allow(non_snake_case, unused)]
            {
                let str_start = __pos;
                match match ::peg::ParseLiteral::parse_string_literal(__input, __pos, ".") {
                    ::peg::RuleResult::Matched(__pos, __val) => {
                        let __seq_res = match __parse_digit_with_separator(
                            __input,
                            __state,
                            __err_state,
                            __pos,
                        ) {
                            ::peg::RuleResult::Matched(pos, _) => {
                                ::peg::RuleResult::Matched(pos, ())
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, _) => {
                                let __seq_res = match match ::peg::ParseElem::parse_elem(
                                    __input, __pos,
                                ) {
                                    ::peg::RuleResult::Matched(__next, __ch) => {
                                        match __ch {
                                            'e' | 'E' => {
                                                let __pos = __next;
                                                let _ = ();
                                                {
                                                    {
                                                        let __seq_res =
                                                            match match ::peg::ParseElem::parse_elem(
                                                                __input, __pos,
                                                            ) {
                                                                ::peg::RuleResult::Matched(
                                                                    __next,
                                                                    __ch,
                                                                ) => match __ch {
                                                                    '-' | '+' => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __next,
                                                                            (),
                                                                        )
                                                                    }
                                                                    _ => {
                                                                        __err_state.mark_failure(
                                                                            __pos,
                                                                            "[\'-\' | \'+\']",
                                                                        );
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                },
                                                                ::peg::RuleResult::Failed => {
                                                                    __err_state.mark_failure(
                                                                        __pos,
                                                                        "[\'-\' | \'+\']",
                                                                    );
                                                                    ::peg::RuleResult::Failed
                                                                }
                                                            } {
                                                                ::peg::RuleResult::Matched(
                                                                    __newpos,
                                                                    _,
                                                                ) => ::peg::RuleResult::Matched(
                                                                    __newpos,
                                                                    (),
                                                                ),
                                                                ::peg::RuleResult::Failed => {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        (),
                                                                    )
                                                                }
                                                            };
                                                        match __seq_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                _,
                                                            ) => {
                                                                let __seq_res = match __parse_digit_with_separator (__input , __state , __err_state , __pos) { :: peg :: RuleResult :: Matched (pos , _) => :: peg :: RuleResult :: Matched (pos , ()) , :: peg :: RuleResult :: Failed => :: peg :: RuleResult :: Failed , } ;
                                                                match __seq_res {
                                                                    ::peg::RuleResult::Matched(
                                                                        __pos,
                                                                        _,
                                                                    ) => {
                                                                        ::peg::RuleResult::Matched(
                                                                            __pos,
                                                                            (),
                                                                        )
                                                                    }
                                                                    ::peg::RuleResult::Failed => {
                                                                        ::peg::RuleResult::Failed
                                                                    }
                                                                }
                                                            }
                                                            ::peg::RuleResult::Failed => {
                                                                ::peg::RuleResult::Failed
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            _ => {
                                                __err_state.mark_failure(__pos, "[\'e\' | \'E\']");
                                                ::peg::RuleResult::Failed
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Failed => {
                                        __err_state.mark_failure(__pos, "[\'e\' | \'E\']");
                                        ::peg::RuleResult::Failed
                                    }
                                } {
                                    ::peg::RuleResult::Matched(__newpos, _) => {
                                        ::peg::RuleResult::Matched(__newpos, ())
                                    }
                                    ::peg::RuleResult::Failed => {
                                        ::peg::RuleResult::Matched(__pos, ())
                                    }
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, _) => {
                                        ::peg::RuleResult::Matched(__pos, ())
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => {
                        __err_state.mark_failure(__pos, "\".\"");
                        ::peg::RuleResult::Failed
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, _) => ::peg::RuleResult::Matched(
                        __newpos,
                        ::peg::ParseSlice::parse_slice(__input, str_start, __newpos),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        pub(super) fn number<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_number(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_number(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_number<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = {
                    let __choice_res = __parse_roblox_number(__input, __state, __err_state, __pos);
                    match __choice_res {
                        ::peg::RuleResult::Matched(__pos, __value) => {
                            ::peg::RuleResult::Matched(__pos, __value)
                        }
                        ::peg::RuleResult::Failed => {
                            let __choice_res =
                                __parse_hex_number(__input, __state, __err_state, __pos);
                            match __choice_res {
                                ::peg::RuleResult::Matched(__pos, __value) => {
                                    ::peg::RuleResult::Matched(__pos, __value)
                                }
                                ::peg::RuleResult::Failed => {
                                    let __choice_res =
                                        __parse_basic_number(__input, __state, __err_state, __pos);
                                    match __choice_res {
                                        ::peg::RuleResult::Matched(__pos, __value) => {
                                            ::peg::RuleResult::Matched(__pos, __value)
                                        }
                                        ::peg::RuleResult::Failed => {
                                            __parse_no_int_fractional_number(
                                                __input,
                                                __state,
                                                __err_state,
                                                __pos,
                                            )
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, n) => ::peg::RuleResult::Matched(
                        __pos,
                        (|| TokenType::Number { text: n.into() }.into())(),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        pub(super) fn symbol<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<RawToken, ::peg::error::ParseError<PositionRepr>> {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_symbol(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_symbol(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_symbol<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = __input.parse_symbol(__pos);
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, symbol) => ::peg::RuleResult::Matched(
                        __pos,
                        (|| TokenType::Symbol { symbol }.into())(),
                    ),
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
        fn __parse_token<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<RawToken> {
            #![allow(non_snake_case, unused)]
            {
                let __choice_res = __parse_whitespace(__input, __state, __err_state, __pos);
                match __choice_res {
                    ::peg::RuleResult::Matched(__pos, __value) => {
                        ::peg::RuleResult::Matched(__pos, __value)
                    }
                    ::peg::RuleResult::Failed => {
                        let __choice_res = __parse_comment(__input, __state, __err_state, __pos);
                        match __choice_res {
                            ::peg::RuleResult::Matched(__pos, __value) => {
                                ::peg::RuleResult::Matched(__pos, __value)
                            }
                            ::peg::RuleResult::Failed => {
                                let __choice_res =
                                    __parse_number(__input, __state, __err_state, __pos);
                                match __choice_res {
                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                        ::peg::RuleResult::Matched(__pos, __value)
                                    }
                                    ::peg::RuleResult::Failed => {
                                        let __choice_res = __parse_string_literal(
                                            __input,
                                            __state,
                                            __err_state,
                                            __pos,
                                        );
                                        match __choice_res {
                                            ::peg::RuleResult::Matched(__pos, __value) => {
                                                ::peg::RuleResult::Matched(__pos, __value)
                                            }
                                            ::peg::RuleResult::Failed => {
                                                let __choice_res =
                                                    match ::peg::ParseLiteral::parse_string_literal(
                                                        __input, __pos, "#!",
                                                    ) {
                                                        ::peg::RuleResult::Matched(
                                                            __pos,
                                                            __val,
                                                        ) => ::peg::RuleResult::Matched(
                                                            __pos,
                                                            (|| {
                                                                TokenizerErrorType :: UnexpectedShebang . into ()
                                                            })(
                                                            ),
                                                        ),
                                                        ::peg::RuleResult::Failed => {
                                                            __err_state
                                                                .mark_failure(__pos, "\"#!\"");
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    };
                                                match __choice_res {
                                                    ::peg::RuleResult::Matched(__pos, __value) => {
                                                        ::peg::RuleResult::Matched(__pos, __value)
                                                    }
                                                    ::peg::RuleResult::Failed => {
                                                        let __choice_res = __parse_symbol(
                                                            __input,
                                                            __state,
                                                            __err_state,
                                                            __pos,
                                                        );
                                                        match __choice_res {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                __value,
                                                            ) => ::peg::RuleResult::Matched(
                                                                __pos, __value,
                                                            ),
                                                            ::peg::RuleResult::Failed => {
                                                                __parse_identifier(
                                                                    __input,
                                                                    __state,
                                                                    __err_state,
                                                                    __pos,
                                                                )
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        pub(crate) fn tokens<'input>(
            __input: &'input Input,
        ) -> ::std::result::Result<Vec<(RawToken, usize)>, ::peg::error::ParseError<PositionRepr>>
        {
            #![allow(non_snake_case, unused)]
            let mut __err_state = ::peg::error::ErrorState::new(::peg::Parse::start(__input));
            let mut __state = ParseState::new();
            match __parse_tokens(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        return Ok(__value);
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            __state = ParseState::new();
            __err_state.reparse_for_error();
            match __parse_tokens(
                __input,
                &mut __state,
                &mut __err_state,
                ::peg::Parse::start(__input),
            ) {
                ::peg::RuleResult::Matched(__pos, __value) => {
                    if ::peg::Parse::is_eof(__input, __pos) {
                        {
                            :: std :: rt :: begin_panic ("Parser is nondeterministic: succeeded when reparsing for error position")
                        };
                    } else {
                        __err_state.mark_failure(__pos, "EOF");
                    }
                }
                _ => (),
            }
            Err(__err_state.into_parse_error(__input))
        }
        fn __parse_tokens<'input>(
            __input: &'input Input,
            __state: &mut ParseState<'input>,
            __err_state: &mut ::peg::error::ErrorState,
            __pos: usize,
        ) -> ::peg::RuleResult<Vec<(RawToken, usize)>> {
            #![allow(non_snake_case, unused)]
            {
                let __seq_res = match {
                    let __seq_res = __parse_utf8_bom(__input, __state, __err_state, __pos);
                    match __seq_res {
                        ::peg::RuleResult::Matched(__pos, bom) => {
                            let __seq_res = ::peg::RuleResult::Matched(__pos, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, pos) => {
                                    ::peg::RuleResult::Matched(__pos, (|| (bom, pos))())
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        }
                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                    }
                } {
                    ::peg::RuleResult::Matched(__newpos, __value) => {
                        ::peg::RuleResult::Matched(__newpos, Some(__value))
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                };
                match __seq_res {
                    ::peg::RuleResult::Matched(__pos, bom) => {
                        let __seq_res = match {
                            let __seq_res = __parse_shebang(__input, __state, __err_state, __pos);
                            match __seq_res {
                                ::peg::RuleResult::Matched(__pos, shebang) => {
                                    let __seq_res = ::peg::RuleResult::Matched(__pos, __pos);
                                    match __seq_res {
                                        ::peg::RuleResult::Matched(__pos, pos) => {
                                            ::peg::RuleResult::Matched(__pos, (|| (shebang, pos))())
                                        }
                                        ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                    }
                                }
                                ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                            }
                        } {
                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                ::peg::RuleResult::Matched(__newpos, Some(__value))
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Matched(__pos, None),
                        };
                        match __seq_res {
                            ::peg::RuleResult::Matched(__pos, shebang) => {
                                let __seq_res = {
                                    let mut __repeat_pos = __pos;
                                    let mut __repeat_value = ::alloc::vec::Vec::new();
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = {
                                            let __seq_res =
                                                __parse_token(__input, __state, __err_state, __pos);
                                            match __seq_res {
                                                ::peg::RuleResult::Matched(__pos, token) => {
                                                    let __seq_res =
                                                        ::peg::RuleResult::Matched(__pos, __pos);
                                                    match __seq_res {
                                                        ::peg::RuleResult::Matched(__pos, pos) => {
                                                            ::peg::RuleResult::Matched(
                                                                __pos,
                                                                (|| (token, pos))(),
                                                            )
                                                        }
                                                        ::peg::RuleResult::Failed => {
                                                            ::peg::RuleResult::Failed
                                                        }
                                                    }
                                                }
                                                ::peg::RuleResult::Failed => {
                                                    ::peg::RuleResult::Failed
                                                }
                                            }
                                        };
                                        match __step_res {
                                            ::peg::RuleResult::Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                                __repeat_value.push(__value);
                                            }
                                            ::peg::RuleResult::Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    ::peg::RuleResult::Matched(__repeat_pos, __repeat_value)
                                };
                                match __seq_res {
                                    ::peg::RuleResult::Matched(__pos, body) => {
                                        ::peg::RuleResult::Matched(
                                            __pos,
                                            (|| {
                                                let mut body = body;
                                                if let Some(shebang) = shebang {
                                                    body.insert(0, shebang)
                                                }
                                                if let Some(bom) = bom {
                                                    body.insert(0, bom)
                                                }
                                                body
                                            })(),
                                        )
                                    }
                                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                                }
                            }
                            ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                        }
                    }
                    ::peg::RuleResult::Failed => ::peg::RuleResult::Failed,
                }
            }
        }
    }
    /// Information about an error that occurs while tokenizing
    pub struct TokenizerError {
        /// The type of error
        error: TokenizerErrorType,
        /// The position of the token that caused the error
        position: Position,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenizerError {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "error" => _serde::export::Ok(__Field::__field0),
                            "position" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"error" => _serde::export::Ok(__Field::__field0),
                            b"position" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TokenizerError>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenizerError;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TokenizerError")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenizerErrorType,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TokenizerError with 2 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Position>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenizerError with 2 elements",
                                    ));
                                }
                            };
                        _serde::export::Ok(TokenizerError {
                            error: __field0,
                            position: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenizerErrorType> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Position> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "error",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenizerErrorType>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "position",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Position>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("error") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("position") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(TokenizerError {
                            error: __field0,
                            position: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["error", "position"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenizerError",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TokenizerError>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenizerError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenizerError",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "error",
                    &self.error,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "position",
                    &self.position,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for TokenizerError {
        #[inline]
        fn clone(&self) -> TokenizerError {
            match *self {
                TokenizerError {
                    error: ref __self_0_0,
                    position: ref __self_0_1,
                } => TokenizerError {
                    error: ::core::clone::Clone::clone(&(*__self_0_0)),
                    position: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for TokenizerError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                TokenizerError {
                    error: ref __self_0_0,
                    position: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "TokenizerError");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "error",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "position",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for TokenizerError {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for TokenizerError {
        #[inline]
        fn eq(&self, other: &TokenizerError) -> bool {
            match *other {
                TokenizerError {
                    error: ref __self_1_0,
                    position: ref __self_1_1,
                } => match *self {
                    TokenizerError {
                        error: ref __self_0_0,
                        position: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenizerError) -> bool {
            match *other {
                TokenizerError {
                    error: ref __self_1_0,
                    position: ref __self_1_1,
                } => match *self {
                    TokenizerError {
                        error: ref __self_0_0,
                        position: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl TokenizerError {
        /// The type of error
        pub fn error(&self) -> &TokenizerErrorType {
            &self.error
        }
        /// The position of the token that caused the error
        pub fn position(&self) -> Position {
            self.position
        }
    }
    impl fmt::Display for TokenizerError {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["", " at line ", ", column "],
                &match (
                    &match &self.error {
                        TokenizerErrorType::UnclosedComment => "unclosed comment".to_string(),
                        TokenizerErrorType::UnclosedString => "unclosed string".to_string(),
                        TokenizerErrorType::UnexpectedShebang => "unexpected shebang".to_string(),
                        TokenizerErrorType::UnexpectedToken(character) => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["unexpected character "],
                                &match (&character,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        }
                        TokenizerErrorType::InvalidSymbol(symbol) => {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["invalid symbol "],
                                &match (&symbol,) {
                                    (arg0,) => [::core::fmt::ArgumentV1::new(
                                        arg0,
                                        ::core::fmt::Display::fmt,
                                    )],
                                },
                            ));
                            res
                        }
                    },
                    &self.position.line,
                    &self.position.character,
                ) {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            ))
        }
    }
    impl std::error::Error for TokenizerError {}
    impl From<peg::str::LineCol> for Position {
        fn from(location: peg::str::LineCol) -> Position {
            Position {
                bytes: location.offset,
                line: location.line,
                character: location.column,
            }
        }
    }
    struct TokenCollector {
        result: Vec<Token>,
    }
    impl TokenCollector {
        fn new() -> Self {
            Self { result: Vec::new() }
        }
        fn push(
            &mut self,
            start_position: Position,
            raw_token: RawToken,
            end_position: Position,
        ) -> Result<(), TokenizerError> {
            match raw_token {
                Ok(token_type) => {
                    self.result.push(Token {
                        start_position,
                        end_position,
                        token_type,
                    });
                    Ok(())
                }
                Err(error) => Err(TokenizerError {
                    error,
                    position: start_position,
                }),
            }
        }
        fn finish(mut self, eof_position: Position) -> Vec<Token> {
            self.result.push(Token {
                start_position: eof_position,
                end_position: eof_position,
                token_type: TokenType::Eof,
            });
            self.result
        }
    }
    fn from_parser_error(
        code: &'_ str,
    ) -> impl Fn(peg::error::ParseError<peg::str::LineCol>) -> TokenizerError + '_ {
        move |err| TokenizerError {
            error: TokenizerErrorType::UnexpectedToken(
                code[err.location.offset..].chars().next().expect(
                    "(internal full-moon error) Text overflow while giving unexpected token error",
                ),
            ),
            position: err.location.into(),
        }
    }
    /// Returns a list of tokens.
    /// You probably want [`parse`](crate::parse) instead.
    ///
    /// # Errors
    ///
    /// If the code passed is malformed from normal Lua expectations,
    /// a [`TokenizerError`] will be returned.
    ///
    /// ```rust
    /// # use full_moon::tokenizer::tokens;
    /// assert!(tokens("local x = 1").is_ok());
    /// assert!(tokens("local 4 = end").is_ok()); // tokens does *not* check validity of code, only tokenizing
    /// assert!(tokens("--[[ Unclosed comment!").is_err());
    /// ```
    pub fn tokens(code: &str) -> Result<Vec<Token>, TokenizerError> {
        let mut tokens = TokenCollector::new();
        let mut raw_tokens = tokens::tokens(code).map_err(from_parser_error(code))?;
        let mut raw_tokens = raw_tokens.drain(..);
        let mut position = Position {
            bytes: 0,
            character: 1,
            line: 1,
        };
        let mut next_is_new_line = false;
        let mut start_position = position;
        if let Some((mut token_type, mut token_offset)) = raw_tokens.next() {
            for character in code.chars() {
                if character == '\n' {
                    next_is_new_line = true;
                } else {
                    position.character += 1;
                }
                position.bytes += character.len_utf8();
                let end_position = position;
                if next_is_new_line {
                    next_is_new_line = false;
                    position.line += 1;
                    position.character = 1;
                }
                if token_offset == end_position.bytes {
                    tokens.push(start_position, token_type, end_position)?;
                    start_position = position;
                    if let Some((next_token_type, next_token_offset)) = raw_tokens.next() {
                        token_type = next_token_type;
                        token_offset = next_token_offset;
                    } else {
                        break;
                    }
                }
            }
        }
        if let Some((token_type, token_offset)) = raw_tokens.next() {
            {
                ::std::rt::panic_fmt(::core::fmt::Arguments::new_v1(
                    &[
                        "(internal full-moon error) Found token ",
                        " with offset ",
                        " which is past the end of source",
                    ],
                    &match (&token_type, &token_offset) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Debug::fmt),
                        ],
                    },
                ))
            };
        }
        Ok(tokens.finish(position))
    }
}
/// Used to create visitors that recurse through [`Ast`](ast::Ast) nodes.
pub mod visitors {
    use crate::{
        ast::{span::ContainedSpan, *},
        plugins::{DefaultPlugin, Plugin},
        private::Sealed,
        tokenizer::{Token, TokenReference},
    };
    #[doc(hidden)]
    pub trait Visit<P: Plugin = DefaultPlugin>: Sealed {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V);
    }
    #[doc(hidden)]
    pub trait VisitMut<P: Plugin = DefaultPlugin>: Sealed
    where
        Self: Sized,
    {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self;
    }
    impl<P: Plugin, T: Visit<P>> Visit<P> for &T {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            (**self).visit(visitor);
        }
    }
    impl<P: Plugin, T: Visit<P>> Visit<P> for &mut T {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            (**self).visit(visitor);
        }
    }
    impl<P: Plugin, T: Visit<P>> Visit<P> for Vec<T> {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            for item in self {
                item.visit(visitor);
            }
        }
    }
    impl<P: Plugin, T: VisitMut<P>> VisitMut<P> for Vec<T> {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            self.into_iter()
                .map(|item| item.visit_mut(visitor))
                .collect()
        }
    }
    impl<P: Plugin, T: Visit<P>> Visit<P> for Option<T> {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            if let Some(item) = self {
                item.visit(visitor);
            }
        }
    }
    impl<P: Plugin, T: VisitMut<P>> VisitMut<P> for Option<T> {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            self.map(|item| item.visit_mut(visitor))
        }
    }
    impl<P: Plugin, A: Visit<P>, B: Visit<P>> Visit<P> for (A, B) {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            self.0.visit(visitor);
            self.1.visit(visitor);
        }
    }
    impl<P: Plugin, A: VisitMut<P>, B: VisitMut<P>> VisitMut<P> for (A, B) {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            (self.0.visit_mut(visitor), self.1.visit_mut(visitor))
        }
    }
    impl<P: Plugin, T: Visit<P>> Visit<P> for Box<T> {
        fn visit<V: Visitor<P>>(&self, visitor: &mut V) {
            (**self).visit(visitor);
        }
    }
    impl<P: Plugin, T: VisitMut<P>> VisitMut<P> for Box<T> {
        fn visit_mut<V: VisitorMut<P>>(self, visitor: &mut V) -> Self {
            Box::new((*self).visit_mut(visitor))
        }
    }
    /// A trait that implements functions to listen for specific nodes/tokens.
    /// Unlike [`VisitorMut`], nodes/tokens passed are immutable.
    ///
    /// ```rust
    /// # use full_moon::ast;
    /// # use full_moon::visitors::*;
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// // A visitor that logs every local assignment made
    /// #[derive(Default)]
    /// struct LocalVariableVisitor {
    ///     names: Vec<String>,
    /// }
    ///
    /// impl Visitor for LocalVariableVisitor {
    ///     fn visit_local_assignment(&mut self, local_assignment: &ast::LocalAssignment) {
    ///         self.names.extend(&mut local_assignment.names().iter().map(|name| name.token().to_string()));
    ///     }
    /// }
    ///
    /// let mut visitor = LocalVariableVisitor::default();
    /// visitor.visit_ast(&full_moon::parse("local x = 1; local y, z = 2, 3")?);
    /// assert_eq!(visitor.names, vec!["x", "y", "z"]);
    /// # Ok(())
    /// # }
    /// ```
    pub trait Visitor<P: Plugin = DefaultPlugin> {
        /// Visit the nodes of an [`Ast`](crate::ast::Ast)
        fn visit_ast(&mut self, ast: &Ast)
        where
            Self: Sized,
        {
            ast.nodes().visit(self);
            ast.eof().visit(self);
        }
        #[allow(missing_docs)]
        fn visit_anonymous_call(&mut self, _node: &FunctionArgs) {}
        #[allow(missing_docs)]
        fn visit_anonymous_call_end(&mut self, _node: &FunctionArgs) {}
        #[allow(missing_docs)]
        fn visit_assignment(&mut self, _node: &Assignment) {}
        #[allow(missing_docs)]
        fn visit_assignment_end(&mut self, _node: &Assignment) {}
        #[allow(missing_docs)]
        fn visit_block(&mut self, _node: &Block<P>) {}
        #[allow(missing_docs)]
        fn visit_block_end(&mut self, _node: &Block<P>) {}
        #[allow(missing_docs)]
        fn visit_call(&mut self, _node: &Call<P>) {}
        #[allow(missing_docs)]
        fn visit_call_end(&mut self, _node: &Call<P>) {}
        #[allow(missing_docs)]
        fn visit_contained_span(&mut self, _node: &ContainedSpan) {}
        #[allow(missing_docs)]
        fn visit_contained_span_end(&mut self, _node: &ContainedSpan) {}
        #[allow(missing_docs)]
        fn visit_do(&mut self, _node: &Do<P>) {}
        #[allow(missing_docs)]
        fn visit_do_end(&mut self, _node: &Do<P>) {}
        #[allow(missing_docs)]
        fn visit_else_if(&mut self, _node: &ElseIf<P>) {}
        #[allow(missing_docs)]
        fn visit_else_if_end(&mut self, _node: &ElseIf<P>) {}
        #[allow(missing_docs)]
        fn visit_eof(&mut self, _node: &TokenReference) {}
        #[allow(missing_docs)]
        fn visit_eof_end(&mut self, _node: &TokenReference) {}
        #[allow(missing_docs)]
        fn visit_expression(&mut self, _node: &Expression<P>) {}
        #[allow(missing_docs)]
        fn visit_expression_end(&mut self, _node: &Expression<P>) {}
        #[allow(missing_docs)]
        fn visit_field(&mut self, _node: &Field<P>) {}
        #[allow(missing_docs)]
        fn visit_field_end(&mut self, _node: &Field<P>) {}
        #[allow(missing_docs)]
        fn visit_function_args(&mut self, _node: &FunctionArgs<P>) {}
        #[allow(missing_docs)]
        fn visit_function_args_end(&mut self, _node: &FunctionArgs<P>) {}
        #[allow(missing_docs)]
        fn visit_function_body(&mut self, _node: &FunctionBody<P>) {}
        #[allow(missing_docs)]
        fn visit_function_body_end(&mut self, _node: &FunctionBody<P>) {}
        #[allow(missing_docs)]
        fn visit_function_call(&mut self, _node: &FunctionCall<P>) {}
        #[allow(missing_docs)]
        fn visit_function_call_end(&mut self, _node: &FunctionCall<P>) {}
        #[allow(missing_docs)]
        fn visit_function_declaration(&mut self, _node: &FunctionDeclaration<P>) {}
        #[allow(missing_docs)]
        fn visit_function_declaration_end(&mut self, _node: &FunctionDeclaration<P>) {}
        #[allow(missing_docs)]
        fn visit_function_name(&mut self, _node: &FunctionName<P>) {}
        #[allow(missing_docs)]
        fn visit_function_name_end(&mut self, _node: &FunctionName<P>) {}
        #[allow(missing_docs)]
        fn visit_generic_for(&mut self, _node: &GenericFor<P>) {}
        #[allow(missing_docs)]
        fn visit_generic_for_end(&mut self, _node: &GenericFor<P>) {}
        #[allow(missing_docs)]
        fn visit_if(&mut self, _node: &If<P>) {}
        #[allow(missing_docs)]
        fn visit_if_end(&mut self, _node: &If<P>) {}
        #[allow(missing_docs)]
        fn visit_index(&mut self, _node: &Index<P>) {}
        #[allow(missing_docs)]
        fn visit_index_end(&mut self, _node: &Index<P>) {}
        #[allow(missing_docs)]
        fn visit_local_assignment(&mut self, _node: &LocalAssignment<P>) {}
        #[allow(missing_docs)]
        fn visit_local_assignment_end(&mut self, _node: &LocalAssignment<P>) {}
        #[allow(missing_docs)]
        fn visit_local_function(&mut self, _node: &LocalFunction<P>) {}
        #[allow(missing_docs)]
        fn visit_local_function_end(&mut self, _node: &LocalFunction<P>) {}
        #[allow(missing_docs)]
        fn visit_last_stmt(&mut self, _node: &LastStmt<P>) {}
        #[allow(missing_docs)]
        fn visit_last_stmt_end(&mut self, _node: &LastStmt<P>) {}
        #[allow(missing_docs)]
        fn visit_method_call(&mut self, _node: &MethodCall<P>) {}
        #[allow(missing_docs)]
        fn visit_method_call_end(&mut self, _node: &MethodCall<P>) {}
        #[allow(missing_docs)]
        fn visit_numeric_for(&mut self, _node: &NumericFor<P>) {}
        #[allow(missing_docs)]
        fn visit_numeric_for_end(&mut self, _node: &NumericFor<P>) {}
        #[allow(missing_docs)]
        fn visit_parameter(&mut self, _node: &Parameter<P>) {}
        #[allow(missing_docs)]
        fn visit_parameter_end(&mut self, _node: &Parameter<P>) {}
        #[allow(missing_docs)]
        fn visit_prefix(&mut self, _node: &Prefix<P>) {}
        #[allow(missing_docs)]
        fn visit_prefix_end(&mut self, _node: &Prefix<P>) {}
        #[allow(missing_docs)]
        fn visit_repeat(&mut self, _node: &Repeat<P>) {}
        #[allow(missing_docs)]
        fn visit_repeat_end(&mut self, _node: &Repeat<P>) {}
        #[allow(missing_docs)]
        fn visit_return(&mut self, _node: &Return<P>) {}
        #[allow(missing_docs)]
        fn visit_return_end(&mut self, _node: &Return<P>) {}
        #[allow(missing_docs)]
        fn visit_stmt(&mut self, _node: &Stmt<P>) {}
        #[allow(missing_docs)]
        fn visit_stmt_end(&mut self, _node: &Stmt<P>) {}
        #[allow(missing_docs)]
        fn visit_suffix(&mut self, _node: &Suffix<P>) {}
        #[allow(missing_docs)]
        fn visit_suffix_end(&mut self, _node: &Suffix<P>) {}
        #[allow(missing_docs)]
        fn visit_table_constructor(&mut self, _node: &TableConstructor<P>) {}
        #[allow(missing_docs)]
        fn visit_table_constructor_end(&mut self, _node: &TableConstructor<P>) {}
        #[allow(missing_docs)]
        fn visit_token_reference(&mut self, _node: &TokenReference) {}
        #[allow(missing_docs)]
        fn visit_token_reference_end(&mut self, _node: &TokenReference) {}
        #[allow(missing_docs)]
        fn visit_un_op(&mut self, _node: &UnOp) {}
        #[allow(missing_docs)]
        fn visit_un_op_end(&mut self, _node: &UnOp) {}
        #[allow(missing_docs)]
        fn visit_value(&mut self, _node: &Value<P>) {}
        #[allow(missing_docs)]
        fn visit_value_end(&mut self, _node: &Value<P>) {}
        #[allow(missing_docs)]
        fn visit_var(&mut self, _node: &Var<P>) {}
        #[allow(missing_docs)]
        fn visit_var_end(&mut self, _node: &Var<P>) {}
        #[allow(missing_docs)]
        fn visit_var_expression(&mut self, _node: &VarExpression<P>) {}
        #[allow(missing_docs)]
        fn visit_var_expression_end(&mut self, _node: &VarExpression<P>) {}
        #[allow(missing_docs)]
        fn visit_while(&mut self, _node: &While<P>) {}
        #[allow(missing_docs)]
        fn visit_while_end(&mut self, _node: &While<P>) {}
        #[allow(missing_docs)]
        fn visit_identifier(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_multi_line_comment(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_number(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_single_line_comment(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_string_literal(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_symbol(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_token(&mut self, _token: &Token) {}
        #[allow(missing_docs)]
        fn visit_whitespace(&mut self, _token: &Token) {}
    }
    /// A trait that implements functions to listen for specific nodes/tokens.
    /// Unlike [`Visitor`], nodes/tokens passed are mutable.
    pub trait VisitorMut<P: Plugin = DefaultPlugin> {
        /// Visit the nodes of an [`Ast`](crate::ast::Ast)
        fn visit_ast(&mut self, ast: Ast) -> Ast
        where
            Self: Sized,
        {
            let eof = ast.eof().to_owned();
            let nodes = ast.nodes.visit_mut(self);
            Ast {
                nodes,
                eof: self.visit_eof(eof),
            }
        }
        #[allow(missing_docs)]
        fn visit_anonymous_call(&mut self, node: FunctionArgs) -> FunctionArgs {
            node
        }
        #[allow(missing_docs)]
        fn visit_anonymous_call_end(&mut self, node: FunctionArgs) -> FunctionArgs {
            node
        }
        #[allow(missing_docs)]
        fn visit_assignment(&mut self, node: Assignment) -> Assignment {
            node
        }
        #[allow(missing_docs)]
        fn visit_assignment_end(&mut self, node: Assignment) -> Assignment {
            node
        }
        #[allow(missing_docs)]
        fn visit_block(&mut self, node: Block<P>) -> Block<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_block_end(&mut self, node: Block<P>) -> Block<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_call(&mut self, node: Call<P>) -> Call<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_call_end(&mut self, node: Call<P>) -> Call<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_contained_span(&mut self, node: ContainedSpan) -> ContainedSpan {
            node
        }
        #[allow(missing_docs)]
        fn visit_contained_span_end(&mut self, node: ContainedSpan) -> ContainedSpan {
            node
        }
        #[allow(missing_docs)]
        fn visit_do(&mut self, node: Do<P>) -> Do<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_do_end(&mut self, node: Do<P>) -> Do<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_else_if(&mut self, node: ElseIf<P>) -> ElseIf<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_else_if_end(&mut self, node: ElseIf<P>) -> ElseIf<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_eof(&mut self, node: TokenReference) -> TokenReference {
            node
        }
        #[allow(missing_docs)]
        fn visit_eof_end(&mut self, node: TokenReference) -> TokenReference {
            node
        }
        #[allow(missing_docs)]
        fn visit_expression(&mut self, node: Expression<P>) -> Expression<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_expression_end(&mut self, node: Expression<P>) -> Expression<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_field(&mut self, node: Field<P>) -> Field<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_field_end(&mut self, node: Field<P>) -> Field<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_args(&mut self, node: FunctionArgs<P>) -> FunctionArgs<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_args_end(&mut self, node: FunctionArgs<P>) -> FunctionArgs<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_body(&mut self, node: FunctionBody<P>) -> FunctionBody<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_body_end(&mut self, node: FunctionBody<P>) -> FunctionBody<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_call(&mut self, node: FunctionCall<P>) -> FunctionCall<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_call_end(&mut self, node: FunctionCall<P>) -> FunctionCall<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_declaration(
            &mut self,
            node: FunctionDeclaration<P>,
        ) -> FunctionDeclaration<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_declaration_end(
            &mut self,
            node: FunctionDeclaration<P>,
        ) -> FunctionDeclaration<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_name(&mut self, node: FunctionName<P>) -> FunctionName<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_function_name_end(&mut self, node: FunctionName<P>) -> FunctionName<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_generic_for(&mut self, node: GenericFor<P>) -> GenericFor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_generic_for_end(&mut self, node: GenericFor<P>) -> GenericFor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_if(&mut self, node: If<P>) -> If<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_if_end(&mut self, node: If<P>) -> If<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_index(&mut self, node: Index<P>) -> Index<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_index_end(&mut self, node: Index<P>) -> Index<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_local_assignment(&mut self, node: LocalAssignment<P>) -> LocalAssignment<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_local_assignment_end(&mut self, node: LocalAssignment<P>) -> LocalAssignment<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_local_function(&mut self, node: LocalFunction<P>) -> LocalFunction<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_local_function_end(&mut self, node: LocalFunction<P>) -> LocalFunction<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_last_stmt(&mut self, node: LastStmt<P>) -> LastStmt<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_last_stmt_end(&mut self, node: LastStmt<P>) -> LastStmt<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_method_call(&mut self, node: MethodCall<P>) -> MethodCall<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_method_call_end(&mut self, node: MethodCall<P>) -> MethodCall<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_numeric_for(&mut self, node: NumericFor<P>) -> NumericFor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_numeric_for_end(&mut self, node: NumericFor<P>) -> NumericFor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_parameter(&mut self, node: Parameter<P>) -> Parameter<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_parameter_end(&mut self, node: Parameter<P>) -> Parameter<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_prefix(&mut self, node: Prefix<P>) -> Prefix<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_prefix_end(&mut self, node: Prefix<P>) -> Prefix<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_repeat(&mut self, node: Repeat<P>) -> Repeat<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_repeat_end(&mut self, node: Repeat<P>) -> Repeat<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_return(&mut self, node: Return<P>) -> Return<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_return_end(&mut self, node: Return<P>) -> Return<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_stmt(&mut self, node: Stmt<P>) -> Stmt<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_stmt_end(&mut self, node: Stmt<P>) -> Stmt<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_suffix(&mut self, node: Suffix<P>) -> Suffix<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_suffix_end(&mut self, node: Suffix<P>) -> Suffix<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_table_constructor(&mut self, node: TableConstructor<P>) -> TableConstructor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_table_constructor_end(
            &mut self,
            node: TableConstructor<P>,
        ) -> TableConstructor<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_token_reference(&mut self, node: TokenReference) -> TokenReference {
            node
        }
        #[allow(missing_docs)]
        fn visit_token_reference_end(&mut self, node: TokenReference) -> TokenReference {
            node
        }
        #[allow(missing_docs)]
        fn visit_un_op(&mut self, node: UnOp) -> UnOp {
            node
        }
        #[allow(missing_docs)]
        fn visit_un_op_end(&mut self, node: UnOp) -> UnOp {
            node
        }
        #[allow(missing_docs)]
        fn visit_value(&mut self, node: Value<P>) -> Value<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_value_end(&mut self, node: Value<P>) -> Value<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_var(&mut self, node: Var<P>) -> Var<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_var_end(&mut self, node: Var<P>) -> Var<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_var_expression(&mut self, node: VarExpression<P>) -> VarExpression<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_var_expression_end(&mut self, node: VarExpression<P>) -> VarExpression<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_while(&mut self, node: While<P>) -> While<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_while_end(&mut self, node: While<P>) -> While<P> {
            node
        }
        #[allow(missing_docs)]
        fn visit_identifier(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_multi_line_comment(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_number(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_single_line_comment(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_string_literal(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_symbol(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_token(&mut self, token: Token) -> Token {
            token
        }
        #[allow(missing_docs)]
        fn visit_whitespace(&mut self, token: Token) -> Token {
            token
        }
    }
}
mod private {
    use crate::{
        ast::{Ast, AstError},
        tokenizer::{Token, TokenReference, TokenType, TokenizerError},
        Error,
    };
    use std::borrow::Cow;
    pub trait Sealed {}
    impl Sealed for () {}
    impl<T> Sealed for &T {}
    impl<T> Sealed for &mut T {}
    impl<T: ToOwned> Sealed for Cow<'_, T> {}
    impl Sealed for Ast {}
    impl Sealed for AstError {}
    impl Sealed for Error {}
    impl Sealed for Token {}
    impl Sealed for TokenizerError {}
    impl Sealed for TokenReference {}
    impl Sealed for TokenType {}
    impl<T> Sealed for Box<T> {}
    impl<T> Sealed for Option<T> {}
    impl<T> Sealed for Vec<T> {}
    impl<A, B> Sealed for (A, B) {}
}
mod short_string {
    use std::{fmt::Display, ops::Deref};
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};
    use smol_str::SmolStr;
    /// A string as used in `TokenType`.
    #[serde(transparent)]
    pub struct ShortString(SmolStr);
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ShortString {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::export::Result::map(
                    _serde::Deserialize::deserialize(__deserializer),
                    |__transparent| ShortString { 0: __transparent },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ShortString {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serialize::serialize(&self.0, __serializer)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ShortString {
        #[inline]
        fn clone(&self) -> ShortString {
            match *self {
                ShortString(ref __self_0_0) => {
                    ShortString(::core::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ShortString {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ShortString(ref __self_0_0) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ShortString");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for ShortString {
        #[inline]
        fn default() -> ShortString {
            ShortString(::core::default::Default::default())
        }
    }
    impl ::core::marker::StructuralEq for ShortString {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ShortString {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<SmolStr>;
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for ShortString {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ShortString {
        #[inline]
        fn eq(&self, other: &ShortString) -> bool {
            match *other {
                ShortString(ref __self_1_0) => match *self {
                    ShortString(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ShortString) -> bool {
            match *other {
                ShortString(ref __self_1_0) => match *self {
                    ShortString(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ShortString {
        /// Creates a new ShortString from the given text.
        pub fn new<T: Into<String> + AsRef<str>>(text: T) -> Self {
            ShortString(SmolStr::from(text))
        }
        /// Returns a `&str` representation of the ShortString.
        pub fn as_str(&self) -> &str {
            self.0.as_str()
        }
        /// Returns the length of the ShortString.
        pub fn len(&self) -> usize {
            self.0.len()
        }
        /// Returns whether or not the ShortString is empty.
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    }
    impl Display for ShortString {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            self.0.fmt(f)
        }
    }
    impl Deref for ShortString {
        type Target = str;
        fn deref(&self) -> &Self::Target {
            &*self.0
        }
    }
    impl<T: Into<String> + AsRef<str>> From<T> for ShortString {
        fn from(value: T) -> Self {
            ShortString(SmolStr::from(value))
        }
    }
}
mod util {
    use crate::tokenizer::TokenReference;
    use std::{borrow::Borrow, fmt::Display};
    pub fn display_option<T: Display, O: Borrow<Option<T>>>(option: O) -> String {
        match option.borrow() {
            Some(x) => x.to_string(),
            None => "".to_string(),
        }
    }
    pub fn display_optional_punctuated<T: Display>(pair: &(T, Option<TokenReference>)) -> String {
        {
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                &["", ""],
                &match (&pair.0, &display_option(&pair.1)) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                    ],
                },
            ));
            res
        }
    }
    pub fn display_optional_punctuated_vec<T: Display>(
        vec: &[(T, Option<TokenReference>)],
    ) -> String {
        let mut string = String::new();
        for pair in vec {
            string.push_str(&display_optional_punctuated(pair));
        }
        string
    }
    pub fn join_vec<T: Display, V: AsRef<[T]>>(vec: V) -> String {
        let mut string = String::new();
        for item in vec.as_ref() {
            string.push_str(&item.to_string());
        }
        string
    }
}
pub use short_string::ShortString;
use std::fmt;
/// An error type that consists of both [`AstError`](ast::AstError) and [`TokenizerError`](tokenizer::TokenizerError)
/// Used by [`parse`]
pub enum Error {
    /// Triggered if there's an issue creating an AST, but tokenizing must have succeeded
    AstError(ast::AstError),
    /// Triggered if there's an issue when tokenizing, and an AST can't be made
    TokenizerError(tokenizer::TokenizerError),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Error {
    #[inline]
    fn clone(&self) -> Error {
        match (&*self,) {
            (&Error::AstError(ref __self_0),) => {
                Error::AstError(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::TokenizerError(ref __self_0),) => {
                Error::TokenizerError(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&Error::AstError(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "AstError");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::TokenizerError(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "TokenizerError");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for Error {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for Error {
    #[inline]
    fn eq(&self, other: &Error) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Error::AstError(ref __self_0), &Error::AstError(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (
                        &Error::TokenizerError(ref __self_0),
                        &Error::TokenizerError(ref __arg_1_0),
                    ) => (*__self_0) == (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &Error) -> bool {
        {
            let __self_vi = ::core::intrinsics::discriminant_value(&*self);
            let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Error::AstError(ref __self_0), &Error::AstError(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (
                        &Error::TokenizerError(ref __self_0),
                        &Error::TokenizerError(ref __arg_1_0),
                    ) => (*__self_0) != (*__arg_1_0),
                    _ => unsafe { ::core::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
impl fmt::Display for Error {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::AstError(error) => formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["error occurred while creating ast: "],
                &match (&error,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::TokenizerError(error) => formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["error occurred while tokenizing: "],
                &match (&error,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
        }
    }
}
impl std::error::Error for Error {}
/// Creates an [`Ast`](ast::Ast) from Lua code
///
/// # Errors
/// If the code passed cannot be tokenized, a TokenizerError will be returned.
/// If the code passed is not valid Lua 5.1 code, an AstError will be returned,
/// specifically AstError::UnexpectedToken.
///
/// ```rust
/// assert!(full_moon::parse("local x = 1").is_ok());
/// assert!(full_moon::parse("local x = ").is_err());
/// ```
pub fn parse(code: &str) -> Result<ast::Ast, Error> {
    let tokens = tokenizer::tokens(code).map_err(Error::TokenizerError)?;
    ast::Ast::from_tokens(tokens).map_err(Error::AstError)
}
/// Prints back Lua code from an [`Ast`](ast::Ast)
pub fn print(ast: &ast::Ast) -> String {
    {
        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
            &["", ""],
            &match (&ast.nodes(), &ast.eof()) {
                (arg0, arg1) => [
                    ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                    ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                ],
            },
        ));
        res
    }
}
