#![feature(prelude_import)]
#![no_std]
#![warn(missing_docs)]
#![doc = " # Full Moon"]
#![doc = ""]
#![doc = " `full_moon` is a lossless parser for Lua 5.1"]
#![doc = " Learn more by going to [the repository](https://github.com/Kampfkarren/full-moon)"]
#[prelude_import]
use ::std::prelude::v1::*;
#[macro_use]
extern crate std as std;
#[doc = " Utilities for ASTs (Abstract Syntax Trees). Contains all nodes used by Full Moon (such as blocks)."]
pub mod ast {
    use crate::tokenizer::{Symbol, Token, TokenKind, TokenReference, TokenType};
    use full_moon_derive::{Node, Visit};
    use generational_arena::Arena;
    use itertools::Itertools;
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Serialize};
    use std::fmt;
    use std::iter::FromIterator;
    use std::sync::Arc;
    struct ParserState<'a> {
        index: usize,
        len: usize,
        tokens: Arc<Arena<Token<'a>>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for ParserState<'a> {
        #[inline]
        fn clone(&self) -> ParserState<'a> {
            match *self {
                ParserState {
                    index: ref __self_0_0,
                    len: ref __self_0_1,
                    tokens: ref __self_0_2,
                } => ParserState {
                    index: ::std::clone::Clone::clone(&(*__self_0_0)),
                    len: ::std::clone::Clone::clone(&(*__self_0_1)),
                    tokens: ::std::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    impl<'a> ParserState<'a> {
        fn new(tokens: Arc<Arena<Token<'a>>>) -> ParserState<'a> {
            ParserState {
                index: 0,
                len: tokens.len(),
                tokens,
            }
        }
        fn advance(&self) -> Option<ParserState<'a>> {
            let mut state = self.clone();
            loop {
                state = ParserState {
                    index: state.index + 1,
                    len: self.len,
                    tokens: Arc::clone(&self.tokens),
                };
                if !state.peek().token_type().ignore() {
                    return Some(state);
                }
            }
        }
        pub fn peek(&self) -> TokenReference<'a> {
            if self.index >= self.len {
                {
                    ::std::rt::begin_panic(
                        "peek failed, when there should always be an eof",
                        &("src/ast.rs", 46u32, 13u32),
                    )
                };
            }
            TokenReference::Borrowed {
                arena: Arc::clone(&self.tokens),
                index: self
                    .tokens
                    .iter()
                    .sorted_by(|left, right| left.1.cmp(&right.1))
                    .nth(self.index)
                    .expect("couldn\'t peek, no eof?")
                    .0,
            }
        }
    }
    impl<'a> fmt::Debug for ParserState<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_fmt(::std::fmt::Arguments::new_v1(
                &["ParserState { index: ", ", current: ", " }"],
                &match (&self.index, &self.peek()) {
                    (arg0, arg1) => [
                        ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                        ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Debug::fmt),
                    ],
                },
            ))
        }
    }
    trait Parser<'a>: Sized {
        type Item;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Self::Item), InternalAstError<'a>>;
    }
    struct ZeroOrMore<P>(P);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::std::clone::Clone> ::std::clone::Clone for ZeroOrMore<P> {
        #[inline]
        fn clone(&self) -> ZeroOrMore<P> {
            match *self {
                ZeroOrMore(ref __self_0_0) => {
                    ZeroOrMore(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::std::fmt::Debug> ::std::fmt::Debug for ZeroOrMore<P> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ZeroOrMore(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("ZeroOrMore");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<P: ::std::cmp::PartialEq> ::std::cmp::PartialEq for ZeroOrMore<P> {
        #[inline]
        fn eq(&self, other: &ZeroOrMore<P>) -> bool {
            match *other {
                ZeroOrMore(ref __self_1_0) => match *self {
                    ZeroOrMore(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ZeroOrMore<P>) -> bool {
            match *other {
                ZeroOrMore(ref __self_1_0) => match *self {
                    ZeroOrMore(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<'a, P, T> Parser<'a> for ZeroOrMore<P>
    where
        P: Parser<'a, Item = T>,
    {
        type Item = Vec<T>;
        fn parse(
            &self,
            mut state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Vec<T>), InternalAstError<'a>> {
            let mut nodes = Vec::new();
            loop {
                match self.0.parse(state.clone()) {
                    Ok((new_state, node)) => {
                        state = new_state;
                        nodes.push(node);
                    }
                    Err(InternalAstError::NoMatch) => break,
                    Err(other) => return Err(other),
                };
            }
            Ok((state, nodes))
        }
    }
    struct ZeroOrMoreDelimited<ItemParser, Delimiter>(ItemParser, Delimiter, bool);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::clone::Clone, Delimiter: ::std::clone::Clone> ::std::clone::Clone
        for ZeroOrMoreDelimited<ItemParser, Delimiter>
    {
        #[inline]
        fn clone(&self) -> ZeroOrMoreDelimited<ItemParser, Delimiter> {
            match *self {
                ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                    ZeroOrMoreDelimited(
                        ::std::clone::Clone::clone(&(*__self_0_0)),
                        ::std::clone::Clone::clone(&(*__self_0_1)),
                        ::std::clone::Clone::clone(&(*__self_0_2)),
                    )
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::fmt::Debug, Delimiter: ::std::fmt::Debug> ::std::fmt::Debug
        for ZeroOrMoreDelimited<ItemParser, Delimiter>
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                    let mut debug_trait_builder = f.debug_tuple("ZeroOrMoreDelimited");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    let _ = debug_trait_builder.field(&&(*__self_0_1));
                    let _ = debug_trait_builder.field(&&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::cmp::PartialEq, Delimiter: ::std::cmp::PartialEq> ::std::cmp::PartialEq
        for ZeroOrMoreDelimited<ItemParser, Delimiter>
    {
        #[inline]
        fn eq(&self, other: &ZeroOrMoreDelimited<ItemParser, Delimiter>) -> bool {
            match *other {
                ZeroOrMoreDelimited(ref __self_1_0, ref __self_1_1, ref __self_1_2) => {
                    match *self {
                        ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    }
                }
            }
        }
        #[inline]
        fn ne(&self, other: &ZeroOrMoreDelimited<ItemParser, Delimiter>) -> bool {
            match *other {
                ZeroOrMoreDelimited(ref __self_1_0, ref __self_1_1, ref __self_1_2) => {
                    match *self {
                        ZeroOrMoreDelimited(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    }
                }
            }
        }
    }
    impl<'a, ItemParser, Delimiter, T> Parser<'a> for ZeroOrMoreDelimited<ItemParser, Delimiter>
    where
        ItemParser: Parser<'a, Item = T>,
        Delimiter: Parser<'a>,
    {
        type Item = Vec<T>;
        fn parse(
            &self,
            mut state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Vec<T>), InternalAstError<'a>> {
            let mut nodes = Vec::new();
            if let Ok((new_state, node)) = match self.0.parse(state.clone()) {
                Ok((state, node)) => Ok((state, node)),
                Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                Err(other) => return Err(other),
            } {
                state = new_state;
                nodes.push(node);
            } else {
                return Ok((state.clone(), Vec::new()));
            }
            while let Ok((new_state, _)) = match self.1.parse(state.clone()) {
                Ok((state, node)) => Ok((state, node)),
                Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                Err(other) => return Err(other),
            } {
                state = new_state;
                match self.0.parse(state.clone()) {
                    Ok((new_state, node)) => {
                        state = new_state;
                        nodes.push(node);
                    }
                    Err(InternalAstError::NoMatch) => {
                        if self.2 {
                            break;
                        } else {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("trailing character"),
                            });
                        }
                    }
                    Err(other) => {
                        return Err(other);
                    }
                }
            }
            Ok((state, nodes))
        }
    }
    struct OneOrMore<ItemParser, Delimiter>(ItemParser, Delimiter, bool);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::clone::Clone, Delimiter: ::std::clone::Clone> ::std::clone::Clone
        for OneOrMore<ItemParser, Delimiter>
    {
        #[inline]
        fn clone(&self) -> OneOrMore<ItemParser, Delimiter> {
            match *self {
                OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => OneOrMore(
                    ::std::clone::Clone::clone(&(*__self_0_0)),
                    ::std::clone::Clone::clone(&(*__self_0_1)),
                    ::std::clone::Clone::clone(&(*__self_0_2)),
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::fmt::Debug, Delimiter: ::std::fmt::Debug> ::std::fmt::Debug
        for OneOrMore<ItemParser, Delimiter>
    {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                    let mut debug_trait_builder = f.debug_tuple("OneOrMore");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    let _ = debug_trait_builder.field(&&(*__self_0_1));
                    let _ = debug_trait_builder.field(&&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<ItemParser: ::std::cmp::PartialEq, Delimiter: ::std::cmp::PartialEq> ::std::cmp::PartialEq
        for OneOrMore<ItemParser, Delimiter>
    {
        #[inline]
        fn eq(&self, other: &OneOrMore<ItemParser, Delimiter>) -> bool {
            match *other {
                OneOrMore(ref __self_1_0, ref __self_1_1, ref __self_1_2) => match *self {
                    OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &OneOrMore<ItemParser, Delimiter>) -> bool {
            match *other {
                OneOrMore(ref __self_1_0, ref __self_1_1, ref __self_1_2) => match *self {
                    OneOrMore(ref __self_0_0, ref __self_0_1, ref __self_0_2) => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<'a, ItemParser: Parser<'a>, Delimiter: Parser<'a>> Parser<'a>
        for OneOrMore<ItemParser, Delimiter>
    {
        type Item = Vec<ItemParser::Item>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Vec<ItemParser::Item>), InternalAstError<'a>> {
            let mut nodes = Vec::new();
            let (mut state, node) = self.0.parse(state.clone())?;
            nodes.push(node);
            while let Ok((new_state, _)) = self.1.parse(state.clone()) {
                match self.0.parse(new_state.clone()) {
                    Ok((new_state, node)) => {
                        state = new_state;
                        nodes.push(node);
                    }
                    Err(InternalAstError::NoMatch) => {
                        if self.2 {
                            state = new_state;
                        }
                        break;
                    }
                    Err(other) => {
                        return Err(other);
                    }
                }
            }
            Ok((state, nodes))
        }
    }
    struct NoDelimiter;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for NoDelimiter {
        #[inline]
        fn clone(&self) -> NoDelimiter {
            match *self {
                NoDelimiter => NoDelimiter,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for NoDelimiter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                NoDelimiter => {
                    let mut debug_trait_builder = f.debug_tuple("NoDelimiter");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for NoDelimiter {
        #[inline]
        fn eq(&self, other: &NoDelimiter) -> bool {
            match *other {
                NoDelimiter => match *self {
                    NoDelimiter => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for NoDelimiter {
        type Item = ();
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, ()), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| Ok((state, ())))(self, state)
        }
    }
    struct ParseSymbol(Symbol);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseSymbol {
        #[inline]
        fn clone(&self) -> ParseSymbol {
            match *self {
                ParseSymbol(ref __self_0_0) => {
                    ParseSymbol(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseSymbol {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseSymbol(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("ParseSymbol");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseSymbol {
        #[inline]
        fn eq(&self, other: &ParseSymbol) -> bool {
            match *other {
                ParseSymbol(ref __self_1_0) => match *self {
                    ParseSymbol(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ParseSymbol) -> bool {
            match *other {
                ParseSymbol(ref __self_1_0) => match *self {
                    ParseSymbol(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseSymbol {
        type Item = TokenReference<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, TokenReference<'a>), InternalAstError<'a>> {
            (|this: &ParseSymbol, state: ParserState<'a>| {
                let expecting = TokenType::Symbol { symbol: this.0 };
                let token = state.peek();
                if *token.token_type() == expecting {
                    Ok((state.advance().ok_or(InternalAstError::NoMatch)?, token))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    struct ParseNumber;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseNumber {
        #[inline]
        fn clone(&self) -> ParseNumber {
            match *self {
                ParseNumber => ParseNumber,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseNumber {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseNumber => {
                    let mut debug_trait_builder = f.debug_tuple("ParseNumber");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseNumber {
        #[inline]
        fn eq(&self, other: &ParseNumber) -> bool {
            match *other {
                ParseNumber => match *self {
                    ParseNumber => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseNumber {
        type Item = TokenReference<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, TokenReference<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let token = state.peek();
                if token.token_kind() == TokenKind::Number {
                    Ok((state.advance().ok_or(InternalAstError::NoMatch)?, token))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    struct ParseStringLiteral;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseStringLiteral {
        #[inline]
        fn clone(&self) -> ParseStringLiteral {
            match *self {
                ParseStringLiteral => ParseStringLiteral,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseStringLiteral {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseStringLiteral => {
                    let mut debug_trait_builder = f.debug_tuple("ParseStringLiteral");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseStringLiteral {
        #[inline]
        fn eq(&self, other: &ParseStringLiteral) -> bool {
            match *other {
                ParseStringLiteral => match *self {
                    ParseStringLiteral => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseStringLiteral {
        type Item = TokenReference<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, TokenReference<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let token = state.peek();
                if token.token_kind() == TokenKind::StringLiteral {
                    Ok((state.advance().ok_or(InternalAstError::NoMatch)?, token))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " A block of statements, such as in if/do/etc block"]
    pub struct Block<'a> {
        #[serde(borrow)]
        stmts: Vec<Stmt<'a>>,
        #[serde(skip_serializing_if = "Option::is_none")]
        last_stmt: Option<LastStmt<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Block<'a> {
        #[inline]
        fn clone(&self) -> Block<'a> {
            match *self {
                Block {
                    stmts: ref __self_0_0,
                    last_stmt: ref __self_0_1,
                } => Block {
                    stmts: ::std::clone::Clone::clone(&(*__self_0_0)),
                    last_stmt: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Block<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Block {
                    stmts: ref __self_0_0,
                    last_stmt: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Block");
                    let _ = debug_trait_builder.field("stmts", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("last_stmt", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Block<'a> {
        #[inline]
        fn eq(&self, other: &Block<'a>) -> bool {
            match *other {
                Block {
                    stmts: ref __self_1_0,
                    last_stmt: ref __self_1_1,
                } => match *self {
                    Block {
                        stmts: ref __self_0_0,
                        last_stmt: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Block<'a>) -> bool {
            match *other {
                Block {
                    stmts: ref __self_1_0,
                    last_stmt: ref __self_1_1,
                } => match *self {
                    Block {
                        stmts: ref __self_0_0,
                        last_stmt: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for Block<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.stmts.start_position()?, self.last_stmt.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.stmts.start_position()?, self.last_stmt.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Block<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_block(self);
            self.stmts.visit(visitor);
            self.last_stmt.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Block<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_block(self);
            self.stmts.visit_mut(visitor);
            self.last_stmt.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Block: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Block<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "stmts" => _serde::export::Ok(__Field::__field0),
                            "last_stmt" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"stmts" => _serde::export::Ok(__Field::__field0),
                            b"last_stmt" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Block<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Block<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Block")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Stmt<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Block with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<LastStmt<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Block with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Block {
                            stmts: __field0,
                            last_stmt: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<Stmt<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Option<LastStmt<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "stmts",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Stmt<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "last_stmt",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<LastStmt<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("stmts") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("last_stmt") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Block {
                            stmts: __field0,
                            last_stmt: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["stmts", "last_stmt"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Block",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Block<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Block: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Block<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Block",
                    false as usize
                        + 1
                        + if Option::is_none(&self.last_stmt) {
                            0
                        } else {
                            1
                        },
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "stmts",
                    &self.stmts,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                if !Option::is_none(&self.last_stmt) {
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "last_stmt",
                        &self.last_stmt,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                } else {
                    match _serde::ser::SerializeStruct::skip_field(&mut __serde_state, "last_stmt")
                    {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                }
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> Block<'a> {
        #[doc = " An iterator over the [statements](enum.Stmt.html) in the block, such as `local foo = 1`"]
        pub fn iter_stmts(&self) -> impl Iterator<Item = &Stmt<'a>> {
            self.stmts.iter()
        }
        #[doc = " The last statement of the block if one exists, such as `return foo`"]
        pub fn last_stmts(&self) -> Option<&LastStmt<'a>> {
            self.last_stmt.as_ref()
        }
    }
    struct ParseBlock;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseBlock {
        #[inline]
        fn clone(&self) -> ParseBlock {
            match *self {
                ParseBlock => ParseBlock,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseBlock {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseBlock => {
                    let mut debug_trait_builder = f.debug_tuple("ParseBlock");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseBlock {
        #[inline]
        fn default() -> ParseBlock {
            ParseBlock
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseBlock {
        #[inline]
        fn eq(&self, other: &ParseBlock) -> bool {
            match *other {
                ParseBlock => match *self {
                    ParseBlock => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseBlock {
        type Item = Block<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Block<'a>), InternalAstError<'a>> {
            (|_, mut state: ParserState<'a>| {
                let mut stmts = Vec::new();
                while let Ok((new_state, stmt)) = match ParseStmt.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    state = new_state;
                    if let Ok((new_state, _)) = ParseSymbol(Symbol::Semicolon).parse(state.clone())
                    {
                        state = new_state;
                    }
                    stmts.push(stmt);
                }
                if let Ok((mut state, last_stmt)) = match ParseLastStmt.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    if let Ok((new_state, _)) = ParseSymbol(Symbol::Semicolon).parse(state.clone())
                    {
                        state = new_state;
                    }
                    Ok((
                        state,
                        Block {
                            stmts,
                            last_stmt: Some(last_stmt),
                        },
                    ))
                } else {
                    Ok((
                        state,
                        Block {
                            stmts,
                            last_stmt: None,
                        },
                    ))
                }
            })(self, state)
        }
    }
    #[doc = " The last statement of a [`Block`](struct.Block.html)"]
    pub enum LastStmt<'a> {
        #[doc = " A `break` statement"]
        Break(TokenReference<'a>),
        #[doc = " A `return` statement, expression is what is being returned"]
        #[serde(borrow)]
        Return(Vec<Expression<'a>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for LastStmt<'a> {
        #[inline]
        fn clone(&self) -> LastStmt<'a> {
            match (&*self,) {
                (&LastStmt::Break(ref __self_0),) => {
                    LastStmt::Break(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&LastStmt::Return(ref __self_0),) => {
                    LastStmt::Return(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for LastStmt<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&LastStmt::Break(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Break");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&LastStmt::Return(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Return");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for LastStmt<'a> {
        #[inline]
        fn eq(&self, other: &LastStmt<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&LastStmt::Break(ref __self_0), &LastStmt::Break(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&LastStmt::Return(ref __self_0), &LastStmt::Return(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &LastStmt<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&LastStmt::Break(ref __self_0), &LastStmt::Break(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&LastStmt::Return(ref __self_0), &LastStmt::Return(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for LastStmt<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    LastStmt::Break(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    LastStmt::Return(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    LastStmt::Break(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    LastStmt::Return(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for LastStmt<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_last_stmt(self);
            match self {
                LastStmt::Break(__self_0) => {
                    __self_0.visit(visitor);
                }
                LastStmt::Return(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for LastStmt<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_last_stmt(self);
            match self {
                LastStmt::Break(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                LastStmt::Return(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_LastStmt: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for LastStmt<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Break" => _serde::export::Ok(__Field::__field0),
                            "Return" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Break" => _serde::export::Ok(__Field::__field0),
                            b"Return" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<LastStmt<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = LastStmt<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum LastStmt")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                LastStmt::Break,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<Expression<'a>>>(
                                    __variant,
                                ),
                                LastStmt::Return,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Break", "Return"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "LastStmt",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LastStmt<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_LastStmt: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for LastStmt<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    LastStmt::Break(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "LastStmt",
                        0u32,
                        "Break",
                        __field0,
                    ),
                    LastStmt::Return(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "LastStmt",
                            1u32,
                            "Return",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    struct ParseLastStmt;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseLastStmt {
        #[inline]
        fn clone(&self) -> ParseLastStmt {
            match *self {
                ParseLastStmt => ParseLastStmt,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseLastStmt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseLastStmt => {
                    let mut debug_trait_builder = f.debug_tuple("ParseLastStmt");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseLastStmt {
        #[inline]
        fn eq(&self, other: &ParseLastStmt) -> bool {
            match *other {
                ParseLastStmt => match *self {
                    ParseLastStmt => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseLastStmt {
        type Item = LastStmt<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, LastStmt<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = ParseSymbol(Symbol::Return).parse(state.clone()) {
                    let (state, returns) = match ZeroOrMoreDelimited(
                        ParseExpression,
                        ParseSymbol(Symbol::Comma),
                        false,
                    )
                    .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("return values"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, LastStmt::Return(returns)))
                } else if let Ok((state, token)) = ParseSymbol(Symbol::Break).parse(state.clone()) {
                    Ok((state, LastStmt::Break(token)))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " Fields of a [`TableConstructor`](struct.TableConstructor.html)"]
    pub enum Field<'a> {
        #[doc = " A key in the format of `[expression] = value`"]
        ExpressionKey {
            #[doc = " The `[` part of `[expression] = value`"]
            #[serde(borrow)]
            start_bracket: TokenReference<'a>,
            #[doc = " The `expression` part of `[expression] = value`"]
            key: Box<Expression<'a>>,
            #[doc = " The `value` part of `[expression] = value`"]
            value: Box<Expression<'a>>,
        },
        #[doc = " A key in the format of `name = value`"]
        NameKey {
            #[serde(borrow)]
            #[doc = " The `name` part of `name = value`"]
            key: Box<TokenReference<'a>>,
            #[doc = " The `value` part of `name = value`"]
            value: Box<Expression<'a>>,
        },
        #[doc = " A field with no key, just a value (such as `\"a\"` in `{ \"a\" }`)"]
        #[serde(borrow)]
        NoKey(Box<Expression<'a>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Field<'a> {
        #[inline]
        fn clone(&self) -> Field<'a> {
            match (&*self,) {
                (&Field::ExpressionKey {
                    start_bracket: ref __self_0,
                    key: ref __self_1,
                    value: ref __self_2,
                },) => Field::ExpressionKey {
                    start_bracket: ::std::clone::Clone::clone(&(*__self_0)),
                    key: ::std::clone::Clone::clone(&(*__self_1)),
                    value: ::std::clone::Clone::clone(&(*__self_2)),
                },
                (&Field::NameKey {
                    key: ref __self_0,
                    value: ref __self_1,
                },) => Field::NameKey {
                    key: ::std::clone::Clone::clone(&(*__self_0)),
                    value: ::std::clone::Clone::clone(&(*__self_1)),
                },
                (&Field::NoKey(ref __self_0),) => {
                    Field::NoKey(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Field<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Field::ExpressionKey {
                    start_bracket: ref __self_0,
                    key: ref __self_1,
                    value: ref __self_2,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("ExpressionKey");
                    let _ = debug_trait_builder.field("start_bracket", &&(*__self_0));
                    let _ = debug_trait_builder.field("key", &&(*__self_1));
                    let _ = debug_trait_builder.field("value", &&(*__self_2));
                    debug_trait_builder.finish()
                }
                (&Field::NameKey {
                    key: ref __self_0,
                    value: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("NameKey");
                    let _ = debug_trait_builder.field("key", &&(*__self_0));
                    let _ = debug_trait_builder.field("value", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&Field::NoKey(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("NoKey");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Field<'a> {
        #[inline]
        fn eq(&self, other: &Field<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Field::ExpressionKey {
                                start_bracket: ref __self_0,
                                key: ref __self_1,
                                value: ref __self_2,
                            },
                            &Field::ExpressionKey {
                                start_bracket: ref __arg_1_0,
                                key: ref __arg_1_1,
                                value: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        (
                            &Field::NameKey {
                                key: ref __self_0,
                                value: ref __self_1,
                            },
                            &Field::NameKey {
                                key: ref __arg_1_0,
                                value: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (&Field::NoKey(ref __self_0), &Field::NoKey(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Field<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Field::ExpressionKey {
                                start_bracket: ref __self_0,
                                key: ref __self_1,
                                value: ref __self_2,
                            },
                            &Field::ExpressionKey {
                                start_bracket: ref __arg_1_0,
                                key: ref __arg_1_1,
                                value: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        (
                            &Field::NameKey {
                                key: ref __self_0,
                                value: ref __self_1,
                            },
                            &Field::NameKey {
                                key: ref __arg_1_0,
                                value: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (&Field::NoKey(ref __self_0), &Field::NoKey(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Field<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Field::ExpressionKey {
                        start_bracket,
                        key,
                        value,
                    } => Some((start_bracket.start_position()?, value.end_position()?)),
                    Field::NameKey { key, value } => {
                        Some((key.start_position()?, value.end_position()?))
                    }
                    Field::NoKey(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Field::ExpressionKey {
                        start_bracket,
                        key,
                        value,
                    } => Some((start_bracket.start_position()?, value.end_position()?)),
                    Field::NameKey { key, value } => {
                        Some((key.start_position()?, value.end_position()?))
                    }
                    Field::NoKey(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Field<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_field(self);
            match self {
                Field::ExpressionKey {
                    start_bracket,
                    key,
                    value,
                } => {
                    start_bracket.visit(visitor);
                    key.visit(visitor);
                    value.visit(visitor);
                }
                Field::NameKey { key, value } => {
                    key.visit(visitor);
                    value.visit(visitor);
                }
                Field::NoKey(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Field<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_field(self);
            match self {
                Field::ExpressionKey {
                    start_bracket,
                    key,
                    value,
                } => {
                    start_bracket.visit_mut(visitor);
                    key.visit_mut(visitor);
                    value.visit_mut(visitor);
                }
                Field::NameKey { key, value } => {
                    key.visit_mut(visitor);
                    value.visit_mut(visitor);
                }
                Field::NoKey(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Field: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Field<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "ExpressionKey" => _serde::export::Ok(__Field::__field0),
                            "NameKey" => _serde::export::Ok(__Field::__field1),
                            "NoKey" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"ExpressionKey" => _serde::export::Ok(__Field::__field0),
                            b"NameKey" => _serde::export::Ok(__Field::__field1),
                            b"NoKey" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Field<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Field<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Field")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            2u64 => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 3",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "start_bracket" => {
                                                _serde::export::Ok(__Field::__field0)
                                            }
                                            "key" => _serde::export::Ok(__Field::__field1),
                                            "value" => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"start_bracket" => {
                                                _serde::export::Ok(__Field::__field0)
                                            }
                                            b"key" => _serde::export::Ok(__Field::__field1),
                                            b"value" => _serde::export::Ok(__Field::__field2),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de: 'a, 'a> {
                                    marker: _serde::export::PhantomData<Field<'a>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = Field<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Field::ExpressionKey",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference<'a>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant Field::ExpressionKey with 3 elements" ) ) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Box<Expression<'a>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant Field::ExpressionKey with 3 elements" ) ) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Box<Expression<'a>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 2usize , & "struct variant Field::ExpressionKey with 3 elements" ) ) ;
                                                }
                                            };
                                        _serde::export::Ok(Field::ExpressionKey {
                                            start_bracket: __field0,
                                            key: __field1,
                                            value: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<
                                            TokenReference<'a>,
                                        > = _serde::export::None;
                                        let mut __field1: _serde::export::Option<
                                            Box<Expression<'a>>,
                                        > = _serde::export::None;
                                        let mut __field2: _serde::export::Option<
                                            Box<Expression<'a>>,
                                        > = _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "start_bracket" ) ) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference<'a>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "key" ) ) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Box<Expression<'a>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::export::Option::is_some(&__field2) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "value" ) ) ;
                                                    }
                                                    __field2 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Box<Expression<'a>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "start_bracket",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("key") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::export::Some(__field2) => __field2,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("value") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Field::ExpressionKey {
                                            start_bracket: __field0,
                                            key: __field1,
                                            value: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["start_bracket", "key", "value"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Field<'a>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "key" => _serde::export::Ok(__Field::__field0),
                                            "value" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"key" => _serde::export::Ok(__Field::__field0),
                                            b"value" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de: 'a, 'a> {
                                    marker: _serde::export::PhantomData<Field<'a>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = Field<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant Field::NameKey",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Box<TokenReference<'a>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant Field::NameKey with 2 elements" ) ) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Box<Expression<'a>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant Field::NameKey with 2 elements" ) ) ;
                                                }
                                            };
                                        _serde::export::Ok(Field::NameKey {
                                            key: __field0,
                                            value: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<
                                            Box<TokenReference<'a>>,
                                        > = _serde::export::None;
                                        let mut __field1: _serde::export::Option<
                                            Box<Expression<'a>>,
                                        > = _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "key" ) ) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Box<TokenReference<'a>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "value" ) ) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Box<Expression<'a>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("key") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("value") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(Field::NameKey {
                                            key: __field0,
                                            value: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["key", "value"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<Field<'a>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<Expression<'a>>>(
                                    __variant,
                                ),
                                Field::NoKey,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["ExpressionKey", "NameKey", "NoKey"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Field",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Field<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Field: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Field<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Field::ExpressionKey {
                        ref start_bracket,
                        ref key,
                        ref value,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Field",
                            0u32,
                            "ExpressionKey",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "start_bracket",
                            start_bracket,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Field::NameKey { ref key, ref value } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Field",
                            1u32,
                            "NameKey",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Field::NoKey(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Field",
                        2u32,
                        "NoKey",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseField;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseField {
        #[inline]
        fn clone(&self) -> ParseField {
            match *self {
                ParseField => ParseField,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseField {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseField => {
                    let mut debug_trait_builder = f.debug_tuple("ParseField");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseField {
        #[inline]
        fn eq(&self, other: &ParseField) -> bool {
            match *other {
                ParseField => match *self {
                    ParseField => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseField {
        type Item = Field<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Field<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, start_bracket)) =
                    ParseSymbol(Symbol::LeftBracket).parse(state.clone())
                {
                    let (state, key) = match ParseExpression.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected key"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, _) = match ParseSymbol(Symbol::RightBracket).parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \']\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, _) = match ParseSymbol(Symbol::Equal).parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \'=\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, value) = match ParseExpression.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected value"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (key, value) = (Box::new(key), Box::new(value));
                    return Ok((
                        state.clone(),
                        Field::ExpressionKey {
                            key,
                            start_bracket,
                            value,
                        },
                    ));
                } else if let Ok((state, key)) = match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    if let Ok((state, _)) = ParseSymbol(Symbol::Equal).parse(state.clone()) {
                        let (state, value) = match ParseExpression.parse(state.clone()) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek(),
                                    additional: Some("expected value"),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        let (key, value) = (Box::new(key), Box::new(value));
                        return Ok((state.clone(), Field::NameKey { key, value }));
                    }
                }
                if let Ok((state, expr)) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let expr = Box::new(expr);
                    return Ok((state.clone(), Field::NoKey(expr)));
                }
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " A [`Field`](enum.Field.html) used when creating a table"]
    #[doc = " Second parameter is the separator used (`,` or `;`) if one exists"]
    pub type TableConstructorField<'a> = (Field<'a>, Option<TokenReference<'a>>);
    #[doc = " A table being constructed, such as `{ 1, 2, 3 }` or `{ a = 1 }`"]
    pub struct TableConstructor<'a> {
        #[serde(borrow)]
        fields: Vec<TableConstructorField<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for TableConstructor<'a> {
        #[inline]
        fn clone(&self) -> TableConstructor<'a> {
            match *self {
                TableConstructor {
                    fields: ref __self_0_0,
                } => TableConstructor {
                    fields: ::std::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for TableConstructor<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TableConstructor {
                    fields: ref __self_0_0,
                } => {
                    let mut debug_trait_builder = f.debug_struct("TableConstructor");
                    let _ = debug_trait_builder.field("fields", &&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for TableConstructor<'a> {
        #[inline]
        fn eq(&self, other: &TableConstructor<'a>) -> bool {
            match *other {
                TableConstructor {
                    fields: ref __self_1_0,
                } => match *self {
                    TableConstructor {
                        fields: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TableConstructor<'a>) -> bool {
            match *other {
                TableConstructor {
                    fields: ref __self_1_0,
                } => match *self {
                    TableConstructor {
                        fields: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl<'a> crate::node::Node for TableConstructor<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.fields.start_position()?, self.fields.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.fields.start_position()?, self.fields.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for TableConstructor<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_table_constructor(self);
            self.fields.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for TableConstructor<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_table_constructor(self);
            self.fields.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_TableConstructor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for TableConstructor<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 1",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "fields" => _serde::export::Ok(__Field::__field0),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"fields" => _serde::export::Ok(__Field::__field0),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<TableConstructor<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = TableConstructor<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TableConstructor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<TableConstructorField<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TableConstructor with 1 element",
                                ));
                            }
                        };
                        _serde::export::Ok(TableConstructor { fields: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<TableConstructorField<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "fields",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<TableConstructorField<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("fields") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(TableConstructor { fields: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["fields"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TableConstructor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TableConstructor<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_TableConstructor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for TableConstructor<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TableConstructor",
                    false as usize + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "fields",
                    &self.fields,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> TableConstructor<'a> {
        #[doc = " An iterator over the [fields](type.TableConstructorField.html) used to create the table"]
        pub fn iter_fields(&self) -> impl Iterator<Item = &TableConstructorField<'a>> {
            self.fields.iter()
        }
    }
    struct ParseTableConstructor;
    impl<'a> Parser<'a> for ParseTableConstructor {
        type Item = TableConstructor<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, TableConstructor<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (mut state, _) = ParseSymbol(Symbol::LeftBrace).parse(state.clone())?;
                let mut fields = Vec::new();
                while let Ok((new_state, field)) = match ParseField.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let field_sep = if let Ok((new_state, separator)) =
                        ParseSymbol(Symbol::Comma).parse(new_state.clone())
                    {
                        state = new_state;
                        Some(separator)
                    } else if let Ok((new_state, separator)) =
                        ParseSymbol(Symbol::Semicolon).parse(new_state.clone())
                    {
                        state = new_state;
                        Some(separator)
                    } else {
                        state = new_state;
                        None
                    };
                    let is_none = field_sep.is_none();
                    fields.push((field, field_sep));
                    if is_none {
                        break;
                    }
                }
                let (state, _) = match ParseSymbol(Symbol::RightBrace).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'}\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, TableConstructor { fields }))
            })(self, state)
        }
    }
    #[doc = " A binary operation, such as (`+ 3`)"]
    #[visit(visit_as = "bin_op")]
    pub struct BinOpRhs<'a> {
        #[serde(borrow)]
        bin_op: BinOp<'a>,
        rhs: Box<Expression<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for BinOpRhs<'a> {
        #[inline]
        fn clone(&self) -> BinOpRhs<'a> {
            match *self {
                BinOpRhs {
                    bin_op: ref __self_0_0,
                    rhs: ref __self_0_1,
                } => BinOpRhs {
                    bin_op: ::std::clone::Clone::clone(&(*__self_0_0)),
                    rhs: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for BinOpRhs<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                BinOpRhs {
                    bin_op: ref __self_0_0,
                    rhs: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("BinOpRhs");
                    let _ = debug_trait_builder.field("bin_op", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("rhs", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for BinOpRhs<'a> {
        #[inline]
        fn eq(&self, other: &BinOpRhs<'a>) -> bool {
            match *other {
                BinOpRhs {
                    bin_op: ref __self_1_0,
                    rhs: ref __self_1_1,
                } => match *self {
                    BinOpRhs {
                        bin_op: ref __self_0_0,
                        rhs: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &BinOpRhs<'a>) -> bool {
            match *other {
                BinOpRhs {
                    bin_op: ref __self_1_0,
                    rhs: ref __self_1_1,
                } => match *self {
                    BinOpRhs {
                        bin_op: ref __self_0_0,
                        rhs: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for BinOpRhs<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.bin_op.start_position()?, self.rhs.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.bin_op.start_position()?, self.rhs.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for BinOpRhs<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_bin_op(self);
            self.bin_op.visit(visitor);
            self.rhs.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for BinOpRhs<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_bin_op(self);
            self.bin_op.visit_mut(visitor);
            self.rhs.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_BinOpRhs: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for BinOpRhs<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bin_op" => _serde::export::Ok(__Field::__field0),
                            "rhs" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bin_op" => _serde::export::Ok(__Field::__field0),
                            b"rhs" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<BinOpRhs<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = BinOpRhs<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct BinOpRhs")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<BinOp<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct BinOpRhs with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Box<Expression<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct BinOpRhs with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(BinOpRhs {
                            bin_op: __field0,
                            rhs: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<BinOp<'a>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Box<Expression<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bin_op",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<BinOp<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "rhs",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Box<Expression<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("bin_op") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => match _serde::private::de::missing_field("rhs")
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            },
                        };
                        _serde::export::Ok(BinOpRhs {
                            bin_op: __field0,
                            rhs: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["bin_op", "rhs"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "BinOpRhs",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<BinOpRhs<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_BinOpRhs: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for BinOpRhs<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "BinOpRhs",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bin_op",
                    &self.bin_op,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "rhs",
                    &self.rhs,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> BinOpRhs<'a> {
        #[doc = " The binary operation used, the `+` part of `+ 3`"]
        pub fn bin_op(&self) -> &BinOp<'a> {
            &self.bin_op
        }
        #[doc = " The right hand side of the binary operation, the `3` part of `+ 3`"]
        pub fn rhs(&self) -> &Expression<'a> {
            self.rhs.as_ref()
        }
    }
    #[doc = " An expression, mostly useful for getting values"]
    #[serde(untagged)]
    pub enum Expression<'a> {
        #[doc = " A unary operation, such as `#list`"]
        UnaryOperator {
            #[serde(borrow)]
            #[doc = " The unary operation, the `#` part of `#list`"]
            unop: UnOp<'a>,
            #[doc = " The expression the operation is being done on, the `list` part of `#list`"]
            expression: Box<Expression<'a>>,
        },
        #[doc = " A value, such as \"strings\""]
        Value {
            #[doc = " The value itself"]
            #[serde(borrow)]
            value: Value<'a>,
            #[doc = " The binary operation being done, if one exists (the `+ 3` part of `2 + 3`)"]
            binop: Option<BinOpRhs<'a>>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Expression<'a> {
        #[inline]
        fn clone(&self) -> Expression<'a> {
            match (&*self,) {
                (&Expression::UnaryOperator {
                    unop: ref __self_0,
                    expression: ref __self_1,
                },) => Expression::UnaryOperator {
                    unop: ::std::clone::Clone::clone(&(*__self_0)),
                    expression: ::std::clone::Clone::clone(&(*__self_1)),
                },
                (&Expression::Value {
                    value: ref __self_0,
                    binop: ref __self_1,
                },) => Expression::Value {
                    value: ::std::clone::Clone::clone(&(*__self_0)),
                    binop: ::std::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Expression<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Expression::UnaryOperator {
                    unop: ref __self_0,
                    expression: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("UnaryOperator");
                    let _ = debug_trait_builder.field("unop", &&(*__self_0));
                    let _ = debug_trait_builder.field("expression", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&Expression::Value {
                    value: ref __self_0,
                    binop: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Value");
                    let _ = debug_trait_builder.field("value", &&(*__self_0));
                    let _ = debug_trait_builder.field("binop", &&(*__self_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Expression<'a> {
        #[inline]
        fn eq(&self, other: &Expression<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Expression::UnaryOperator {
                                unop: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::UnaryOperator {
                                unop: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Expression::Value {
                                value: ref __self_0,
                                binop: ref __self_1,
                            },
                            &Expression::Value {
                                value: ref __arg_1_0,
                                binop: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Expression<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Expression::UnaryOperator {
                                unop: ref __self_0,
                                expression: ref __self_1,
                            },
                            &Expression::UnaryOperator {
                                unop: ref __arg_1_0,
                                expression: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Expression::Value {
                                value: ref __self_0,
                                binop: ref __self_1,
                            },
                            &Expression::Value {
                                value: ref __arg_1_0,
                                binop: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Expression<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Expression::UnaryOperator { unop, expression } => {
                        Some((unop.start_position()?, expression.end_position()?))
                    }
                    Expression::Value { value, binop } => {
                        Some((value.start_position()?, binop.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Expression::UnaryOperator { unop, expression } => {
                        Some((unop.start_position()?, expression.end_position()?))
                    }
                    Expression::Value { value, binop } => {
                        Some((value.start_position()?, binop.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Expression<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_expression(self);
            match self {
                Expression::UnaryOperator { unop, expression } => {
                    unop.visit(visitor);
                    expression.visit(visitor);
                }
                Expression::Value { value, binop } => {
                    value.visit(visitor);
                    binop.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Expression<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_expression(self);
            match self {
                Expression::UnaryOperator { unop, expression } => {
                    unop.visit_mut(visitor);
                    expression.visit_mut(visitor);
                }
                Expression::Value { value, binop } => {
                    value.visit_mut(visitor);
                    binop.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Expression: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Expression<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                let __content =
                    match <_serde::private::de::Content as _serde::Deserialize>::deserialize(
                        __deserializer,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "unop" => _serde::export::Ok(__Field::__field0),
                                "expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"unop" => _serde::export::Ok(__Field::__field0),
                                b"expression" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de: 'a, 'a> {
                        marker: _serde::export::PhantomData<Expression<'a>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                        type Value = Expression<'a>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::UnaryOperator",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<UnOp<'a>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Box<Expression<'a>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unop",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<UnOp<'a>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "expression",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Box<Expression<'a>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("unop") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("expression") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::UnaryOperator {
                                unop: __field0,
                                expression: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["unop", "expression"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<'a>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                if let _serde::export::Ok(__ok) = {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "value" => _serde::export::Ok(__Field::__field0),
                                "binop" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"value" => _serde::export::Ok(__Field::__field0),
                                b"binop" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de: 'a, 'a> {
                        marker: _serde::export::PhantomData<Expression<'a>>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                        type Value = Expression<'a>;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct variant Expression::Value",
                            )
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Value<'a>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<BinOpRhs<'a>>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "value",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Value<'a>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "binop",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<BinOpRhs<'a>>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("value") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("binop") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Expression::Value {
                                value: __field0,
                                binop: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["value", "binop"];
                    _serde::Deserializer::deserialize_any(
                        _serde::private::de::ContentRefDeserializer::<__D::Error>::new(&__content),
                        __Visitor {
                            marker: _serde::export::PhantomData::<Expression<'a>>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                } {
                    return _serde::export::Ok(__ok);
                }
                _serde::export::Err(_serde::de::Error::custom(
                    "data did not match any variant of untagged enum Expression",
                ))
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Expression: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Expression<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Expression::UnaryOperator {
                        ref unop,
                        ref expression,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "unop",
                            unop,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "expression",
                            expression,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    Expression::Value {
                        ref value,
                        ref binop,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Expression",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "binop",
                            binop,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            }
        }
    };
    struct ParseExpression;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseExpression {
        #[inline]
        fn clone(&self) -> ParseExpression {
            match *self {
                ParseExpression => ParseExpression,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseExpression {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseExpression => {
                    let mut debug_trait_builder = f.debug_tuple("ParseExpression");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseExpression {
        #[inline]
        fn eq(&self, other: &ParseExpression) -> bool {
            match *other {
                ParseExpression => match *self {
                    ParseExpression => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseExpression {
        type Item = Expression<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Expression<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, value)) = match ParseValue.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let (state, binop) =
                        if let Ok((state, bin_op)) = ParseBinOp.parse(state.clone()) {
                            let (state, expression) = match ParseExpression.parse(state.clone()) {
                                Ok((state, node)) => (state, node),
                                Err(InternalAstError::NoMatch) => {
                                    return Err(InternalAstError::UnexpectedToken {
                                        token: state.peek(),
                                        additional: Some("expected expression"),
                                    });
                                }
                                Err(other) => return Err(other),
                            };
                            (
                                state,
                                Some(BinOpRhs {
                                    bin_op,
                                    rhs: Box::new(expression),
                                }),
                            )
                        } else {
                            (state, None)
                        };
                    Ok((state, Expression::Value { value, binop }))
                } else if let Ok((state, unop)) = match ParseUnOp.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let (state, expression) = match ParseExpression.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected expression"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((
                        state,
                        Expression::UnaryOperator {
                            unop,
                            expression: Box::new(expression),
                        },
                    ))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    struct ParseParenExpression;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseParenExpression {
        #[inline]
        fn clone(&self) -> ParseParenExpression {
            match *self {
                ParseParenExpression => ParseParenExpression,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseParenExpression {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseParenExpression => {
                    let mut debug_trait_builder = f.debug_tuple("ParseParenExpression");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseParenExpression {
        #[inline]
        fn eq(&self, other: &ParseParenExpression) -> bool {
            match *other {
                ParseParenExpression => match *self {
                    ParseParenExpression => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseParenExpression {
        type Item = Expression<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Expression<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = ParseSymbol(Symbol::LeftParen).parse(state.clone()) {
                    let (state, expression) = match ParseExpression.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected expression"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, _) = match ParseSymbol(Symbol::RightParen).parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \')\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, expression))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " Values that cannot be used standalone, but as part of things such as [statements](enum.Stmt.html)"]
    pub enum Value<'a> {
        #[serde(borrow)]
        #[doc = " An anonymous function, such as `function() end)`"]
        Function(FunctionBody<'a>),
        #[doc = " A call of a function, such as `call()`"]
        FunctionCall(Box<FunctionCall<'a>>),
        #[doc = " A table constructor, such as `{ 1, 2, 3 }`"]
        TableConstructor(Box<TableConstructor<'a>>),
        #[doc = " A number token, such as `3.3`"]
        Number(TokenReference<'a>),
        #[doc = " An expression between parentheses, such as `(3 + 2)`"]
        ParseExpression(Box<Expression<'a>>),
        #[doc = " A string token, such as `\"hello\"`"]
        String(TokenReference<'a>),
        #[doc = " A symbol, such as `true`"]
        Symbol(TokenReference<'a>),
        #[doc = " A more complex value, such as `call().x`"]
        Var(Box<Var<'a>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Value<'a> {
        #[inline]
        fn clone(&self) -> Value<'a> {
            match (&*self,) {
                (&Value::Function(ref __self_0),) => {
                    Value::Function(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::FunctionCall(ref __self_0),) => {
                    Value::FunctionCall(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::TableConstructor(ref __self_0),) => {
                    Value::TableConstructor(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Number(ref __self_0),) => {
                    Value::Number(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::ParseExpression(ref __self_0),) => {
                    Value::ParseExpression(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::String(ref __self_0),) => {
                    Value::String(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Symbol(ref __self_0),) => {
                    Value::Symbol(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Value::Var(ref __self_0),) => {
                    Value::Var(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Value<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Value::Function(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Function");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::FunctionCall(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("FunctionCall");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::TableConstructor(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TableConstructor");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Number(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Number");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::ParseExpression(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("ParseExpression");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::String(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Symbol(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Symbol");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Value::Var(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Var");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Value<'a> {
        #[inline]
        fn eq(&self, other: &Value<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Function(ref __self_0), &Value::Function(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Value::FunctionCall(ref __self_0),
                            &Value::FunctionCall(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Value::TableConstructor(ref __self_0),
                            &Value::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Value::Number(ref __self_0), &Value::Number(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Value::ParseExpression(ref __self_0),
                            &Value::ParseExpression(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Value::String(ref __self_0), &Value::String(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Value::Symbol(ref __self_0), &Value::Symbol(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Value::Var(ref __self_0), &Value::Var(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Value<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Value::Function(ref __self_0), &Value::Function(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Value::FunctionCall(ref __self_0),
                            &Value::FunctionCall(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Value::TableConstructor(ref __self_0),
                            &Value::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Value::Number(ref __self_0), &Value::Number(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Value::ParseExpression(ref __self_0),
                            &Value::ParseExpression(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Value::String(ref __self_0), &Value::String(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Value::Symbol(ref __self_0), &Value::Symbol(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Value::Var(ref __self_0), &Value::Var(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Value<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Value::Function(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::FunctionCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::TableConstructor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::Number(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::ParseExpression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::String(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::Symbol(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::Var(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Value::Function(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::FunctionCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::TableConstructor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::Number(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::ParseExpression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Value::String(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::Symbol(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Value::Var(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Value<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_value(self);
            match self {
                Value::Function(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::FunctionCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::TableConstructor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Number(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::ParseExpression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::String(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Symbol(__self_0) => {
                    __self_0.visit(visitor);
                }
                Value::Var(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Value<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_value(self);
            match self {
                Value::Function(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::FunctionCall(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::TableConstructor(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::Number(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::ParseExpression(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::String(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::Symbol(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Value::Var(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Value: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Value<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 8",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Function" => _serde::export::Ok(__Field::__field0),
                            "FunctionCall" => _serde::export::Ok(__Field::__field1),
                            "TableConstructor" => _serde::export::Ok(__Field::__field2),
                            "Number" => _serde::export::Ok(__Field::__field3),
                            "ParseExpression" => _serde::export::Ok(__Field::__field4),
                            "String" => _serde::export::Ok(__Field::__field5),
                            "Symbol" => _serde::export::Ok(__Field::__field6),
                            "Var" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Function" => _serde::export::Ok(__Field::__field0),
                            b"FunctionCall" => _serde::export::Ok(__Field::__field1),
                            b"TableConstructor" => _serde::export::Ok(__Field::__field2),
                            b"Number" => _serde::export::Ok(__Field::__field3),
                            b"ParseExpression" => _serde::export::Ok(__Field::__field4),
                            b"String" => _serde::export::Ok(__Field::__field5),
                            b"Symbol" => _serde::export::Ok(__Field::__field6),
                            b"Var" => _serde::export::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Value<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Value<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Value")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionBody<'a>>(
                                    __variant,
                                ),
                                Value::Function,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<FunctionCall<'a>>>(
                                    __variant,
                                ),
                                Value::FunctionCall,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Box<TableConstructor<'a>>,
                                >(__variant),
                                Value::TableConstructor,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Value::Number,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<Expression<'a>>>(
                                    __variant,
                                ),
                                Value::ParseExpression,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Value::String,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Value::Symbol,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<Var<'a>>>(
                                    __variant,
                                ),
                                Value::Var,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Function",
                    "FunctionCall",
                    "TableConstructor",
                    "Number",
                    "ParseExpression",
                    "String",
                    "Symbol",
                    "Var",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Value",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Value<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Value: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Value<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Value::Function(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        0u32,
                        "Function",
                        __field0,
                    ),
                    Value::FunctionCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            1u32,
                            "FunctionCall",
                            __field0,
                        )
                    }
                    Value::TableConstructor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            2u32,
                            "TableConstructor",
                            __field0,
                        )
                    }
                    Value::Number(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        3u32,
                        "Number",
                        __field0,
                    ),
                    Value::ParseExpression(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Value",
                            4u32,
                            "ParseExpression",
                            __field0,
                        )
                    }
                    Value::String(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        5u32,
                        "String",
                        __field0,
                    ),
                    Value::Symbol(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        6u32,
                        "Symbol",
                        __field0,
                    ),
                    Value::Var(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Value",
                        7u32,
                        "Var",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseValue;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseValue {
        #[inline]
        fn clone(&self) -> ParseValue {
            match *self {
                ParseValue => ParseValue,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseValue {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseValue => {
                    let mut debug_trait_builder = f.debug_tuple("ParseValue");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseValue {
        #[inline]
        fn eq(&self, other: &ParseValue) -> bool {
            match *other {
                ParseValue => match *self {
                    ParseValue => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseValue {
        type Item = Value<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Value<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseSymbol(Symbol::Nil).parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Symbol(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseSymbol(Symbol::False).parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Symbol(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseSymbol(Symbol::True).parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Symbol(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseNumber.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Number(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseStringLiteral.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::String(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseSymbol(Symbol::Ellipse).parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Symbol(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseFunction.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Function(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseTableConstructor.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::TableConstructor(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseFunctionCall.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::FunctionCall(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseVar.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::Var(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseParenExpression.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Value::ParseExpression(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " A statement that stands alone"]
    pub enum Stmt<'a> {
        #[serde(borrow)]
        #[doc = " An assignment, such as `x = 1`"]
        Assignment(Assignment<'a>),
        #[doc = " A do block, `do end`"]
        Do(Block<'a>),
        #[doc = " A function call on its own, such as `call()`"]
        FunctionCall(Box<FunctionCall<'a>>),
        #[doc = " A function declaration, such as `function x() end`"]
        FunctionDeclaration(Box<FunctionDeclaration<'a>>),
        #[doc = " A generic for loop, such as `for index, value in pairs(list) do end`"]
        GenericFor(Box<GenericFor<'a>>),
        #[doc = " An if statement"]
        If(Box<If<'a>>),
        #[doc = " A local assignment, such as `local x = 1`"]
        LocalAssignment(LocalAssignment<'a>),
        #[doc = " A local function declaration, such as `local function x() end`"]
        LocalFunction(LocalFunction<'a>),
        #[doc = " A numeric for loop, such as `for index = 1, 10 do end`"]
        NumericFor(Box<NumericFor<'a>>),
        #[doc = " A repeat loop"]
        Repeat(Box<Repeat<'a>>),
        #[doc = " A while loop"]
        While(Box<While<'a>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Stmt<'a> {
        #[inline]
        fn clone(&self) -> Stmt<'a> {
            match (&*self,) {
                (&Stmt::Assignment(ref __self_0),) => {
                    Stmt::Assignment(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::Do(ref __self_0),) => Stmt::Do(::std::clone::Clone::clone(&(*__self_0))),
                (&Stmt::FunctionCall(ref __self_0),) => {
                    Stmt::FunctionCall(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::FunctionDeclaration(ref __self_0),) => {
                    Stmt::FunctionDeclaration(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::GenericFor(ref __self_0),) => {
                    Stmt::GenericFor(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::If(ref __self_0),) => Stmt::If(::std::clone::Clone::clone(&(*__self_0))),
                (&Stmt::LocalAssignment(ref __self_0),) => {
                    Stmt::LocalAssignment(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::LocalFunction(ref __self_0),) => {
                    Stmt::LocalFunction(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::NumericFor(ref __self_0),) => {
                    Stmt::NumericFor(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::Repeat(ref __self_0),) => {
                    Stmt::Repeat(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Stmt::While(ref __self_0),) => {
                    Stmt::While(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Stmt<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Stmt::Assignment(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Assignment");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::Do(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Do");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::FunctionCall(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("FunctionCall");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::FunctionDeclaration(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("FunctionDeclaration");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::GenericFor(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("GenericFor");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::If(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("If");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::LocalAssignment(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("LocalAssignment");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::LocalFunction(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("LocalFunction");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::NumericFor(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("NumericFor");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::Repeat(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Repeat");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Stmt::While(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("While");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Stmt<'a> {
        #[inline]
        fn eq(&self, other: &Stmt<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Assignment(ref __self_0), &Stmt::Assignment(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::Do(ref __self_0), &Stmt::Do(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::FunctionCall(ref __self_0), &Stmt::FunctionCall(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Stmt::FunctionDeclaration(ref __self_0),
                            &Stmt::FunctionDeclaration(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Stmt::GenericFor(ref __self_0), &Stmt::GenericFor(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::If(ref __self_0), &Stmt::If(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Stmt::LocalAssignment(ref __self_0),
                            &Stmt::LocalAssignment(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Stmt::LocalFunction(ref __self_0),
                            &Stmt::LocalFunction(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Stmt::NumericFor(ref __self_0), &Stmt::NumericFor(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::Repeat(ref __self_0), &Stmt::Repeat(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Stmt::While(ref __self_0), &Stmt::While(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Stmt<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Stmt::Assignment(ref __self_0), &Stmt::Assignment(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::Do(ref __self_0), &Stmt::Do(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::FunctionCall(ref __self_0), &Stmt::FunctionCall(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Stmt::FunctionDeclaration(ref __self_0),
                            &Stmt::FunctionDeclaration(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Stmt::GenericFor(ref __self_0), &Stmt::GenericFor(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::If(ref __self_0), &Stmt::If(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Stmt::LocalAssignment(ref __self_0),
                            &Stmt::LocalAssignment(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Stmt::LocalFunction(ref __self_0),
                            &Stmt::LocalFunction(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Stmt::NumericFor(ref __self_0), &Stmt::NumericFor(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::Repeat(ref __self_0), &Stmt::Repeat(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Stmt::While(ref __self_0), &Stmt::While(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Stmt<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Stmt::Assignment(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::Do(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::FunctionCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::FunctionDeclaration(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::GenericFor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::If(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::LocalAssignment(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::LocalFunction(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::NumericFor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::Repeat(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::While(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Stmt::Assignment(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::Do(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::FunctionCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::FunctionDeclaration(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::GenericFor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::If(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::LocalAssignment(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::LocalFunction(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::NumericFor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Stmt::Repeat(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Stmt::While(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Stmt<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_stmt(self);
            match self {
                Stmt::Assignment(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::Do(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::FunctionCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::FunctionDeclaration(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::GenericFor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::If(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::LocalAssignment(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::LocalFunction(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::NumericFor(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::Repeat(__self_0) => {
                    __self_0.visit(visitor);
                }
                Stmt::While(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Stmt<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_stmt(self);
            match self {
                Stmt::Assignment(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::Do(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::FunctionCall(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::FunctionDeclaration(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::GenericFor(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::If(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::LocalAssignment(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::LocalFunction(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::NumericFor(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::Repeat(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Stmt::While(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Stmt: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Stmt<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 11",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Assignment" => _serde::export::Ok(__Field::__field0),
                            "Do" => _serde::export::Ok(__Field::__field1),
                            "FunctionCall" => _serde::export::Ok(__Field::__field2),
                            "FunctionDeclaration" => _serde::export::Ok(__Field::__field3),
                            "GenericFor" => _serde::export::Ok(__Field::__field4),
                            "If" => _serde::export::Ok(__Field::__field5),
                            "LocalAssignment" => _serde::export::Ok(__Field::__field6),
                            "LocalFunction" => _serde::export::Ok(__Field::__field7),
                            "NumericFor" => _serde::export::Ok(__Field::__field8),
                            "Repeat" => _serde::export::Ok(__Field::__field9),
                            "While" => _serde::export::Ok(__Field::__field10),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Assignment" => _serde::export::Ok(__Field::__field0),
                            b"Do" => _serde::export::Ok(__Field::__field1),
                            b"FunctionCall" => _serde::export::Ok(__Field::__field2),
                            b"FunctionDeclaration" => _serde::export::Ok(__Field::__field3),
                            b"GenericFor" => _serde::export::Ok(__Field::__field4),
                            b"If" => _serde::export::Ok(__Field::__field5),
                            b"LocalAssignment" => _serde::export::Ok(__Field::__field6),
                            b"LocalFunction" => _serde::export::Ok(__Field::__field7),
                            b"NumericFor" => _serde::export::Ok(__Field::__field8),
                            b"Repeat" => _serde::export::Ok(__Field::__field9),
                            b"While" => _serde::export::Ok(__Field::__field10),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Stmt<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Stmt<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Stmt")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Assignment<'a>>(
                                    __variant,
                                ),
                                Stmt::Assignment,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Block<'a>>(__variant),
                                Stmt::Do,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<FunctionCall<'a>>>(
                                    __variant,
                                ),
                                Stmt::FunctionCall,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Box<FunctionDeclaration<'a>>,
                                >(__variant),
                                Stmt::FunctionDeclaration,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<GenericFor<'a>>>(
                                    __variant,
                                ),
                                Stmt::GenericFor,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<If<'a>>>(
                                    __variant,
                                ),
                                Stmt::If,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<LocalAssignment<'a>>(
                                    __variant,
                                ),
                                Stmt::LocalAssignment,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<LocalFunction<'a>>(
                                    __variant,
                                ),
                                Stmt::LocalFunction,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<NumericFor<'a>>>(
                                    __variant,
                                ),
                                Stmt::NumericFor,
                            ),
                            (__Field::__field9, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<Repeat<'a>>>(
                                    __variant,
                                ),
                                Stmt::Repeat,
                            ),
                            (__Field::__field10, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Box<While<'a>>>(
                                    __variant,
                                ),
                                Stmt::While,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Assignment",
                    "Do",
                    "FunctionCall",
                    "FunctionDeclaration",
                    "GenericFor",
                    "If",
                    "LocalAssignment",
                    "LocalFunction",
                    "NumericFor",
                    "Repeat",
                    "While",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Stmt",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Stmt<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Stmt: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Stmt<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Stmt::Assignment(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            0u32,
                            "Assignment",
                            __field0,
                        )
                    }
                    Stmt::Do(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        1u32,
                        "Do",
                        __field0,
                    ),
                    Stmt::FunctionCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            2u32,
                            "FunctionCall",
                            __field0,
                        )
                    }
                    Stmt::FunctionDeclaration(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            3u32,
                            "FunctionDeclaration",
                            __field0,
                        )
                    }
                    Stmt::GenericFor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            4u32,
                            "GenericFor",
                            __field0,
                        )
                    }
                    Stmt::If(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        5u32,
                        "If",
                        __field0,
                    ),
                    Stmt::LocalAssignment(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            6u32,
                            "LocalAssignment",
                            __field0,
                        )
                    }
                    Stmt::LocalFunction(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            7u32,
                            "LocalFunction",
                            __field0,
                        )
                    }
                    Stmt::NumericFor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Stmt",
                            8u32,
                            "NumericFor",
                            __field0,
                        )
                    }
                    Stmt::Repeat(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        9u32,
                        "Repeat",
                        __field0,
                    ),
                    Stmt::While(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Stmt",
                        10u32,
                        "While",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseStmt;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseStmt {
        #[inline]
        fn clone(&self) -> ParseStmt {
            match *self {
                ParseStmt => ParseStmt,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseStmt {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseStmt => {
                    let mut debug_trait_builder = f.debug_tuple("ParseStmt");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseStmt {
        #[inline]
        fn default() -> ParseStmt {
            ParseStmt
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseStmt {
        #[inline]
        fn eq(&self, other: &ParseStmt) -> bool {
            match *other {
                ParseStmt => match *self {
                    ParseStmt => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseStmt {
        type Item = Stmt<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Stmt<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseAssignment.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::Assignment(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseFunctionCall.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::FunctionCall(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseDo.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::Do(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseWhile.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::While(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseRepeat.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::Repeat(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseIf.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::If(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseNumericFor.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::NumericFor(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseGenericFor.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::GenericFor(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseFunctionDeclaration.parse(state.clone()) {
                    Ok((state, node)) => {
                        return Ok((state, Stmt::FunctionDeclaration(node.into())))
                    }
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseLocalFunction.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::LocalFunction(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseLocalAssignment.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Stmt::LocalAssignment(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " A node used before another in cases such as function calling"]
    #[doc = " The `(\"foo\")` part of `(\"foo\"):upper()`"]
    pub enum Prefix<'a> {
        #[serde(borrow)]
        #[doc = " A complicated expression, such as `(\"foo\")`"]
        Expression(Expression<'a>),
        #[doc = " Just a name, such as `foo`"]
        Name(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Prefix<'a> {
        #[inline]
        fn clone(&self) -> Prefix<'a> {
            match (&*self,) {
                (&Prefix::Expression(ref __self_0),) => {
                    Prefix::Expression(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Prefix::Name(ref __self_0),) => {
                    Prefix::Name(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Prefix<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Prefix::Expression(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Expression");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Prefix::Name(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Name");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Prefix<'a> {
        #[inline]
        fn eq(&self, other: &Prefix<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Prefix::Expression(ref __self_0), &Prefix::Expression(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Prefix::Name(ref __self_0), &Prefix::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Prefix<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Prefix::Expression(ref __self_0), &Prefix::Expression(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Prefix::Name(ref __self_0), &Prefix::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Prefix<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Prefix::Expression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Prefix::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Prefix::Expression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Prefix::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Prefix<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_prefix(self);
            match self {
                Prefix::Expression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Prefix::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Prefix<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_prefix(self);
            match self {
                Prefix::Expression(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Prefix::Name(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Prefix: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Prefix<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Expression" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Expression" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Prefix<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Prefix<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Prefix")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Expression<'a>>(
                                    __variant,
                                ),
                                Prefix::Expression,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Prefix::Name,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Expression", "Name"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Prefix",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Prefix<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Prefix: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Prefix<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Prefix::Expression(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Prefix",
                            0u32,
                            "Expression",
                            __field0,
                        )
                    }
                    Prefix::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Prefix",
                        1u32,
                        "Name",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParsePrefix;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParsePrefix {
        #[inline]
        fn clone(&self) -> ParsePrefix {
            match *self {
                ParsePrefix => ParsePrefix,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParsePrefix {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParsePrefix => {
                    let mut debug_trait_builder = f.debug_tuple("ParsePrefix");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParsePrefix {
        #[inline]
        fn eq(&self, other: &ParsePrefix) -> bool {
            match *other {
                ParsePrefix => match *self {
                    ParsePrefix => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParsePrefix {
        type Item = Prefix<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Prefix<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseParenExpression.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Prefix::Expression(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Prefix::Name(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " The indexing of something, such as `x.y` or `x[\"y\"]`"]
    #[doc = " Values of variants are the keys, such as `\"y\"`"]
    pub enum Index<'a> {
        #[serde(borrow)]
        #[doc = " Indexing in the form of `x[\"y\"]`"]
        Brackets(Expression<'a>),
        #[doc = " Indexing in the form of `x.y`"]
        Dot(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Index<'a> {
        #[inline]
        fn clone(&self) -> Index<'a> {
            match (&*self,) {
                (&Index::Brackets(ref __self_0),) => {
                    Index::Brackets(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Index::Dot(ref __self_0),) => {
                    Index::Dot(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Index<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Index::Brackets(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Brackets");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Index::Dot(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Dot");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Index<'a> {
        #[inline]
        fn eq(&self, other: &Index<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Index::Brackets(ref __self_0), &Index::Brackets(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Index::Dot(ref __self_0), &Index::Dot(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Index<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Index::Brackets(ref __self_0), &Index::Brackets(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Index::Dot(ref __self_0), &Index::Dot(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Index<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Index::Brackets(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Index::Dot(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Index::Brackets(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Index::Dot(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Index<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_index(self);
            match self {
                Index::Brackets(__self_0) => {
                    __self_0.visit(visitor);
                }
                Index::Dot(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Index<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_index(self);
            match self {
                Index::Brackets(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Index::Dot(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Index: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Index<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Brackets" => _serde::export::Ok(__Field::__field0),
                            "Dot" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Brackets" => _serde::export::Ok(__Field::__field0),
                            b"Dot" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Index<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Index<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Index")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Expression<'a>>(
                                    __variant,
                                ),
                                Index::Brackets,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Index::Dot,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Brackets", "Dot"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Index",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Index<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Index: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Index<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Index::Brackets(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Index",
                        0u32,
                        "Brackets",
                        __field0,
                    ),
                    Index::Dot(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Index",
                        1u32,
                        "Dot",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseIndex;
    impl<'a> Parser<'a> for ParseIndex {
        type Item = Index<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Index<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = ParseSymbol(Symbol::LeftBracket).parse(state.clone()) {
                    let (state, expression) = match ParseExpression.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected expression"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, _) = match ParseSymbol(Symbol::RightBracket).parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \']\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, Index::Brackets(expression)))
                } else if let Ok((state, _)) = ParseSymbol(Symbol::Dot).parse(state.clone()) {
                    let (state, name) = match ParseIdentifier.parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected name"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, Index::Dot(name)))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " Arguments used for a function"]
    pub enum FunctionArgs<'a> {
        #[serde(borrow)]
        #[doc = " Used when a function is called in the form of `call(1, 2, 3)`"]
        Parentheses(Vec<Expression<'a>>),
        #[doc = " Used when a function is called in the form of `call \"foobar\"`"]
        String(TokenReference<'a>),
        #[doc = " Used when a function is called in the form of `call { 1, 2, 3 }`"]
        TableConstructor(Box<TableConstructor<'a>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for FunctionArgs<'a> {
        #[inline]
        fn clone(&self) -> FunctionArgs<'a> {
            match (&*self,) {
                (&FunctionArgs::Parentheses(ref __self_0),) => {
                    FunctionArgs::Parentheses(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&FunctionArgs::String(ref __self_0),) => {
                    FunctionArgs::String(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&FunctionArgs::TableConstructor(ref __self_0),) => {
                    FunctionArgs::TableConstructor(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for FunctionArgs<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FunctionArgs::Parentheses(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Parentheses");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&FunctionArgs::String(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("String");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&FunctionArgs::TableConstructor(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TableConstructor");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for FunctionArgs<'a> {
        #[inline]
        fn eq(&self, other: &FunctionArgs<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FunctionArgs::Parentheses(ref __self_0),
                            &FunctionArgs::Parentheses(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &FunctionArgs::String(ref __self_0),
                            &FunctionArgs::String(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &FunctionArgs::TableConstructor(ref __self_0),
                            &FunctionArgs::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionArgs<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FunctionArgs::Parentheses(ref __self_0),
                            &FunctionArgs::Parentheses(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &FunctionArgs::String(ref __self_0),
                            &FunctionArgs::String(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &FunctionArgs::TableConstructor(ref __self_0),
                            &FunctionArgs::TableConstructor(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for FunctionArgs<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    FunctionArgs::Parentheses(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    FunctionArgs::String(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    FunctionArgs::TableConstructor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    FunctionArgs::Parentheses(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    FunctionArgs::String(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    FunctionArgs::TableConstructor(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for FunctionArgs<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_function_args(self);
            match self {
                FunctionArgs::Parentheses(__self_0) => {
                    __self_0.visit(visitor);
                }
                FunctionArgs::String(__self_0) => {
                    __self_0.visit(visitor);
                }
                FunctionArgs::TableConstructor(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for FunctionArgs<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_function_args(self);
            match self {
                FunctionArgs::Parentheses(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                FunctionArgs::String(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                FunctionArgs::TableConstructor(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_FunctionArgs: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for FunctionArgs<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Parentheses" => _serde::export::Ok(__Field::__field0),
                            "String" => _serde::export::Ok(__Field::__field1),
                            "TableConstructor" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Parentheses" => _serde::export::Ok(__Field::__field0),
                            b"String" => _serde::export::Ok(__Field::__field1),
                            b"TableConstructor" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<FunctionArgs<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = FunctionArgs<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum FunctionArgs")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<Expression<'a>>>(
                                    __variant,
                                ),
                                FunctionArgs::Parentheses,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                FunctionArgs::String,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Box<TableConstructor<'a>>,
                                >(__variant),
                                FunctionArgs::TableConstructor,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["Parentheses", "String", "TableConstructor"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "FunctionArgs",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionArgs<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_FunctionArgs: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for FunctionArgs<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    FunctionArgs::Parentheses(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            0u32,
                            "Parentheses",
                            __field0,
                        )
                    }
                    FunctionArgs::String(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            1u32,
                            "String",
                            __field0,
                        )
                    }
                    FunctionArgs::TableConstructor(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "FunctionArgs",
                            2u32,
                            "TableConstructor",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    struct ParseFunctionArgs;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunctionArgs {
        #[inline]
        fn clone(&self) -> ParseFunctionArgs {
            match *self {
                ParseFunctionArgs => ParseFunctionArgs,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunctionArgs {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunctionArgs => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunctionArgs");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunctionArgs {
        #[inline]
        fn eq(&self, other: &ParseFunctionArgs) -> bool {
            match *other {
                ParseFunctionArgs => match *self {
                    ParseFunctionArgs => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunctionArgs {
        type Item = FunctionArgs<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionArgs<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = match ParseSymbol(Symbol::LeftParen).parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    let (state, expr_list) = match ZeroOrMoreDelimited(
                        ParseExpression,
                        ParseSymbol(Symbol::Comma),
                        false,
                    )
                    .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected arguments"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (state, _) = match ParseSymbol(Symbol::RightParen).parse(state.clone()) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \')\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    Ok((state, FunctionArgs::Parentheses(expr_list)))
                } else if let Ok((state, table_constructor)) =
                    match ParseTableConstructor.parse(state.clone()) {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    }
                {
                    Ok((
                        state,
                        FunctionArgs::TableConstructor(Box::new(table_constructor)),
                    ))
                } else if let Ok((state, string)) = match ParseStringLiteral.parse(state.clone()) {
                    Ok((state, node)) => Ok((state, node)),
                    Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                    Err(other) => return Err(other),
                } {
                    Ok((state, FunctionArgs::String(string)))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " A numeric for loop, such as `for index = 1, 10 do end`"]
    pub struct NumericFor<'a> {
        #[serde(borrow)]
        index_variable: TokenReference<'a>,
        start: Expression<'a>,
        end: Expression<'a>,
        step: Option<Expression<'a>>,
        block: Block<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for NumericFor<'a> {
        #[inline]
        fn clone(&self) -> NumericFor<'a> {
            match *self {
                NumericFor {
                    index_variable: ref __self_0_0,
                    start: ref __self_0_1,
                    end: ref __self_0_2,
                    step: ref __self_0_3,
                    block: ref __self_0_4,
                } => NumericFor {
                    index_variable: ::std::clone::Clone::clone(&(*__self_0_0)),
                    start: ::std::clone::Clone::clone(&(*__self_0_1)),
                    end: ::std::clone::Clone::clone(&(*__self_0_2)),
                    step: ::std::clone::Clone::clone(&(*__self_0_3)),
                    block: ::std::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for NumericFor<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                NumericFor {
                    index_variable: ref __self_0_0,
                    start: ref __self_0_1,
                    end: ref __self_0_2,
                    step: ref __self_0_3,
                    block: ref __self_0_4,
                } => {
                    let mut debug_trait_builder = f.debug_struct("NumericFor");
                    let _ = debug_trait_builder.field("index_variable", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("start", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("end", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("step", &&(*__self_0_3));
                    let _ = debug_trait_builder.field("block", &&(*__self_0_4));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for NumericFor<'a> {
        #[inline]
        fn eq(&self, other: &NumericFor<'a>) -> bool {
            match *other {
                NumericFor {
                    index_variable: ref __self_1_0,
                    start: ref __self_1_1,
                    end: ref __self_1_2,
                    step: ref __self_1_3,
                    block: ref __self_1_4,
                } => match *self {
                    NumericFor {
                        index_variable: ref __self_0_0,
                        start: ref __self_0_1,
                        end: ref __self_0_2,
                        step: ref __self_0_3,
                        block: ref __self_0_4,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                            && (*__self_0_4) == (*__self_1_4)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NumericFor<'a>) -> bool {
            match *other {
                NumericFor {
                    index_variable: ref __self_1_0,
                    start: ref __self_1_1,
                    end: ref __self_1_2,
                    step: ref __self_1_3,
                    block: ref __self_1_4,
                } => match *self {
                    NumericFor {
                        index_variable: ref __self_0_0,
                        start: ref __self_0_1,
                        end: ref __self_0_2,
                        step: ref __self_0_3,
                        block: ref __self_0_4,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                            || (*__self_0_4) != (*__self_1_4)
                    }
                },
            }
        }
    }
    impl<'a> crate::node::Node for NumericFor<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.index_variable.start_position()?,
                    self.block.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.index_variable.start_position()?,
                    self.block.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for NumericFor<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_numeric_for(self);
            self.index_variable.visit(visitor);
            self.start.visit(visitor);
            self.end.visit(visitor);
            self.step.visit(visitor);
            self.block.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for NumericFor<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_numeric_for(self);
            self.index_variable.visit_mut(visitor);
            self.start.visit_mut(visitor);
            self.end.visit_mut(visitor);
            self.step.visit_mut(visitor);
            self.block.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_NumericFor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for NumericFor<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 5",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "index_variable" => _serde::export::Ok(__Field::__field0),
                            "start" => _serde::export::Ok(__Field::__field1),
                            "end" => _serde::export::Ok(__Field::__field2),
                            "step" => _serde::export::Ok(__Field::__field3),
                            "block" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"index_variable" => _serde::export::Ok(__Field::__field0),
                            b"start" => _serde::export::Ok(__Field::__field1),
                            b"end" => _serde::export::Ok(__Field::__field2),
                            b"step" => _serde::export::Ok(__Field::__field3),
                            b"block" => _serde::export::Ok(__Field::__field4),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<NumericFor<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = NumericFor<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct NumericFor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct NumericFor with 5 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Expression<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct NumericFor with 5 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Expression<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct NumericFor with 5 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Option<Expression<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct NumericFor with 5 elements",
                                ));
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct NumericFor with 5 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(NumericFor {
                            index_variable: __field0,
                            start: __field1,
                            end: __field2,
                            step: __field3,
                            block: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Expression<'a>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<Expression<'a>> =
                            _serde::export::None;
                        let mut __field3: _serde::export::Option<Option<Expression<'a>>> =
                            _serde::export::None;
                        let mut __field4: _serde::export::Option<Block<'a>> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "index_variable",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "step",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Expression<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("index_variable") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("start") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => match _serde::private::de::missing_field("end")
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            },
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("step") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(NumericFor {
                            index_variable: __field0,
                            start: __field1,
                            end: __field2,
                            step: __field3,
                            block: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["index_variable", "start", "end", "step", "block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "NumericFor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<NumericFor<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_NumericFor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for NumericFor<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "NumericFor",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "index_variable",
                    &self.index_variable,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start",
                    &self.start,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end",
                    &self.end,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "step",
                    &self.step,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> NumericFor<'a> {
        #[doc = " The index identity, `index` in the initial example"]
        pub fn index_variable(&self) -> &Token<'a> {
            &self.index_variable
        }
        #[doc = " The starting point, `1` in the initial example"]
        pub fn start(&self) -> &Expression<'a> {
            &self.start
        }
        #[doc = " The ending point, `10` in the initial example"]
        pub fn end(&self) -> &Expression<'a> {
            &self.end
        }
        #[doc = " The step if one exists, `2` in `for index = 0, 10, 2 do end`"]
        pub fn step(&self) -> Option<&Expression<'a>> {
            self.step.as_ref()
        }
        #[doc = " The code inside the for loop"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
    }
    struct ParseNumericFor;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseNumericFor {
        #[inline]
        fn clone(&self) -> ParseNumericFor {
            match *self {
                ParseNumericFor => ParseNumericFor,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseNumericFor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseNumericFor => {
                    let mut debug_trait_builder = f.debug_tuple("ParseNumericFor");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseNumericFor {
        #[inline]
        fn eq(&self, other: &ParseNumericFor) -> bool {
            match *other {
                ParseNumericFor => match *self {
                    ParseNumericFor => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseNumericFor {
        type Item = NumericFor<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, NumericFor<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::For).parse(state.clone())?;
                let (state, index_variable) = match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected names"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = ParseSymbol(Symbol::Equal).parse(state.clone())?;
                let (state, start) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected start expression"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::Comma).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected comma"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, end) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected end expression"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, step) =
                    if let Ok((state, _)) = ParseSymbol(Symbol::Comma).parse(state.clone()) {
                        let (state, expression) = match ParseExpression.parse(state.clone()) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek(),
                                    additional: Some("expected limit expression"),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        (state, Some(expression))
                    } else {
                        (state, None)
                    };
                let (state, _) = match ParseSymbol(Symbol::Do).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'do\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((
                    state,
                    NumericFor {
                        index_variable,
                        start,
                        end,
                        step,
                        block,
                    },
                ))
            })(self, state)
        }
    }
    #[doc = " A generic for loop, such as `for index, value in pairs(list) do end`"]
    pub struct GenericFor<'a> {
        #[serde(borrow)]
        names: Vec<TokenReference<'a>>,
        expr_list: Vec<Expression<'a>>,
        block: Block<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for GenericFor<'a> {
        #[inline]
        fn clone(&self) -> GenericFor<'a> {
            match *self {
                GenericFor {
                    names: ref __self_0_0,
                    expr_list: ref __self_0_1,
                    block: ref __self_0_2,
                } => GenericFor {
                    names: ::std::clone::Clone::clone(&(*__self_0_0)),
                    expr_list: ::std::clone::Clone::clone(&(*__self_0_1)),
                    block: ::std::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for GenericFor<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                GenericFor {
                    names: ref __self_0_0,
                    expr_list: ref __self_0_1,
                    block: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("GenericFor");
                    let _ = debug_trait_builder.field("names", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("expr_list", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("block", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for GenericFor<'a> {
        #[inline]
        fn eq(&self, other: &GenericFor<'a>) -> bool {
            match *other {
                GenericFor {
                    names: ref __self_1_0,
                    expr_list: ref __self_1_1,
                    block: ref __self_1_2,
                } => match *self {
                    GenericFor {
                        names: ref __self_0_0,
                        expr_list: ref __self_0_1,
                        block: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GenericFor<'a>) -> bool {
            match *other {
                GenericFor {
                    names: ref __self_1_0,
                    expr_list: ref __self_1_1,
                    block: ref __self_1_2,
                } => match *self {
                    GenericFor {
                        names: ref __self_0_0,
                        expr_list: ref __self_0_1,
                        block: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl<'a> crate::node::Node for GenericFor<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.names.start_position()?, self.block.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.names.start_position()?, self.block.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for GenericFor<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_generic_for(self);
            self.names.visit(visitor);
            self.expr_list.visit(visitor);
            self.block.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for GenericFor<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_generic_for(self);
            self.names.visit_mut(visitor);
            self.expr_list.visit_mut(visitor);
            self.block.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_GenericFor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for GenericFor<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "names" => _serde::export::Ok(__Field::__field0),
                            "expr_list" => _serde::export::Ok(__Field::__field1),
                            "block" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"names" => _serde::export::Ok(__Field::__field0),
                            b"expr_list" => _serde::export::Ok(__Field::__field1),
                            b"block" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<GenericFor<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = GenericFor<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct GenericFor")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<TokenReference<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct GenericFor with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Expression<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct GenericFor with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct GenericFor with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(GenericFor {
                            names: __field0,
                            expr_list: __field1,
                            block: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<TokenReference<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Expression<'a>>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<Block<'a>> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "names",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<TokenReference<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Expression<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("names") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(GenericFor {
                            names: __field0,
                            expr_list: __field1,
                            block: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["names", "expr_list", "block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "GenericFor",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<GenericFor<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_GenericFor: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for GenericFor<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "GenericFor",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "names",
                    &self.names,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> GenericFor<'a> {
        #[doc = " An iterator over the names used in a for loop"]
        #[doc = " In `for index, value in pairs(list) do`, iterates over `index` and `value`"]
        pub fn iter_names(&self) -> impl Iterator<Item = &TokenReference<'a>> {
            self.names.iter()
        }
        #[doc = " An iterator over the expression used in a for loop"]
        #[doc = " In `for index, value in pairs(list) do`, iterates over `pairs(list)`"]
        pub fn iter_expr_list(&self) -> impl Iterator<Item = &Expression<'a>> {
            self.expr_list.iter()
        }
        #[doc = " The code inside the for loop"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
    }
    struct ParseGenericFor;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseGenericFor {
        #[inline]
        fn clone(&self) -> ParseGenericFor {
            match *self {
                ParseGenericFor => ParseGenericFor,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseGenericFor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseGenericFor => {
                    let mut debug_trait_builder = f.debug_tuple("ParseGenericFor");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseGenericFor {
        #[inline]
        fn eq(&self, other: &ParseGenericFor) -> bool {
            match *other {
                ParseGenericFor => match *self {
                    ParseGenericFor => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseGenericFor {
        type Item = GenericFor<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, GenericFor<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::For).parse(state.clone())?;
                let (state, names) =
                    match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected names"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                let (state, _) = match ParseSymbol(Symbol::In).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'in\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, expr_list) =
                    match OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected expression"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                let (state, _) = match ParseSymbol(Symbol::Do).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'do\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((
                    state,
                    GenericFor {
                        names,
                        expr_list,
                        block,
                    },
                ))
            })(self, state)
        }
    }
    #[doc = " An if statement"]
    pub struct If<'a> {
        #[serde(borrow)]
        condition: Expression<'a>,
        block: Block<'a>,
        else_if: Option<Vec<(Expression<'a>, Block<'a>)>>,
        #[serde(rename = "else")]
        r#else: Option<Block<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for If<'a> {
        #[inline]
        fn clone(&self) -> If<'a> {
            match *self {
                If {
                    condition: ref __self_0_0,
                    block: ref __self_0_1,
                    else_if: ref __self_0_2,
                    r#else: ref __self_0_3,
                } => If {
                    condition: ::std::clone::Clone::clone(&(*__self_0_0)),
                    block: ::std::clone::Clone::clone(&(*__self_0_1)),
                    else_if: ::std::clone::Clone::clone(&(*__self_0_2)),
                    r#else: ::std::clone::Clone::clone(&(*__self_0_3)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for If<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                If {
                    condition: ref __self_0_0,
                    block: ref __self_0_1,
                    else_if: ref __self_0_2,
                    r#else: ref __self_0_3,
                } => {
                    let mut debug_trait_builder = f.debug_struct("If");
                    let _ = debug_trait_builder.field("condition", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("block", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("else_if", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("else", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for If<'a> {
        #[inline]
        fn eq(&self, other: &If<'a>) -> bool {
            match *other {
                If {
                    condition: ref __self_1_0,
                    block: ref __self_1_1,
                    else_if: ref __self_1_2,
                    r#else: ref __self_1_3,
                } => match *self {
                    If {
                        condition: ref __self_0_0,
                        block: ref __self_0_1,
                        else_if: ref __self_0_2,
                        r#else: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &If<'a>) -> bool {
            match *other {
                If {
                    condition: ref __self_1_0,
                    block: ref __self_1_1,
                    else_if: ref __self_1_2,
                    r#else: ref __self_1_3,
                } => match *self {
                    If {
                        condition: ref __self_0_0,
                        block: ref __self_0_1,
                        else_if: ref __self_0_2,
                        r#else: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    impl<'a> crate::node::Node for If<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.condition.start_position()?,
                    self.r#else.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.condition.start_position()?,
                    self.r#else.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for If<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_if(self);
            self.condition.visit(visitor);
            self.block.visit(visitor);
            self.else_if.visit(visitor);
            self.r#else.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for If<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_if(self);
            self.condition.visit_mut(visitor);
            self.block.visit_mut(visitor);
            self.else_if.visit_mut(visitor);
            self.r#else.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_If: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for If<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "condition" => _serde::export::Ok(__Field::__field0),
                            "block" => _serde::export::Ok(__Field::__field1),
                            "else_if" => _serde::export::Ok(__Field::__field2),
                            "else" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"condition" => _serde::export::Ok(__Field::__field0),
                            b"block" => _serde::export::Ok(__Field::__field1),
                            b"else_if" => _serde::export::Ok(__Field::__field2),
                            b"else" => _serde::export::Ok(__Field::__field3),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<If<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = If<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct If")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Expression<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct If with 4 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct If with 4 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Option<Vec<(Expression<'a>, Block<'a>)>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct If with 4 elements",
                                ));
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            Option<Block<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct If with 4 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(If {
                            condition: __field0,
                            block: __field1,
                            else_if: __field2,
                            r#else: __field3,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Expression<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Block<'a>> = _serde::export::None;
                        let mut __field2: _serde::export::Option<
                            Option<Vec<(Expression<'a>, Block<'a>)>>,
                        > = _serde::export::None;
                        let mut __field3: _serde::export::Option<Option<Block<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else_if",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Vec<(Expression<'a>, Block<'a>)>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "else",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<Block<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("condition") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else_if") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("else") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(If {
                            condition: __field0,
                            block: __field1,
                            else_if: __field2,
                            r#else: __field3,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["condition", "block", "else_if", "else"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "If",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<If<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_If: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for If<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "If",
                    false as usize + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition",
                    &self.condition,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else_if",
                    &self.else_if,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "else",
                    &self.r#else,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> If<'a> {
        #[doc = " The condition of the if statement, `condition` in `if condition then`"]
        pub fn condition(&self) -> &Expression<'a> {
            &self.condition
        }
        #[doc = " The block inside the initial if statement"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
        #[doc = " If there are `elseif` conditions, returns a vector of them"]
        #[doc = " Expression is the condition, block is the code if the condition is true"]
        pub fn else_if(&self) -> Option<&Vec<(Expression<'a>, Block<'a>)>> {
            self.else_if.as_ref()
        }
        #[doc = " The code inside an `else` block if one exists"]
        pub fn else_block(&self) -> Option<&Block<'a>> {
            self.r#else.as_ref()
        }
    }
    struct ParseIf;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseIf {
        #[inline]
        fn clone(&self) -> ParseIf {
            match *self {
                ParseIf => ParseIf,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseIf {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseIf => {
                    let mut debug_trait_builder = f.debug_tuple("ParseIf");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseIf {
        #[inline]
        fn eq(&self, other: &ParseIf) -> bool {
            match *other {
                ParseIf => match *self {
                    ParseIf => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseIf {
        type Item = If<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, If<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::If).parse(state.clone())?;
                let (state, condition) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected condition"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::Then).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'then\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (mut state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let mut else_ifs = Vec::new();
                while let Ok((new_state, _)) = ParseSymbol(Symbol::ElseIf).parse(state.clone()) {
                    let (new_state, condition) = match ParseExpression.parse(new_state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected condition"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (new_state, _) = match ParseSymbol(Symbol::Then).parse(new_state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected \'then\'"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    let (new_state, block) = match ParseBlock.parse(new_state) {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected block"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                    state = new_state;
                    else_ifs.push((condition, block));
                }
                let (state, r#else) =
                    if let Ok((state, _)) = ParseSymbol(Symbol::Else).parse(state.clone()) {
                        let (state, block) = match ParseBlock.parse(state.clone()) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek(),
                                    additional: Some("expected block"),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        (state, Some(block))
                    } else {
                        (state, None)
                    };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((
                    state,
                    If {
                        condition,
                        block,
                        r#else,
                        else_if: if else_ifs.is_empty() {
                            None
                        } else {
                            Some(else_ifs)
                        },
                    },
                ))
            })(self, state)
        }
    }
    #[doc = " A while loop"]
    pub struct While<'a> {
        #[serde(borrow)]
        condition: Expression<'a>,
        block: Block<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for While<'a> {
        #[inline]
        fn clone(&self) -> While<'a> {
            match *self {
                While {
                    condition: ref __self_0_0,
                    block: ref __self_0_1,
                } => While {
                    condition: ::std::clone::Clone::clone(&(*__self_0_0)),
                    block: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for While<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                While {
                    condition: ref __self_0_0,
                    block: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("While");
                    let _ = debug_trait_builder.field("condition", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("block", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for While<'a> {
        #[inline]
        fn eq(&self, other: &While<'a>) -> bool {
            match *other {
                While {
                    condition: ref __self_1_0,
                    block: ref __self_1_1,
                } => match *self {
                    While {
                        condition: ref __self_0_0,
                        block: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &While<'a>) -> bool {
            match *other {
                While {
                    condition: ref __self_1_0,
                    block: ref __self_1_1,
                } => match *self {
                    While {
                        condition: ref __self_0_0,
                        block: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for While<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.condition.start_position()?, self.block.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.condition.start_position()?, self.block.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for While<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_while(self);
            self.condition.visit(visitor);
            self.block.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for While<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_while(self);
            self.condition.visit_mut(visitor);
            self.block.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_While: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for While<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "condition" => _serde::export::Ok(__Field::__field0),
                            "block" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"condition" => _serde::export::Ok(__Field::__field0),
                            b"block" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<While<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = While<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct While")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Expression<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct While with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct While with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(While {
                            condition: __field0,
                            block: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Expression<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Block<'a>> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "condition",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("condition") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(While {
                            condition: __field0,
                            block: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["condition", "block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "While",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<While<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_While: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for While<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "While",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "condition",
                    &self.condition,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> While<'a> {
        #[doc = " The `condition` part of `while condition do`"]
        pub fn condition(&self) -> &Expression<'a> {
            &self.condition
        }
        #[doc = " The code inside the while loop"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
    }
    struct ParseWhile;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseWhile {
        #[inline]
        fn clone(&self) -> ParseWhile {
            match *self {
                ParseWhile => ParseWhile,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseWhile {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseWhile => {
                    let mut debug_trait_builder = f.debug_tuple("ParseWhile");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseWhile {
        #[inline]
        fn eq(&self, other: &ParseWhile) -> bool {
            match *other {
                ParseWhile => match *self {
                    ParseWhile => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseWhile {
        type Item = While<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, While<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::While).parse(state.clone())?;
                let (state, condition) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected condition"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::Do).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'do\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, While { condition, block }))
            })(self, state)
        }
    }
    #[doc = " A repeat loop"]
    pub struct Repeat<'a> {
        #[serde(borrow)]
        block: Block<'a>,
        until: Expression<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Repeat<'a> {
        #[inline]
        fn clone(&self) -> Repeat<'a> {
            match *self {
                Repeat {
                    block: ref __self_0_0,
                    until: ref __self_0_1,
                } => Repeat {
                    block: ::std::clone::Clone::clone(&(*__self_0_0)),
                    until: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Repeat<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Repeat {
                    block: ref __self_0_0,
                    until: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Repeat");
                    let _ = debug_trait_builder.field("block", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("until", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Repeat<'a> {
        #[inline]
        fn eq(&self, other: &Repeat<'a>) -> bool {
            match *other {
                Repeat {
                    block: ref __self_1_0,
                    until: ref __self_1_1,
                } => match *self {
                    Repeat {
                        block: ref __self_0_0,
                        until: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Repeat<'a>) -> bool {
            match *other {
                Repeat {
                    block: ref __self_1_0,
                    until: ref __self_1_1,
                } => match *self {
                    Repeat {
                        block: ref __self_0_0,
                        until: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for Repeat<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.block.start_position()?, self.until.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.block.start_position()?, self.until.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Repeat<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_repeat(self);
            self.block.visit(visitor);
            self.until.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Repeat<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_repeat(self);
            self.block.visit_mut(visitor);
            self.until.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Repeat: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Repeat<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "block" => _serde::export::Ok(__Field::__field0),
                            "until" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"block" => _serde::export::Ok(__Field::__field0),
                            b"until" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Repeat<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Repeat<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Repeat")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Repeat with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Expression<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Repeat with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Repeat {
                            block: __field0,
                            until: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Block<'a>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Expression<'a>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "until",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Expression<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("until") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Repeat {
                            block: __field0,
                            until: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["block", "until"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Repeat",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Repeat<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Repeat: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Repeat<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Repeat",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "until",
                    &self.until,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> Repeat<'a> {
        #[doc = " The code inside the `repeat` block"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
        #[doc = " The condition for the `until` part"]
        pub fn until(&self) -> &Expression<'a> {
            &self.until
        }
    }
    struct ParseRepeat;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseRepeat {
        #[inline]
        fn clone(&self) -> ParseRepeat {
            match *self {
                ParseRepeat => ParseRepeat,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseRepeat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseRepeat => {
                    let mut debug_trait_builder = f.debug_tuple("ParseRepeat");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseRepeat {
        #[inline]
        fn eq(&self, other: &ParseRepeat) -> bool {
            match *other {
                ParseRepeat => match *self {
                    ParseRepeat => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseRepeat {
        type Item = Repeat<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Repeat<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Repeat).parse(state.clone())?;
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::Until).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'until\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, until) = match ParseExpression.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected condition"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, Repeat { until, block }))
            })(self, state)
        }
    }
    #[doc = " A method call, such as `x:y()`"]
    pub struct MethodCall<'a> {
        #[serde(borrow)]
        name: TokenReference<'a>,
        args: FunctionArgs<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for MethodCall<'a> {
        #[inline]
        fn clone(&self) -> MethodCall<'a> {
            match *self {
                MethodCall {
                    name: ref __self_0_0,
                    args: ref __self_0_1,
                } => MethodCall {
                    name: ::std::clone::Clone::clone(&(*__self_0_0)),
                    args: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for MethodCall<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MethodCall {
                    name: ref __self_0_0,
                    args: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("MethodCall");
                    let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("args", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for MethodCall<'a> {
        #[inline]
        fn eq(&self, other: &MethodCall<'a>) -> bool {
            match *other {
                MethodCall {
                    name: ref __self_1_0,
                    args: ref __self_1_1,
                } => match *self {
                    MethodCall {
                        name: ref __self_0_0,
                        args: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MethodCall<'a>) -> bool {
            match *other {
                MethodCall {
                    name: ref __self_1_0,
                    args: ref __self_1_1,
                } => match *self {
                    MethodCall {
                        name: ref __self_0_0,
                        args: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for MethodCall<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.args.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.args.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for MethodCall<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_method_call(self);
            self.name.visit(visitor);
            self.args.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for MethodCall<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_method_call(self);
            self.name.visit_mut(visitor);
            self.args.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_MethodCall: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for MethodCall<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::export::Ok(__Field::__field0),
                            "args" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::export::Ok(__Field::__field0),
                            b"args" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<MethodCall<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = MethodCall<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct MethodCall")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MethodCall with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            FunctionArgs<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MethodCall with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(MethodCall {
                            name: __field0,
                            args: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<FunctionArgs<'a>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "args",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionArgs<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("args") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(MethodCall {
                            name: __field0,
                            args: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "args"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MethodCall",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<MethodCall<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_MethodCall: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for MethodCall<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MethodCall",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "args",
                    &self.args,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> MethodCall<'a> {
        #[doc = " The arguments of a method call, the `x, y, z` part of `method:call(x, y, z)`"]
        pub fn args(&self) -> &FunctionArgs<'a> {
            &self.args
        }
        #[doc = " The method being called, the `call` part of `method:call()`"]
        pub fn name(&self) -> &Token<'a> {
            &self.name
        }
    }
    struct ParseMethodCall;
    impl<'a> Parser<'a> for ParseMethodCall {
        type Item = MethodCall<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, MethodCall<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Colon).parse(state.clone())?;
                let (state, name) = match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected method"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, args) = match ParseFunctionArgs.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected args"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, MethodCall { name, args }))
            })(self, state)
        }
    }
    #[doc = " Something being called"]
    pub enum Call<'a> {
        #[serde(borrow)]
        #[doc = " A function being called directly, such as `x(1)`"]
        AnonymousCall(FunctionArgs<'a>),
        #[doc = " A method call, such as `x:y()`"]
        MethodCall(MethodCall<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Call<'a> {
        #[inline]
        fn clone(&self) -> Call<'a> {
            match (&*self,) {
                (&Call::AnonymousCall(ref __self_0),) => {
                    Call::AnonymousCall(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Call::MethodCall(ref __self_0),) => {
                    Call::MethodCall(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Call<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Call::AnonymousCall(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("AnonymousCall");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Call::MethodCall(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("MethodCall");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Call<'a> {
        #[inline]
        fn eq(&self, other: &Call<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Call::AnonymousCall(ref __self_0),
                            &Call::AnonymousCall(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Call::MethodCall(ref __self_0), &Call::MethodCall(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Call<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Call::AnonymousCall(ref __self_0),
                            &Call::AnonymousCall(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Call::MethodCall(ref __self_0), &Call::MethodCall(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Call<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Call::AnonymousCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Call::MethodCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Call::AnonymousCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Call::MethodCall(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Call<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_call(self);
            match self {
                Call::AnonymousCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                Call::MethodCall(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Call<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_call(self);
            match self {
                Call::AnonymousCall(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Call::MethodCall(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Call: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Call<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "AnonymousCall" => _serde::export::Ok(__Field::__field0),
                            "MethodCall" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"AnonymousCall" => _serde::export::Ok(__Field::__field0),
                            b"MethodCall" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Call<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Call<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Call")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<FunctionArgs<'a>>(
                                    __variant,
                                ),
                                Call::AnonymousCall,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<MethodCall<'a>>(
                                    __variant,
                                ),
                                Call::MethodCall,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["AnonymousCall", "MethodCall"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Call",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Call<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Call: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Call<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Call::AnonymousCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Call",
                            0u32,
                            "AnonymousCall",
                            __field0,
                        )
                    }
                    Call::MethodCall(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Call",
                            1u32,
                            "MethodCall",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    struct ParseCall;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseCall {
        #[inline]
        fn clone(&self) -> ParseCall {
            match *self {
                ParseCall => ParseCall,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseCall {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseCall => {
                    let mut debug_trait_builder = f.debug_tuple("ParseCall");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseCall {
        #[inline]
        fn eq(&self, other: &ParseCall) -> bool {
            match *other {
                ParseCall => match *self {
                    ParseCall => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseCall {
        type Item = Call<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Call<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseFunctionArgs.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Call::AnonymousCall(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseMethodCall.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Call::MethodCall(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " A function body, everything except `function x` in `function x(a, b, c) call() end`"]
    pub struct FunctionBody<'a> {
        #[serde(borrow)]
        parameters: Vec<Parameter<'a>>,
        block: Block<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for FunctionBody<'a> {
        #[inline]
        fn clone(&self) -> FunctionBody<'a> {
            match *self {
                FunctionBody {
                    parameters: ref __self_0_0,
                    block: ref __self_0_1,
                } => FunctionBody {
                    parameters: ::std::clone::Clone::clone(&(*__self_0_0)),
                    block: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for FunctionBody<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FunctionBody {
                    parameters: ref __self_0_0,
                    block: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("FunctionBody");
                    let _ = debug_trait_builder.field("parameters", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("block", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for FunctionBody<'a> {
        #[inline]
        fn eq(&self, other: &FunctionBody<'a>) -> bool {
            match *other {
                FunctionBody {
                    parameters: ref __self_1_0,
                    block: ref __self_1_1,
                } => match *self {
                    FunctionBody {
                        parameters: ref __self_0_0,
                        block: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionBody<'a>) -> bool {
            match *other {
                FunctionBody {
                    parameters: ref __self_1_0,
                    block: ref __self_1_1,
                } => match *self {
                    FunctionBody {
                        parameters: ref __self_0_0,
                        block: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for FunctionBody<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.parameters.start_position()?,
                    self.block.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.parameters.start_position()?,
                    self.block.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for FunctionBody<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_function_body(self);
            self.parameters.visit(visitor);
            self.block.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for FunctionBody<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_function_body(self);
            self.parameters.visit_mut(visitor);
            self.block.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_FunctionBody: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for FunctionBody<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "parameters" => _serde::export::Ok(__Field::__field0),
                            "block" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"parameters" => _serde::export::Ok(__Field::__field0),
                            b"block" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<FunctionBody<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = FunctionBody<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionBody")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Parameter<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionBody with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Block<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionBody with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionBody {
                            parameters: __field0,
                            block: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<Parameter<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Block<'a>> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parameters",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Parameter<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "block",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Block<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("parameters") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("block") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionBody {
                            parameters: __field0,
                            block: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["parameters", "block"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionBody",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionBody<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_FunctionBody: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for FunctionBody<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionBody",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parameters",
                    &self.parameters,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "block",
                    &self.block,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> FunctionBody<'a> {
        #[doc = " The code of a function body"]
        pub fn block(&self) -> &Block<'a> {
            &self.block
        }
        #[doc = " An iterator over the parameters for the function declaration"]
        pub fn iter_parameters(&self) -> impl Iterator<Item = &Parameter<'a>> {
            self.parameters.iter()
        }
    }
    struct ParseFunctionBody;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunctionBody {
        #[inline]
        fn clone(&self) -> ParseFunctionBody {
            match *self {
                ParseFunctionBody => ParseFunctionBody,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunctionBody {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunctionBody => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunctionBody");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunctionBody {
        #[inline]
        fn eq(&self, other: &ParseFunctionBody) -> bool {
            match *other {
                ParseFunctionBody => match *self {
                    ParseFunctionBody => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunctionBody {
        type Item = FunctionBody<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionBody<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (mut state, _) = match ParseSymbol(Symbol::LeftParen).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'(\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let mut parameters = Vec::new();
                if let Ok((new_state, names)) =
                    match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                    {
                        Ok((state, node)) => Ok((state, node)),
                        Err(InternalAstError::NoMatch) => Err(InternalAstError::NoMatch),
                        Err(other) => return Err(other),
                    }
                {
                    state = new_state;
                    parameters.extend(names.into_iter().map(Parameter::Name));
                    if let Ok((new_state, _)) = ParseSymbol(Symbol::Comma).parse(state.clone()) {
                        if let Ok((new_state, ellipse)) =
                            ParseSymbol(Symbol::Ellipse).parse(new_state)
                        {
                            state = new_state;
                            parameters.push(Parameter::Ellipse(ellipse));
                        }
                    }
                } else if let Ok((new_state, ellipse)) =
                    ParseSymbol(Symbol::Ellipse).parse(state.clone())
                {
                    state = new_state;
                    parameters.push(Parameter::Ellipse(ellipse));
                }
                let (state, _) = match ParseSymbol(Symbol::RightParen).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \')\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, FunctionBody { parameters, block }))
            })(self, state)
        }
    }
    struct ParseFunction;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunction {
        #[inline]
        fn clone(&self) -> ParseFunction {
            match *self {
                ParseFunction => ParseFunction,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunction => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunction");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunction {
        #[inline]
        fn eq(&self, other: &ParseFunction) -> bool {
            match *other {
                ParseFunction => match *self {
                    ParseFunction => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunction {
        type Item = FunctionBody<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionBody<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Function).parse(state.clone())?;
                ParseFunctionBody.parse(state.clone())
            })(self, state)
        }
    }
    #[doc = " A parameter in a function declaration"]
    pub enum Parameter<'a> {
        #[serde(borrow)]
        #[doc = " The `...` vararg syntax, such as `function x(...)`"]
        Ellipse(TokenReference<'a>),
        #[doc = " A name parameter, such as `function x(a, b, c)`"]
        Name(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Parameter<'a> {
        #[inline]
        fn clone(&self) -> Parameter<'a> {
            match (&*self,) {
                (&Parameter::Ellipse(ref __self_0),) => {
                    Parameter::Ellipse(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Parameter::Name(ref __self_0),) => {
                    Parameter::Name(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Parameter<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Parameter::Ellipse(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Ellipse");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Parameter::Name(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Name");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Parameter<'a> {
        #[inline]
        fn eq(&self, other: &Parameter<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Parameter::Ellipse(ref __self_0), &Parameter::Ellipse(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Parameter::Name(ref __self_0), &Parameter::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Parameter<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Parameter::Ellipse(ref __self_0), &Parameter::Ellipse(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Parameter::Name(ref __self_0), &Parameter::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Parameter<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Parameter::Ellipse(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Parameter::Name(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Parameter::Ellipse(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Parameter::Name(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Parameter<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_parameter(self);
            match self {
                Parameter::Ellipse(__self_0) => {
                    __self_0.visit(visitor);
                }
                Parameter::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Parameter<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_parameter(self);
            match self {
                Parameter::Ellipse(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Parameter::Name(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Parameter: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Parameter<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Ellipse" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Ellipse" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Parameter<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Parameter<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Parameter")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Parameter::Ellipse,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Parameter::Name,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Ellipse", "Name"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Parameter",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Parameter<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Parameter: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Parameter<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Parameter::Ellipse(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Parameter",
                            0u32,
                            "Ellipse",
                            __field0,
                        )
                    }
                    Parameter::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Parameter",
                        1u32,
                        "Name",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc = " A suffix in certain cases, such as `:y()` in `x:y()`"]
    #[doc = " Can be stacked on top of each other, such as in `x()()()`"]
    pub enum Suffix<'a> {
        #[serde(borrow)]
        #[doc = " A call, including method calls and direct calls"]
        Call(Call<'a>),
        #[doc = " An index, such as `x.y`"]
        Index(Index<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Suffix<'a> {
        #[inline]
        fn clone(&self) -> Suffix<'a> {
            match (&*self,) {
                (&Suffix::Call(ref __self_0),) => {
                    Suffix::Call(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Suffix::Index(ref __self_0),) => {
                    Suffix::Index(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Suffix<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Suffix::Call(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Call");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Suffix::Index(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Index");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Suffix<'a> {
        #[inline]
        fn eq(&self, other: &Suffix<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Suffix::Call(ref __self_0), &Suffix::Call(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Suffix::Index(ref __self_0), &Suffix::Index(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Suffix<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Suffix::Call(ref __self_0), &Suffix::Call(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Suffix::Index(ref __self_0), &Suffix::Index(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Suffix<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Suffix::Call(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Suffix::Index(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Suffix::Call(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    Suffix::Index(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Suffix<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_suffix(self);
            match self {
                Suffix::Call(__self_0) => {
                    __self_0.visit(visitor);
                }
                Suffix::Index(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Suffix<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_suffix(self);
            match self {
                Suffix::Call(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Suffix::Index(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Suffix: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Suffix<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Call" => _serde::export::Ok(__Field::__field0),
                            "Index" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Call" => _serde::export::Ok(__Field::__field0),
                            b"Index" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Suffix<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Suffix<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Suffix")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Call<'a>>(__variant),
                                Suffix::Call,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Index<'a>>(__variant),
                                Suffix::Index,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Call", "Index"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Suffix",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Suffix<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Suffix: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Suffix<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Suffix::Call(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Suffix",
                        0u32,
                        "Call",
                        __field0,
                    ),
                    Suffix::Index(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Suffix",
                        1u32,
                        "Index",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseSuffix;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseSuffix {
        #[inline]
        fn clone(&self) -> ParseSuffix {
            match *self {
                ParseSuffix => ParseSuffix,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseSuffix {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseSuffix => {
                    let mut debug_trait_builder = f.debug_tuple("ParseSuffix");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseSuffix {
        #[inline]
        fn eq(&self, other: &ParseSuffix) -> bool {
            match *other {
                ParseSuffix => match *self {
                    ParseSuffix => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseSuffix {
        type Item = Suffix<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Suffix<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseCall.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Suffix::Call(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseIndex.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Suffix::Index(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " A complex expression used by [`Var`](enum.Var.html), consisting of both a prefix and suffixes"]
    pub struct VarExpression<'a> {
        #[serde(borrow)]
        prefix: Prefix<'a>,
        suffixes: Vec<Suffix<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for VarExpression<'a> {
        #[inline]
        fn clone(&self) -> VarExpression<'a> {
            match *self {
                VarExpression {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => VarExpression {
                    prefix: ::std::clone::Clone::clone(&(*__self_0_0)),
                    suffixes: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for VarExpression<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                VarExpression {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("VarExpression");
                    let _ = debug_trait_builder.field("prefix", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("suffixes", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for VarExpression<'a> {
        #[inline]
        fn eq(&self, other: &VarExpression<'a>) -> bool {
            match *other {
                VarExpression {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    VarExpression {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &VarExpression<'a>) -> bool {
            match *other {
                VarExpression {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    VarExpression {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for VarExpression<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.prefix.start_position()?, self.suffixes.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.prefix.start_position()?, self.suffixes.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for VarExpression<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_var_expression(self);
            self.prefix.visit(visitor);
            self.suffixes.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for VarExpression<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_var_expression(self);
            self.prefix.visit_mut(visitor);
            self.suffixes.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_VarExpression: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for VarExpression<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prefix" => _serde::export::Ok(__Field::__field0),
                            "suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prefix" => _serde::export::Ok(__Field::__field0),
                            b"suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<VarExpression<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = VarExpression<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct VarExpression")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Prefix<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct VarExpression with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Suffix<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct VarExpression with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(VarExpression {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Prefix<'a>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Suffix<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prefix",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Prefix<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "suffixes",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Suffix<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("prefix") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("suffixes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(VarExpression {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["prefix", "suffixes"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "VarExpression",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<VarExpression<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_VarExpression: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for VarExpression<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "VarExpression",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prefix",
                    &self.prefix,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "suffixes",
                    &self.suffixes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> VarExpression<'a> {
        #[doc = " The prefix of the expression, such as a name"]
        pub fn prefix(&self) -> &Prefix<'a> {
            &self.prefix
        }
        #[doc = " An iter over the suffixes, such as indexing or calling"]
        pub fn iter_suffixes(&self) -> impl Iterator<Item = &Suffix<'a>> {
            self.suffixes.iter()
        }
    }
    struct ParseVarExpression;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseVarExpression {
        #[inline]
        fn clone(&self) -> ParseVarExpression {
            match *self {
                ParseVarExpression => ParseVarExpression,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseVarExpression {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseVarExpression => {
                    let mut debug_trait_builder = f.debug_tuple("ParseVarExpression");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseVarExpression {
        #[inline]
        fn eq(&self, other: &ParseVarExpression) -> bool {
            match *other {
                ParseVarExpression => match *self {
                    ParseVarExpression => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseVarExpression {
        type Item = VarExpression<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, VarExpression<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, prefix) = ParsePrefix.parse(state.clone())?;
                let (state, suffixes) = ZeroOrMore(ParseSuffix).parse(state.clone())?;
                if let Some(Suffix::Index(_)) = suffixes.last() {
                    Ok((state, VarExpression { prefix, suffixes }))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " Used in [`Assignment`s](struct.Assignment.html) and [`Value`s](enum.Value.html)"]
    pub enum Var<'a> {
        #[serde(borrow)]
        #[doc = " An expression, such as `x.y.z` or `x()`"]
        Expression(VarExpression<'a>),
        #[doc = " A literal identifier, such as `x`"]
        Name(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Var<'a> {
        #[inline]
        fn clone(&self) -> Var<'a> {
            match (&*self,) {
                (&Var::Expression(ref __self_0),) => {
                    Var::Expression(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&Var::Name(ref __self_0),) => Var::Name(::std::clone::Clone::clone(&(*__self_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Var<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Var::Expression(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Expression");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Var::Name(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Name");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Var<'a> {
        #[inline]
        fn eq(&self, other: &Var<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Var::Expression(ref __self_0), &Var::Expression(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Var::Name(ref __self_0), &Var::Name(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Var<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Var::Expression(ref __self_0), &Var::Expression(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Var::Name(ref __self_0), &Var::Name(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for Var<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Var::Expression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Var::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    Var::Expression(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    Var::Name(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Var<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_var(self);
            match self {
                Var::Expression(__self_0) => {
                    __self_0.visit(visitor);
                }
                Var::Name(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Var<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_var(self);
            match self {
                Var::Expression(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                Var::Name(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Var: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Var<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Expression" => _serde::export::Ok(__Field::__field0),
                            "Name" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Expression" => _serde::export::Ok(__Field::__field0),
                            b"Name" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Var<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Var<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Var")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<VarExpression<'a>>(
                                    __variant,
                                ),
                                Var::Expression,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                Var::Name,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Expression", "Name"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Var",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Var<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Var: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Var<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Var::Expression(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Var",
                        0u32,
                        "Expression",
                        __field0,
                    ),
                    Var::Name(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Var",
                        1u32,
                        "Name",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseVar;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseVar {
        #[inline]
        fn clone(&self) -> ParseVar {
            match *self {
                ParseVar => ParseVar,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseVar {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseVar => {
                    let mut debug_trait_builder = f.debug_tuple("ParseVar");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseVar {
        #[inline]
        fn default() -> ParseVar {
            ParseVar
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseVar {
        #[inline]
        fn eq(&self, other: &ParseVar) -> bool {
            match *other {
                ParseVar => match *self {
                    ParseVar => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseVar {
        type Item = Var<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Var<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                match ParseVarExpression.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Var::Expression(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => return Ok((state, Var::Name(node.into()))),
                    Err(InternalAstError::NoMatch) => {}
                    Err(other) => return Err(other),
                };
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " An assignment, such as `x = y`. Not used for [`LocalAssignment`s](struct.LocalAssignment.html)"]
    pub struct Assignment<'a> {
        #[serde(borrow)]
        var_list: Vec<Var<'a>>,
        expr_list: Vec<Expression<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Assignment<'a> {
        #[inline]
        fn clone(&self) -> Assignment<'a> {
            match *self {
                Assignment {
                    var_list: ref __self_0_0,
                    expr_list: ref __self_0_1,
                } => Assignment {
                    var_list: ::std::clone::Clone::clone(&(*__self_0_0)),
                    expr_list: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Assignment<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Assignment {
                    var_list: ref __self_0_0,
                    expr_list: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Assignment");
                    let _ = debug_trait_builder.field("var_list", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("expr_list", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for Assignment<'a> {
        #[inline]
        fn eq(&self, other: &Assignment<'a>) -> bool {
            match *other {
                Assignment {
                    var_list: ref __self_1_0,
                    expr_list: ref __self_1_1,
                } => match *self {
                    Assignment {
                        var_list: ref __self_0_0,
                        expr_list: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Assignment<'a>) -> bool {
            match *other {
                Assignment {
                    var_list: ref __self_1_0,
                    expr_list: ref __self_1_1,
                } => match *self {
                    Assignment {
                        var_list: ref __self_0_0,
                        expr_list: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for Assignment<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.var_list.start_position()?,
                    self.expr_list.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.var_list.start_position()?,
                    self.expr_list.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for Assignment<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_assignment(self);
            self.var_list.visit(visitor);
            self.expr_list.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for Assignment<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_assignment(self);
            self.var_list.visit_mut(visitor);
            self.expr_list.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Assignment: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Assignment<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "var_list" => _serde::export::Ok(__Field::__field0),
                            "expr_list" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"var_list" => _serde::export::Ok(__Field::__field0),
                            b"expr_list" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Assignment<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Assignment<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Assignment")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Vec<Var<'a>>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Assignment with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Expression<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Assignment with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Assignment {
                            var_list: __field0,
                            expr_list: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<Var<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Expression<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "var_list",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Var<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Expression<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("var_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Assignment {
                            var_list: __field0,
                            expr_list: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["var_list", "expr_list"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Assignment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Assignment<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Assignment: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Assignment<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Assignment",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "var_list",
                    &self.var_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> Assignment<'a> {
        #[doc = " An iterator over the expressions being assigned, the `1, 2` part of `x, y[\"a\"] = 1, 2`"]
        pub fn iter_expr_list(&self) -> impl Iterator<Item = &Expression<'a>> {
            self.expr_list.iter()
        }
        #[doc = " An iterator over the variables being assigned to, the `x, y[\"a\"]` part of `x, y[\"a\"] = 1, 2`"]
        pub fn iter_var_list(&self) -> impl Iterator<Item = &Var<'a>> {
            self.var_list.iter()
        }
    }
    struct ParseAssignment;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseAssignment {
        #[inline]
        fn clone(&self) -> ParseAssignment {
            match *self {
                ParseAssignment => ParseAssignment,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseAssignment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseAssignment => {
                    let mut debug_trait_builder = f.debug_tuple("ParseAssignment");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseAssignment {
        #[inline]
        fn default() -> ParseAssignment {
            ParseAssignment
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseAssignment {
        #[inline]
        fn eq(&self, other: &ParseAssignment) -> bool {
            match *other {
                ParseAssignment => match *self {
                    ParseAssignment => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseAssignment {
        type Item = Assignment<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Assignment<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, var_list) =
                    OneOrMore(ParseVar, ParseSymbol(Symbol::Comma), false).parse(state.clone())?;
                let (state, _) = ParseSymbol(Symbol::Equal).parse(state.clone())?;
                let (state, expr_list) =
                    match OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected values"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                Ok((
                    state,
                    Assignment {
                        var_list,
                        expr_list,
                    },
                ))
            })(self, state)
        }
    }
    #[doc = " A declaration of a local function, such as `local function x() end`"]
    pub struct LocalFunction<'a> {
        #[serde(borrow)]
        name: TokenReference<'a>,
        func_body: FunctionBody<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for LocalFunction<'a> {
        #[inline]
        fn clone(&self) -> LocalFunction<'a> {
            match *self {
                LocalFunction {
                    name: ref __self_0_0,
                    func_body: ref __self_0_1,
                } => LocalFunction {
                    name: ::std::clone::Clone::clone(&(*__self_0_0)),
                    func_body: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for LocalFunction<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                LocalFunction {
                    name: ref __self_0_0,
                    func_body: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("LocalFunction");
                    let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("func_body", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for LocalFunction<'a> {
        #[inline]
        fn eq(&self, other: &LocalFunction<'a>) -> bool {
            match *other {
                LocalFunction {
                    name: ref __self_1_0,
                    func_body: ref __self_1_1,
                } => match *self {
                    LocalFunction {
                        name: ref __self_0_0,
                        func_body: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LocalFunction<'a>) -> bool {
            match *other {
                LocalFunction {
                    name: ref __self_1_0,
                    func_body: ref __self_1_1,
                } => match *self {
                    LocalFunction {
                        name: ref __self_0_0,
                        func_body: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for LocalFunction<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.func_body.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.func_body.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for LocalFunction<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_local_function(self);
            self.name.visit(visitor);
            self.func_body.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for LocalFunction<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_local_function(self);
            self.name.visit_mut(visitor);
            self.func_body.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_LocalFunction: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for LocalFunction<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::export::Ok(__Field::__field0),
                            "func_body" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::export::Ok(__Field::__field0),
                            b"func_body" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<LocalFunction<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = LocalFunction<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct LocalFunction")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenReference<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LocalFunction with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            FunctionBody<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LocalFunction with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(LocalFunction {
                            name: __field0,
                            func_body: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenReference<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<FunctionBody<'a>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenReference<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "func_body",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionBody<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("func_body") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(LocalFunction {
                            name: __field0,
                            func_body: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "func_body"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LocalFunction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LocalFunction<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_LocalFunction: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for LocalFunction<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "LocalFunction",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "func_body",
                    &self.func_body,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> LocalFunction<'a> {
        #[doc = " The function body, everything except `local function x` in `local function x(a, b, c) call() end`"]
        pub fn func_body(&self) -> &FunctionBody<'a> {
            &self.func_body
        }
        #[doc = " The name of the function, the `x` part of `local function x() end`"]
        pub fn name(&self) -> &Token<'a> {
            &self.name
        }
    }
    struct ParseLocalFunction;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseLocalFunction {
        #[inline]
        fn clone(&self) -> ParseLocalFunction {
            match *self {
                ParseLocalFunction => ParseLocalFunction,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseLocalFunction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseLocalFunction => {
                    let mut debug_trait_builder = f.debug_tuple("ParseLocalFunction");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseLocalFunction {
        #[inline]
        fn default() -> ParseLocalFunction {
            ParseLocalFunction
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseLocalFunction {
        #[inline]
        fn eq(&self, other: &ParseLocalFunction) -> bool {
            match *other {
                ParseLocalFunction => match *self {
                    ParseLocalFunction => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseLocalFunction {
        type Item = LocalFunction<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, LocalFunction<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Local).parse(state.clone())?;
                let (state, _) = ParseSymbol(Symbol::Function).parse(state.clone())?;
                let (state, name) = match ParseIdentifier.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected name"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, func_body) = ParseFunctionBody.parse(state.clone())?;
                Ok((state, LocalFunction { name, func_body }))
            })(self, state)
        }
    }
    #[doc = " An assignment to a local variable, such as `local x = 1`"]
    pub struct LocalAssignment<'a> {
        #[serde(borrow)]
        name_list: Vec<TokenReference<'a>>,
        expr_list: Vec<Expression<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for LocalAssignment<'a> {
        #[inline]
        fn clone(&self) -> LocalAssignment<'a> {
            match *self {
                LocalAssignment {
                    name_list: ref __self_0_0,
                    expr_list: ref __self_0_1,
                } => LocalAssignment {
                    name_list: ::std::clone::Clone::clone(&(*__self_0_0)),
                    expr_list: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for LocalAssignment<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                LocalAssignment {
                    name_list: ref __self_0_0,
                    expr_list: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("LocalAssignment");
                    let _ = debug_trait_builder.field("name_list", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("expr_list", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for LocalAssignment<'a> {
        #[inline]
        fn eq(&self, other: &LocalAssignment<'a>) -> bool {
            match *other {
                LocalAssignment {
                    name_list: ref __self_1_0,
                    expr_list: ref __self_1_1,
                } => match *self {
                    LocalAssignment {
                        name_list: ref __self_0_0,
                        expr_list: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LocalAssignment<'a>) -> bool {
            match *other {
                LocalAssignment {
                    name_list: ref __self_1_0,
                    expr_list: ref __self_1_1,
                } => match *self {
                    LocalAssignment {
                        name_list: ref __self_0_0,
                        expr_list: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for LocalAssignment<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.name_list.start_position()?,
                    self.expr_list.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.name_list.start_position()?,
                    self.expr_list.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for LocalAssignment<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_local_assignment(self);
            self.name_list.visit(visitor);
            self.expr_list.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for LocalAssignment<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_local_assignment(self);
            self.name_list.visit_mut(visitor);
            self.expr_list.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_LocalAssignment: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for LocalAssignment<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name_list" => _serde::export::Ok(__Field::__field0),
                            "expr_list" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name_list" => _serde::export::Ok(__Field::__field0),
                            b"expr_list" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<LocalAssignment<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = LocalAssignment<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct LocalAssignment")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<TokenReference<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct LocalAssignment with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Expression<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct LocalAssignment with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(LocalAssignment {
                            name_list: __field0,
                            expr_list: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<TokenReference<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Expression<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name_list",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<TokenReference<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "expr_list",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Expression<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("expr_list") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(LocalAssignment {
                            name_list: __field0,
                            expr_list: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name_list", "expr_list"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "LocalAssignment",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<LocalAssignment<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_LocalAssignment: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for LocalAssignment<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "LocalAssignment",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name_list",
                    &self.name_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "expr_list",
                    &self.expr_list,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> LocalAssignment<'a> {
        #[doc = " An iterator over the expressions being assigned, the `1, 2` part of `local x, y = 1, 2`"]
        pub fn iter_expr_list(&self) -> impl Iterator<Item = &Expression<'a>> {
            self.expr_list.iter()
        }
        #[doc = " An iterator over the names being assigned to, the `x, y` part of `local x, y = 1, 2`"]
        pub fn iter_name_list(&self) -> impl Iterator<Item = &TokenReference<'a>> {
            self.name_list.iter()
        }
        #[doc = " A mutable iterator over the names being assigned to, the `x, y` part of `local x, y = 1, 2`"]
        pub fn iter_name_list_mut(&mut self) -> impl Iterator<Item = &mut TokenReference<'a>> {
            self.name_list.iter_mut()
        }
    }
    struct ParseLocalAssignment;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseLocalAssignment {
        #[inline]
        fn clone(&self) -> ParseLocalAssignment {
            match *self {
                ParseLocalAssignment => ParseLocalAssignment,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseLocalAssignment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseLocalAssignment => {
                    let mut debug_trait_builder = f.debug_tuple("ParseLocalAssignment");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseLocalAssignment {
        #[inline]
        fn default() -> ParseLocalAssignment {
            ParseLocalAssignment
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseLocalAssignment {
        #[inline]
        fn eq(&self, other: &ParseLocalAssignment) -> bool {
            match *other {
                ParseLocalAssignment => match *self {
                    ParseLocalAssignment => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseLocalAssignment {
        type Item = LocalAssignment<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, LocalAssignment<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Local).parse(state.clone())?;
                let (state, name_list) =
                    match OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                    {
                        Ok((state, node)) => (state, node),
                        Err(InternalAstError::NoMatch) => {
                            return Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected name"),
                            });
                        }
                        Err(other) => return Err(other),
                    };
                let (state, expr_list) = match ParseSymbol(Symbol::Equal).parse(state.clone()) {
                    Ok((state, _)) => OneOrMore(ParseExpression, ParseSymbol(Symbol::Comma), false)
                        .parse(state.clone())
                        .or_else(|_| {
                            Err(InternalAstError::UnexpectedToken {
                                token: state.peek(),
                                additional: Some("expected expression"),
                            })
                        })?,
                    Err(InternalAstError::NoMatch) => (state, Vec::new()),
                    Err(other) => return Err(other),
                };
                Ok((
                    state,
                    LocalAssignment {
                        name_list,
                        expr_list,
                    },
                ))
            })(self, state)
        }
    }
    struct ParseDo;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseDo {
        #[inline]
        fn clone(&self) -> ParseDo {
            match *self {
                ParseDo => ParseDo,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseDo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseDo => {
                    let mut debug_trait_builder = f.debug_tuple("ParseDo");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseDo {
        #[inline]
        fn eq(&self, other: &ParseDo) -> bool {
            match *other {
                ParseDo => match *self {
                    ParseDo => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseDo {
        type Item = Block<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, Block<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Do).parse(state.clone())?;
                let (state, block) = match ParseBlock.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected block"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, _) = match ParseSymbol(Symbol::End).parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected \'end\'"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, block))
            })(self, state)
        }
    }
    #[doc = " A function being called, such as `call()`"]
    pub struct FunctionCall<'a> {
        #[serde(borrow)]
        prefix: Prefix<'a>,
        suffixes: Vec<Suffix<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for FunctionCall<'a> {
        #[inline]
        fn clone(&self) -> FunctionCall<'a> {
            match *self {
                FunctionCall {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => FunctionCall {
                    prefix: ::std::clone::Clone::clone(&(*__self_0_0)),
                    suffixes: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for FunctionCall<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FunctionCall {
                    prefix: ref __self_0_0,
                    suffixes: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("FunctionCall");
                    let _ = debug_trait_builder.field("prefix", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("suffixes", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for FunctionCall<'a> {
        #[inline]
        fn eq(&self, other: &FunctionCall<'a>) -> bool {
            match *other {
                FunctionCall {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    FunctionCall {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionCall<'a>) -> bool {
            match *other {
                FunctionCall {
                    prefix: ref __self_1_0,
                    suffixes: ref __self_1_1,
                } => match *self {
                    FunctionCall {
                        prefix: ref __self_0_0,
                        suffixes: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for FunctionCall<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.prefix.start_position()?, self.suffixes.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.prefix.start_position()?, self.suffixes.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for FunctionCall<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_function_call(self);
            self.prefix.visit(visitor);
            self.suffixes.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for FunctionCall<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_function_call(self);
            self.prefix.visit_mut(visitor);
            self.suffixes.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_FunctionCall: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for FunctionCall<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "prefix" => _serde::export::Ok(__Field::__field0),
                            "suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"prefix" => _serde::export::Ok(__Field::__field0),
                            b"suffixes" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<FunctionCall<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = FunctionCall<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionCall")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Prefix<'a>>(
                            &mut __seq,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionCall with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Suffix<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionCall with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionCall {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Prefix<'a>> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<Suffix<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "prefix",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Prefix<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "suffixes",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Suffix<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("prefix") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("suffixes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionCall {
                            prefix: __field0,
                            suffixes: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["prefix", "suffixes"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionCall",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionCall<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_FunctionCall: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for FunctionCall<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionCall",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "prefix",
                    &self.prefix,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "suffixes",
                    &self.suffixes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> FunctionCall<'a> {
        #[doc = " The prefix of a function call, the `call` part of `call()`"]
        pub fn prefix(&self) -> &Prefix<'a> {
            &self.prefix
        }
        #[doc = " The suffix of a function call, the `()` part of `call()`"]
        pub fn iter_suffixes(&self) -> impl Iterator<Item = &Suffix<'a>> {
            self.suffixes.iter()
        }
    }
    struct ParseFunctionCall;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunctionCall {
        #[inline]
        fn clone(&self) -> ParseFunctionCall {
            match *self {
                ParseFunctionCall => ParseFunctionCall,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunctionCall {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunctionCall => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunctionCall");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunctionCall {
        #[inline]
        fn eq(&self, other: &ParseFunctionCall) -> bool {
            match *other {
                ParseFunctionCall => match *self {
                    ParseFunctionCall => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunctionCall {
        type Item = FunctionCall<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionCall<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, prefix) = ParsePrefix.parse(state.clone())?;
                let (state, suffixes) = ZeroOrMore(ParseSuffix).parse(state.clone())?;
                if let Some(Suffix::Call(_)) = suffixes.last() {
                    Ok((state, FunctionCall { prefix, suffixes }))
                } else {
                    Err(InternalAstError::NoMatch)
                }
            })(self, state)
        }
    }
    #[doc = " A function name when being [declared](struct.FunctionDeclaration.html)"]
    pub struct FunctionName<'a> {
        #[serde(borrow)]
        names: Vec<TokenReference<'a>>,
        colon_name: Option<TokenReference<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for FunctionName<'a> {
        #[inline]
        fn clone(&self) -> FunctionName<'a> {
            match *self {
                FunctionName {
                    names: ref __self_0_0,
                    colon_name: ref __self_0_1,
                } => FunctionName {
                    names: ::std::clone::Clone::clone(&(*__self_0_0)),
                    colon_name: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for FunctionName<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FunctionName {
                    names: ref __self_0_0,
                    colon_name: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("FunctionName");
                    let _ = debug_trait_builder.field("names", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("colon_name", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for FunctionName<'a> {
        #[inline]
        fn eq(&self, other: &FunctionName<'a>) -> bool {
            match *other {
                FunctionName {
                    names: ref __self_1_0,
                    colon_name: ref __self_1_1,
                } => match *self {
                    FunctionName {
                        names: ref __self_0_0,
                        colon_name: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionName<'a>) -> bool {
            match *other {
                FunctionName {
                    names: ref __self_1_0,
                    colon_name: ref __self_1_1,
                } => match *self {
                    FunctionName {
                        names: ref __self_0_0,
                        colon_name: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for FunctionName<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.names.start_position()?,
                    self.colon_name.end_position()?,
                ))?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                Some((
                    self.names.start_position()?,
                    self.colon_name.end_position()?,
                ))?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for FunctionName<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_function_name(self);
            self.names.visit(visitor);
            self.colon_name.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for FunctionName<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_function_name(self);
            self.names.visit_mut(visitor);
            self.colon_name.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_FunctionName: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for FunctionName<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "names" => _serde::export::Ok(__Field::__field0),
                            "colon_name" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"names" => _serde::export::Ok(__Field::__field0),
                            b"colon_name" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<FunctionName<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = FunctionName<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct FunctionName")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<TokenReference<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionName with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<TokenReference<'a>>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionName with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionName {
                            names: __field0,
                            colon_name: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Vec<TokenReference<'a>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Option<TokenReference<'a>>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "names",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<TokenReference<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "colon_name",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<TokenReference<'a>>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("names") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("colon_name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionName {
                            names: __field0,
                            colon_name: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["names", "colon_name"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionName",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionName<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_FunctionName: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for FunctionName<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionName",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "names",
                    &self.names,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "colon_name",
                    &self.colon_name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> FunctionName<'a> {
        #[doc = " A method name if one exists, the `y` part of `function x:y() end`"]
        pub fn method_name(&self) -> Option<&TokenReference<'a>> {
            self.colon_name.as_ref()
        }
        #[doc = " An iterator over the names used when defining the function, the `x.y.z` part of `function x.y.z() end`"]
        pub fn iter_names(&self) -> impl Iterator<Item = &TokenReference<'a>> {
            self.names.iter()
        }
    }
    struct ParseFunctionName;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunctionName {
        #[inline]
        fn clone(&self) -> ParseFunctionName {
            match *self {
                ParseFunctionName => ParseFunctionName,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunctionName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunctionName => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunctionName");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunctionName {
        #[inline]
        fn eq(&self, other: &ParseFunctionName) -> bool {
            match *other {
                ParseFunctionName => match *self {
                    ParseFunctionName => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunctionName {
        type Item = FunctionName<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionName<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, names) = OneOrMore(ParseIdentifier, ParseSymbol(Symbol::Dot), false)
                    .parse(state.clone())?;
                let (state, colon_name) =
                    if let Ok((state, _)) = ParseSymbol(Symbol::Colon).parse(state.clone()) {
                        let (state, colon_name) = match ParseIdentifier.parse(state.clone()) {
                            Ok((state, node)) => (state, node),
                            Err(InternalAstError::NoMatch) => {
                                return Err(InternalAstError::UnexpectedToken {
                                    token: state.peek(),
                                    additional: Some("expected method name"),
                                });
                            }
                            Err(other) => return Err(other),
                        };
                        (state, Some(colon_name))
                    } else {
                        (state, None)
                    };
                Ok((state, FunctionName { names, colon_name }))
            })(self, state)
        }
    }
    #[doc = " A normal function declaration, supports simple declarations like `function x() end`"]
    #[doc = " as well as complicated declarations such as `function x.y.z:a() end`"]
    pub struct FunctionDeclaration<'a> {
        #[serde(borrow)]
        name: FunctionName<'a>,
        body: FunctionBody<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for FunctionDeclaration<'a> {
        #[inline]
        fn clone(&self) -> FunctionDeclaration<'a> {
            match *self {
                FunctionDeclaration {
                    name: ref __self_0_0,
                    body: ref __self_0_1,
                } => FunctionDeclaration {
                    name: ::std::clone::Clone::clone(&(*__self_0_0)),
                    body: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for FunctionDeclaration<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FunctionDeclaration {
                    name: ref __self_0_0,
                    body: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("FunctionDeclaration");
                    let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("body", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for FunctionDeclaration<'a> {
        #[inline]
        fn eq(&self, other: &FunctionDeclaration<'a>) -> bool {
            match *other {
                FunctionDeclaration {
                    name: ref __self_1_0,
                    body: ref __self_1_1,
                } => match *self {
                    FunctionDeclaration {
                        name: ref __self_0_0,
                        body: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FunctionDeclaration<'a>) -> bool {
            match *other {
                FunctionDeclaration {
                    name: ref __self_1_0,
                    body: ref __self_1_1,
                } => match *self {
                    FunctionDeclaration {
                        name: ref __self_0_0,
                        body: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl<'a> crate::node::Node for FunctionDeclaration<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.body.end_position()?))?.0)
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(Some((self.name.start_position()?, self.body.end_position()?))?.1)
        }
    }
    impl<'a> crate::visitors::Visit<'a> for FunctionDeclaration<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            visitor.visit_function_declaration(self);
            self.name.visit(visitor);
            self.body.visit(visitor);
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for FunctionDeclaration<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            visitor.visit_function_declaration(self);
            self.name.visit_mut(visitor);
            self.body.visit_mut(visitor);
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_FunctionDeclaration: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for FunctionDeclaration<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::export::Ok(__Field::__field0),
                            "body" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::export::Ok(__Field::__field0),
                            b"body" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<FunctionDeclaration<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = FunctionDeclaration<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "struct FunctionDeclaration",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            FunctionName<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct FunctionDeclaration with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            FunctionBody<'a>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct FunctionDeclaration with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(FunctionDeclaration {
                            name: __field0,
                            body: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<FunctionName<'a>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<FunctionBody<'a>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionName<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "body",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<FunctionBody<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("body") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(FunctionDeclaration {
                            name: __field0,
                            body: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "body"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "FunctionDeclaration",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<FunctionDeclaration<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_FunctionDeclaration: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for FunctionDeclaration<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "FunctionDeclaration",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "body",
                    &self.body,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> FunctionDeclaration<'a> {
        #[doc = " The body of the function"]
        pub fn body(&self) -> &FunctionBody<'a> {
            &self.body
        }
        #[doc = " The name of the function"]
        pub fn name(&self) -> &FunctionName<'a> {
            &self.name
        }
    }
    struct ParseFunctionDeclaration;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseFunctionDeclaration {
        #[inline]
        fn clone(&self) -> ParseFunctionDeclaration {
            match *self {
                ParseFunctionDeclaration => ParseFunctionDeclaration,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseFunctionDeclaration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseFunctionDeclaration => {
                    let mut debug_trait_builder = f.debug_tuple("ParseFunctionDeclaration");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseFunctionDeclaration {
        #[inline]
        fn default() -> ParseFunctionDeclaration {
            ParseFunctionDeclaration
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseFunctionDeclaration {
        #[inline]
        fn eq(&self, other: &ParseFunctionDeclaration) -> bool {
            match *other {
                ParseFunctionDeclaration => match *self {
                    ParseFunctionDeclaration => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseFunctionDeclaration {
        type Item = FunctionDeclaration<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, FunctionDeclaration<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let (state, _) = ParseSymbol(Symbol::Function).parse(state.clone())?;
                let (state, name) = match ParseFunctionName.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected function name"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                let (state, body) = match ParseFunctionBody.parse(state.clone()) {
                    Ok((state, node)) => (state, node),
                    Err(InternalAstError::NoMatch) => {
                        return Err(InternalAstError::UnexpectedToken {
                            token: state.peek(),
                            additional: Some("expected function body"),
                        });
                    }
                    Err(other) => return Err(other),
                };
                Ok((state, FunctionDeclaration { name, body }))
            })(self, state)
        }
    }
    struct ParseIdentifier;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseIdentifier {
        #[inline]
        fn clone(&self) -> ParseIdentifier {
            match *self {
                ParseIdentifier => ParseIdentifier,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseIdentifier {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseIdentifier => {
                    let mut debug_trait_builder = f.debug_tuple("ParseIdentifier");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for ParseIdentifier {
        #[inline]
        fn default() -> ParseIdentifier {
            ParseIdentifier
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseIdentifier {
        #[inline]
        fn eq(&self, other: &ParseIdentifier) -> bool {
            match *other {
                ParseIdentifier => match *self {
                    ParseIdentifier => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseIdentifier {
        type Item = TokenReference<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, TokenReference<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                let next_token = state.peek();
                match next_token.token_kind() {
                    TokenKind::Identifier => Ok((
                        state.advance().ok_or(InternalAstError::NoMatch)?,
                        next_token,
                    )),
                    _ => Err(InternalAstError::NoMatch),
                }
            })(self, state)
        }
    }
    #[doc = "Operators that require two operands, such as X + Y or X - Y"]
    #[visit(skip_visit_self)]
    pub enum BinOp<'a> {
        #[serde(borrow)]
        #[allow(missing_docs)]
        And(TokenReference<'a>),
        #[allow(missing_docs)]
        Caret(TokenReference<'a>),
        #[allow(missing_docs)]
        GreaterThan(TokenReference<'a>),
        #[allow(missing_docs)]
        GreaterThanEqual(TokenReference<'a>),
        #[allow(missing_docs)]
        LessThan(TokenReference<'a>),
        #[allow(missing_docs)]
        LessThanEqual(TokenReference<'a>),
        #[allow(missing_docs)]
        Minus(TokenReference<'a>),
        #[allow(missing_docs)]
        Or(TokenReference<'a>),
        #[allow(missing_docs)]
        Percent(TokenReference<'a>),
        #[allow(missing_docs)]
        Plus(TokenReference<'a>),
        #[allow(missing_docs)]
        Slash(TokenReference<'a>),
        #[allow(missing_docs)]
        Star(TokenReference<'a>),
        #[allow(missing_docs)]
        TildeEqual(TokenReference<'a>),
        #[allow(missing_docs)]
        TwoDots(TokenReference<'a>),
        #[allow(missing_docs)]
        TwoEqual(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for BinOp<'a> {
        #[inline]
        fn clone(&self) -> BinOp<'a> {
            match (&*self,) {
                (&BinOp::And(ref __self_0),) => {
                    BinOp::And(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Caret(ref __self_0),) => {
                    BinOp::Caret(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::GreaterThan(ref __self_0),) => {
                    BinOp::GreaterThan(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::GreaterThanEqual(ref __self_0),) => {
                    BinOp::GreaterThanEqual(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::LessThan(ref __self_0),) => {
                    BinOp::LessThan(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::LessThanEqual(ref __self_0),) => {
                    BinOp::LessThanEqual(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Minus(ref __self_0),) => {
                    BinOp::Minus(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Or(ref __self_0),) => BinOp::Or(::std::clone::Clone::clone(&(*__self_0))),
                (&BinOp::Percent(ref __self_0),) => {
                    BinOp::Percent(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Plus(ref __self_0),) => {
                    BinOp::Plus(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Slash(ref __self_0),) => {
                    BinOp::Slash(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::Star(ref __self_0),) => {
                    BinOp::Star(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TildeEqual(ref __self_0),) => {
                    BinOp::TildeEqual(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TwoDots(ref __self_0),) => {
                    BinOp::TwoDots(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&BinOp::TwoEqual(ref __self_0),) => {
                    BinOp::TwoEqual(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for BinOp<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&BinOp::And(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("And");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Caret(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Caret");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::GreaterThan(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterThan");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::GreaterThanEqual(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterThanEqual");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::LessThan(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("LessThan");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::LessThanEqual(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("LessThanEqual");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Minus(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Or(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Or");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Percent(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Percent");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Plus(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Plus");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Slash(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Slash");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::Star(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Star");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::TildeEqual(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TildeEqual");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::TwoDots(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TwoDots");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&BinOp::TwoEqual(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("TwoEqual");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for BinOp<'a> {
        #[inline]
        fn eq(&self, other: &BinOp<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&BinOp::And(ref __self_0), &BinOp::And(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Caret(ref __self_0), &BinOp::Caret(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::GreaterThan(ref __self_0), &BinOp::GreaterThan(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &BinOp::GreaterThanEqual(ref __self_0),
                            &BinOp::GreaterThanEqual(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&BinOp::LessThan(ref __self_0), &BinOp::LessThan(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &BinOp::LessThanEqual(ref __self_0),
                            &BinOp::LessThanEqual(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&BinOp::Minus(ref __self_0), &BinOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Or(ref __self_0), &BinOp::Or(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Percent(ref __self_0), &BinOp::Percent(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Plus(ref __self_0), &BinOp::Plus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Slash(ref __self_0), &BinOp::Slash(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::Star(ref __self_0), &BinOp::Star(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TildeEqual(ref __self_0), &BinOp::TildeEqual(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TwoDots(ref __self_0), &BinOp::TwoDots(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&BinOp::TwoEqual(ref __self_0), &BinOp::TwoEqual(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &BinOp<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&BinOp::And(ref __self_0), &BinOp::And(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Caret(ref __self_0), &BinOp::Caret(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::GreaterThan(ref __self_0), &BinOp::GreaterThan(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &BinOp::GreaterThanEqual(ref __self_0),
                            &BinOp::GreaterThanEqual(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&BinOp::LessThan(ref __self_0), &BinOp::LessThan(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &BinOp::LessThanEqual(ref __self_0),
                            &BinOp::LessThanEqual(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&BinOp::Minus(ref __self_0), &BinOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Or(ref __self_0), &BinOp::Or(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Percent(ref __self_0), &BinOp::Percent(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Plus(ref __self_0), &BinOp::Plus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Slash(ref __self_0), &BinOp::Slash(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::Star(ref __self_0), &BinOp::Star(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TildeEqual(ref __self_0), &BinOp::TildeEqual(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TwoDots(ref __self_0), &BinOp::TwoDots(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&BinOp::TwoEqual(ref __self_0), &BinOp::TwoEqual(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for BinOp<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    BinOp::And(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Caret(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::GreaterThan(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::GreaterThanEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::LessThan(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::LessThanEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::Minus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Or(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Percent(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Plus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Slash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Star(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::TildeEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::TwoDots(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::TwoEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    BinOp::And(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Caret(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::GreaterThan(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::GreaterThanEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::LessThan(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::LessThanEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::Minus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Or(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Percent(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Plus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Slash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::Star(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::TildeEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                    BinOp::TwoDots(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    BinOp::TwoEqual(inner) => {
                        Some((inner.start_position()?, inner.end_position()?))
                    }
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for BinOp<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            match self {
                BinOp::And(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Caret(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::GreaterThan(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::GreaterThanEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::LessThan(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::LessThanEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Minus(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Or(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Percent(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Plus(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Slash(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::Star(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TildeEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TwoDots(__self_0) => {
                    __self_0.visit(visitor);
                }
                BinOp::TwoEqual(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for BinOp<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            match self {
                BinOp::And(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Caret(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::GreaterThan(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::GreaterThanEqual(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::LessThan(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::LessThanEqual(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Minus(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Or(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Percent(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Plus(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Slash(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::Star(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::TildeEqual(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::TwoDots(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                BinOp::TwoEqual(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_BinOp: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for BinOp<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            12u64 => _serde::export::Ok(__Field::__field12),
                            13u64 => _serde::export::Ok(__Field::__field13),
                            14u64 => _serde::export::Ok(__Field::__field14),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 15",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "And" => _serde::export::Ok(__Field::__field0),
                            "Caret" => _serde::export::Ok(__Field::__field1),
                            "GreaterThan" => _serde::export::Ok(__Field::__field2),
                            "GreaterThanEqual" => _serde::export::Ok(__Field::__field3),
                            "LessThan" => _serde::export::Ok(__Field::__field4),
                            "LessThanEqual" => _serde::export::Ok(__Field::__field5),
                            "Minus" => _serde::export::Ok(__Field::__field6),
                            "Or" => _serde::export::Ok(__Field::__field7),
                            "Percent" => _serde::export::Ok(__Field::__field8),
                            "Plus" => _serde::export::Ok(__Field::__field9),
                            "Slash" => _serde::export::Ok(__Field::__field10),
                            "Star" => _serde::export::Ok(__Field::__field11),
                            "TildeEqual" => _serde::export::Ok(__Field::__field12),
                            "TwoDots" => _serde::export::Ok(__Field::__field13),
                            "TwoEqual" => _serde::export::Ok(__Field::__field14),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"And" => _serde::export::Ok(__Field::__field0),
                            b"Caret" => _serde::export::Ok(__Field::__field1),
                            b"GreaterThan" => _serde::export::Ok(__Field::__field2),
                            b"GreaterThanEqual" => _serde::export::Ok(__Field::__field3),
                            b"LessThan" => _serde::export::Ok(__Field::__field4),
                            b"LessThanEqual" => _serde::export::Ok(__Field::__field5),
                            b"Minus" => _serde::export::Ok(__Field::__field6),
                            b"Or" => _serde::export::Ok(__Field::__field7),
                            b"Percent" => _serde::export::Ok(__Field::__field8),
                            b"Plus" => _serde::export::Ok(__Field::__field9),
                            b"Slash" => _serde::export::Ok(__Field::__field10),
                            b"Star" => _serde::export::Ok(__Field::__field11),
                            b"TildeEqual" => _serde::export::Ok(__Field::__field12),
                            b"TwoDots" => _serde::export::Ok(__Field::__field13),
                            b"TwoEqual" => _serde::export::Ok(__Field::__field14),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<BinOp<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = BinOp<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum BinOp")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::And,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Caret,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::GreaterThan,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::GreaterThanEqual,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::LessThan,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::LessThanEqual,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Minus,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Or,
                            ),
                            (__Field::__field8, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Percent,
                            ),
                            (__Field::__field9, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Plus,
                            ),
                            (__Field::__field10, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Slash,
                            ),
                            (__Field::__field11, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::Star,
                            ),
                            (__Field::__field12, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::TildeEqual,
                            ),
                            (__Field::__field13, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::TwoDots,
                            ),
                            (__Field::__field14, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                BinOp::TwoEqual,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "And",
                    "Caret",
                    "GreaterThan",
                    "GreaterThanEqual",
                    "LessThan",
                    "LessThanEqual",
                    "Minus",
                    "Or",
                    "Percent",
                    "Plus",
                    "Slash",
                    "Star",
                    "TildeEqual",
                    "TwoDots",
                    "TwoEqual",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "BinOp",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<BinOp<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_BinOp: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for BinOp<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    BinOp::And(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        0u32,
                        "And",
                        __field0,
                    ),
                    BinOp::Caret(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        1u32,
                        "Caret",
                        __field0,
                    ),
                    BinOp::GreaterThan(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            2u32,
                            "GreaterThan",
                            __field0,
                        )
                    }
                    BinOp::GreaterThanEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            3u32,
                            "GreaterThanEqual",
                            __field0,
                        )
                    }
                    BinOp::LessThan(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        4u32,
                        "LessThan",
                        __field0,
                    ),
                    BinOp::LessThanEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            5u32,
                            "LessThanEqual",
                            __field0,
                        )
                    }
                    BinOp::Minus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        6u32,
                        "Minus",
                        __field0,
                    ),
                    BinOp::Or(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        7u32,
                        "Or",
                        __field0,
                    ),
                    BinOp::Percent(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        8u32,
                        "Percent",
                        __field0,
                    ),
                    BinOp::Plus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        9u32,
                        "Plus",
                        __field0,
                    ),
                    BinOp::Slash(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        10u32,
                        "Slash",
                        __field0,
                    ),
                    BinOp::Star(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        11u32,
                        "Star",
                        __field0,
                    ),
                    BinOp::TildeEqual(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "BinOp",
                            12u32,
                            "TildeEqual",
                            __field0,
                        )
                    }
                    BinOp::TwoDots(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        13u32,
                        "TwoDots",
                        __field0,
                    ),
                    BinOp::TwoEqual(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "BinOp",
                        14u32,
                        "TwoEqual",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseBinOp;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseBinOp {
        #[inline]
        fn clone(&self) -> ParseBinOp {
            match *self {
                ParseBinOp => ParseBinOp,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseBinOp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseBinOp => {
                    let mut debug_trait_builder = f.debug_tuple("ParseBinOp");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseBinOp {
        #[inline]
        fn eq(&self, other: &ParseBinOp) -> bool {
            match *other {
                ParseBinOp => match *self {
                    ParseBinOp => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseBinOp {
        type Item = BinOp<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, BinOp<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = ParseSymbol(Symbol::And).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::And(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Caret).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Caret(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::GreaterThan).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::GreaterThan(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::GreaterThanEqual).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::GreaterThanEqual(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::LessThan).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::LessThan(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::LessThanEqual).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::LessThanEqual(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Minus).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Minus(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Or).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Or(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Percent).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Percent(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Plus).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Plus(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Slash).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Slash(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Star).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::Star(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::TildeEqual).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::TildeEqual(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::TwoDots).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::TwoDots(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::TwoEqual).parse(state.clone()) {
                    return Ok((state.clone(), BinOp::TwoEqual(state.peek())));
                }
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = "Operators that require just one operand, such as #X"]
    #[visit(skip_visit_self)]
    pub enum UnOp<'a> {
        #[serde(borrow)]
        #[allow(missing_docs)]
        Minus(TokenReference<'a>),
        #[allow(missing_docs)]
        Not(TokenReference<'a>),
        #[allow(missing_docs)]
        Hash(TokenReference<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for UnOp<'a> {
        #[inline]
        fn clone(&self) -> UnOp<'a> {
            match (&*self,) {
                (&UnOp::Minus(ref __self_0),) => {
                    UnOp::Minus(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&UnOp::Not(ref __self_0),) => UnOp::Not(::std::clone::Clone::clone(&(*__self_0))),
                (&UnOp::Hash(ref __self_0),) => {
                    UnOp::Hash(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for UnOp<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&UnOp::Minus(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnOp::Not(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Not");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&UnOp::Hash(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Hash");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for UnOp<'a> {
        #[inline]
        fn eq(&self, other: &UnOp<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&UnOp::Minus(ref __self_0), &UnOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&UnOp::Not(ref __self_0), &UnOp::Not(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&UnOp::Hash(ref __self_0), &UnOp::Hash(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &UnOp<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&UnOp::Minus(ref __self_0), &UnOp::Minus(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&UnOp::Not(ref __self_0), &UnOp::Not(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&UnOp::Hash(ref __self_0), &UnOp::Hash(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl<'a> crate::node::Node for UnOp<'a> {
        fn start_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    UnOp::Minus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    UnOp::Not(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    UnOp::Hash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .0,
            )
        }
        fn end_position(&self) -> Option<crate::tokenizer::Position> {
            Some(
                #[allow(unused_variables)]
                match self {
                    UnOp::Minus(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    UnOp::Not(inner) => Some((inner.start_position()?, inner.end_position()?)),
                    UnOp::Hash(inner) => Some((inner.start_position()?, inner.end_position()?)),
                }?
                .1,
            )
        }
    }
    impl<'a> crate::visitors::Visit<'a> for UnOp<'a> {
        fn visit<V: crate::visitors::Visitor<'a>>(&self, visitor: &mut V) {
            match self {
                UnOp::Minus(__self_0) => {
                    __self_0.visit(visitor);
                }
                UnOp::Not(__self_0) => {
                    __self_0.visit(visitor);
                }
                UnOp::Hash(__self_0) => {
                    __self_0.visit(visitor);
                }
                _ => {}
            }
        }
    }
    impl<'a> crate::visitors::VisitMut<'a> for UnOp<'a> {
        fn visit_mut<V: crate::visitors::VisitorMut<'a>>(&mut self, visitor: &mut V) {
            match self {
                UnOp::Minus(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                UnOp::Not(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                UnOp::Hash(__self_0) => {
                    __self_0.visit_mut(visitor);
                }
                _ => {}
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_UnOp: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for UnOp<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Minus" => _serde::export::Ok(__Field::__field0),
                            "Not" => _serde::export::Ok(__Field::__field1),
                            "Hash" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Minus" => _serde::export::Ok(__Field::__field0),
                            b"Not" => _serde::export::Ok(__Field::__field1),
                            b"Hash" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<UnOp<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = UnOp<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum UnOp")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                UnOp::Minus,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                UnOp::Not,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<TokenReference<'a>>(
                                    __variant,
                                ),
                                UnOp::Hash,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Minus", "Not", "Hash"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UnOp",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnOp<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_UnOp: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for UnOp<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UnOp::Minus(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        0u32,
                        "Minus",
                        __field0,
                    ),
                    UnOp::Not(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        1u32,
                        "Not",
                        __field0,
                    ),
                    UnOp::Hash(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "UnOp",
                        2u32,
                        "Hash",
                        __field0,
                    ),
                }
            }
        }
    };
    struct ParseUnOp;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseUnOp {
        #[inline]
        fn clone(&self) -> ParseUnOp {
            match *self {
                ParseUnOp => ParseUnOp,
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseUnOp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseUnOp => {
                    let mut debug_trait_builder = f.debug_tuple("ParseUnOp");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseUnOp {
        #[inline]
        fn eq(&self, other: &ParseUnOp) -> bool {
            match *other {
                ParseUnOp => match *self {
                    ParseUnOp => true,
                },
            }
        }
    }
    impl<'a> Parser<'a> for ParseUnOp {
        type Item = UnOp<'a>;
        fn parse(
            &self,
            state: ParserState<'a>,
        ) -> Result<(ParserState<'a>, UnOp<'a>), InternalAstError<'a>> {
            (|_, state: ParserState<'a>| {
                if let Ok((state, _)) = ParseSymbol(Symbol::Minus).parse(state.clone()) {
                    return Ok((state.clone(), UnOp::Minus(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Not).parse(state.clone()) {
                    return Ok((state.clone(), UnOp::Not(state.peek())));
                }
                if let Ok((state, _)) = ParseSymbol(Symbol::Hash).parse(state.clone()) {
                    return Ok((state.clone(), UnOp::Hash(state.peek())));
                }
                Err(InternalAstError::NoMatch)
            })(self, state)
        }
    }
    #[doc = " An error that occurs when creating the ast *after* tokenizing"]
    pub enum AstError<'a> {
        #[doc = " There were no tokens passed, which shouldn't happen normally"]
        Empty,
        #[doc = " Tokens passed had no end of file token, which shouldn't happen normally"]
        NoEof,
        #[doc = " An unexpected token, the most likely scenario when getting an AstError"]
        UnexpectedToken {
            #[doc = " The token that caused the error"]
            token: Token<'a>,
            #[doc = " Any additional information that could be provided for debugging"]
            additional: Option<&'a str>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for AstError<'a> {
        #[inline]
        fn clone(&self) -> AstError<'a> {
            match (&*self,) {
                (&AstError::Empty,) => AstError::Empty,
                (&AstError::NoEof,) => AstError::NoEof,
                (&AstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => AstError::UnexpectedToken {
                    token: ::std::clone::Clone::clone(&(*__self_0)),
                    additional: ::std::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for AstError<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&AstError::Empty,) => {
                    let mut debug_trait_builder = f.debug_tuple("Empty");
                    debug_trait_builder.finish()
                }
                (&AstError::NoEof,) => {
                    let mut debug_trait_builder = f.debug_tuple("NoEof");
                    debug_trait_builder.finish()
                }
                (&AstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("UnexpectedToken");
                    let _ = debug_trait_builder.field("token", &&(*__self_0));
                    let _ = debug_trait_builder.field("additional", &&(*__self_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for AstError<'a> {
        #[inline]
        fn eq(&self, other: &AstError<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &AstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &AstError<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &AstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_AstError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for AstError<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Empty" => _serde::export::Ok(__Field::__field0),
                            "NoEof" => _serde::export::Ok(__Field::__field1),
                            "UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Empty" => _serde::export::Ok(__Field::__field0),
                            b"NoEof" => _serde::export::Ok(__Field::__field1),
                            b"UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<AstError<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = AstError<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum AstError")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(AstError::Empty)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(AstError::NoEof)
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "token" => _serde::export::Ok(__Field::__field0),
                                            "additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"token" => _serde::export::Ok(__Field::__field0),
                                            b"additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de: 'a, 'a> {
                                    marker: _serde::export::PhantomData<AstError<'a>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = AstError<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant AstError::UnexpectedToken",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Token<'a>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant AstError::UnexpectedToken with 2 elements" ) ) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<&'a str>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant AstError::UnexpectedToken with 2 elements" ) ) ;
                                                }
                                            };
                                        _serde::export::Ok(AstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<Token<'a>> =
                                            _serde::export::None;
                                        let mut __field1: _serde::export::Option<Option<&'a str>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "token" ) ) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Token<'a>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "additional" ) ) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<&'a str>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("token") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "additional",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(AstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["token", "additional"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<AstError<'a>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Empty", "NoEof", "UnexpectedToken"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AstError",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<AstError<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_AstError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for AstError<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AstError::Empty => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AstError",
                        0u32,
                        "Empty",
                    ),
                    AstError::NoEof => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AstError",
                        1u32,
                        "NoEof",
                    ),
                    AstError::UnexpectedToken {
                        ref token,
                        ref additional,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "AstError",
                            2u32,
                            "UnexpectedToken",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token",
                            token,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional",
                            additional,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    impl<'a> fmt::Display for AstError<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match self {
                AstError::Empty => formatter.write_fmt(::std::fmt::Arguments::new_v1(
                    &["tokens passed was empty, which shouldn\'t happen normally"],
                    &match () {
                        () => [],
                    },
                )),
                AstError::NoEof => formatter.write_fmt(::std::fmt::Arguments::new_v1(
                    &["tokens passed had no eof token, which shouldn\'t happen normally"],
                    &match () {
                        () => [],
                    },
                )),
                AstError::UnexpectedToken { token, additional } => {
                    formatter.write_fmt(::std::fmt::Arguments::new_v1(
                        &[
                            "unexpected token `",
                            "`. (starting from line ",
                            ", character ",
                            " and ending on line ",
                            ", character ",
                            ")",
                        ],
                        &match (
                            &token,
                            &token.start_position().line(),
                            &token.start_position().character(),
                            &token.end_position().line(),
                            &token.end_position().character(),
                            &match additional {
                                Some(additional) => {
                                    ::alloc::fmt::format(::std::fmt::Arguments::new_v1(
                                        &["\nadditional information: "],
                                        &match (&additional,) {
                                            (arg0,) => [::std::fmt::ArgumentV1::new(
                                                arg0,
                                                ::std::fmt::Display::fmt,
                                            )],
                                        },
                                    ))
                                }
                                None => String::new(),
                            },
                        ) {
                            (arg0, arg1, arg2, arg3, arg4, arg5) => [
                                ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg2, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg3, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg4, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg5, ::std::fmt::Display::fmt),
                            ],
                        },
                    ))
                }
            }
        }
    }
    impl<'a> std::error::Error for AstError<'a> {}
    enum InternalAstError<'a> {
        NoMatch,
        UnexpectedToken {
            #[serde(borrow)]
            token: TokenReference<'a>,
            additional: Option<&'a str>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for InternalAstError<'a> {
        #[inline]
        fn clone(&self) -> InternalAstError<'a> {
            match (&*self,) {
                (&InternalAstError::NoMatch,) => InternalAstError::NoMatch,
                (&InternalAstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => InternalAstError::UnexpectedToken {
                    token: ::std::clone::Clone::clone(&(*__self_0)),
                    additional: ::std::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for InternalAstError<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&InternalAstError::NoMatch,) => {
                    let mut debug_trait_builder = f.debug_tuple("NoMatch");
                    debug_trait_builder.finish()
                }
                (&InternalAstError::UnexpectedToken {
                    token: ref __self_0,
                    additional: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("UnexpectedToken");
                    let _ = debug_trait_builder.field("token", &&(*__self_0));
                    let _ = debug_trait_builder.field("additional", &&(*__self_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for InternalAstError<'a> {
        #[inline]
        fn eq(&self, other: &InternalAstError<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &InternalAstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &InternalAstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &InternalAstError<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &InternalAstError::UnexpectedToken {
                                token: ref __self_0,
                                additional: ref __self_1,
                            },
                            &InternalAstError::UnexpectedToken {
                                token: ref __arg_1_0,
                                additional: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_InternalAstError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for InternalAstError<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "NoMatch" => _serde::export::Ok(__Field::__field0),
                            "UnexpectedToken" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"NoMatch" => _serde::export::Ok(__Field::__field0),
                            b"UnexpectedToken" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<InternalAstError<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = InternalAstError<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum InternalAstError")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(InternalAstError::NoMatch)
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::export::Ok(__Field::__field0),
                                            1u64 => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Err(
                                                _serde::de::Error::invalid_value(
                                                    _serde::de::Unexpected::Unsigned(__value),
                                                    &"field index 0 <= i < 2",
                                                ),
                                            ),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "token" => _serde::export::Ok(__Field::__field0),
                                            "additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::export::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"token" => _serde::export::Ok(__Field::__field0),
                                            b"additional" => _serde::export::Ok(__Field::__field1),
                                            _ => _serde::export::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::export::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de: 'a, 'a> {
                                    marker: _serde::export::PhantomData<InternalAstError<'a>>,
                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                }
                                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = InternalAstError<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::export::Formatter,
                                    ) -> _serde::export::fmt::Result
                                    {
                                        _serde::export::Formatter::write_str(
                                            __formatter,
                                            "struct variant InternalAstError::UnexpectedToken",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                TokenReference<'a>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant InternalAstError::UnexpectedToken with 2 elements" ) ) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<&'a str>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            } {
                                                _serde::export::Some(__value) => __value,
                                                _serde::export::None => {
                                                    return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant InternalAstError::UnexpectedToken with 2 elements" ) ) ;
                                                }
                                            };
                                        _serde::export::Ok(InternalAstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::export::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::export::Option<
                                            TokenReference<'a>,
                                        > = _serde::export::None;
                                        let mut __field1: _serde::export::Option<Option<&'a str>> =
                                            _serde::export::None;
                                        while let _serde::export::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::export::Option::is_some(&__field0) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "token" ) ) ;
                                                    }
                                                    __field0 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            TokenReference<'a>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::export::Option::is_some(&__field1) {
                                                        return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "additional" ) ) ;
                                                    }
                                                    __field1 = _serde::export::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<&'a str>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::export::Some(__field0) => __field0,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field("token") {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::export::Some(__field1) => __field1,
                                            _serde::export::None => {
                                                match _serde::private::de::missing_field(
                                                    "additional",
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::export::Ok(InternalAstError::UnexpectedToken {
                                            token: __field0,
                                            additional: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["token", "additional"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::export::PhantomData::<InternalAstError<'a>>,
                                        lifetime: _serde::export::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["NoMatch", "UnexpectedToken"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "InternalAstError",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<InternalAstError<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_InternalAstError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for InternalAstError<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    InternalAstError::NoMatch => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "InternalAstError",
                        0u32,
                        "NoMatch",
                    ),
                    InternalAstError::UnexpectedToken {
                        ref token,
                        ref additional,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "InternalAstError",
                            1u32,
                            "UnexpectedToken",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "token",
                            token,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "additional",
                            additional,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc = " An abstract syntax tree, contains all the nodes used in the code"]
    pub struct Ast<'a> {
        nodes: Block<'a>,
        tokens: Arc<Arena<Token<'a>>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Ast<'a> {
        #[inline]
        fn clone(&self) -> Ast<'a> {
            match *self {
                Ast {
                    nodes: ref __self_0_0,
                    tokens: ref __self_0_1,
                } => Ast {
                    nodes: ::std::clone::Clone::clone(&(*__self_0_0)),
                    tokens: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Ast<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Ast {
                    nodes: ref __self_0_0,
                    tokens: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Ast");
                    let _ = debug_trait_builder.field("nodes", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("tokens", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl<'a> Ast<'a> {
        #[doc = " Create an Ast from the passed tokens. You probably want [`parse`](../fn.parse.html)"]
        #[doc = ""]
        #[doc = " # Errors"]
        #[doc = ""]
        #[doc = " If the tokens passed are impossible to get through normal tokenization,"]
        #[doc = " an error of Empty (if the vector is empty) or NoEof (if there is no eof token)"]
        #[doc = " will be returned."]
        #[doc = ""]
        #[doc = " More likely, if the tokens pass are invalid Lua 5.1 code, an"]
        #[doc = " UnexpectedToken error will be returned."]
        pub fn from_tokens(tokens: Vec<Token<'a>>) -> Result<Ast<'a>, AstError<'a>> {
            if *tokens.last().ok_or(AstError::Empty)?.token_type() != TokenType::Eof {
                Err(AstError::NoEof)
            } else {
                let tokens = Arc::new(Arena::from_iter(tokens));
                let mut state = ParserState::new(Arc::clone(&tokens));
                if tokens
                    .iter()
                    .filter(|token| !token.1.token_type().ignore())
                    .count()
                    == 1
                {
                    return Ok(Ast {
                        nodes: Block {
                            stmts: Vec::new(),
                            last_stmt: None,
                        },
                        tokens,
                    });
                }
                if state.peek().token_type().ignore() {
                    state = state.advance().unwrap();
                }
                match ParseBlock.parse(state.clone()) {
                    Ok((state, block)) => {
                        if state.index == tokens.len() - 1 {
                            Ok(Ast {
                                tokens,
                                nodes: block,
                            })
                        } else {
                            Err(AstError::UnexpectedToken {
                                token: (*state.peek()).to_owned(),
                                additional: Some("leftover token"),
                            })
                        }
                    }
                    Err(InternalAstError::NoMatch) => Err(AstError::UnexpectedToken {
                        token: (*state.peek()).to_owned(),
                        additional: None,
                    }),
                    Err(InternalAstError::UnexpectedToken { token, additional }) => {
                        Err(AstError::UnexpectedToken {
                            token: (*token).to_owned(),
                            additional,
                        })
                    }
                }
            }
        }
        #[doc = " The entire code of the function"]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " # fn main() -> Result<(), Box<std::error::Error>> {"]
        #[doc = " assert_eq!(full_moon::parse(\"local x = 1; local y = 2\")?.nodes().iter_stmts().count(), 2);"]
        #[doc = " # Ok(())"]
        #[doc = " # }"]
        #[doc = " ```"]
        pub fn nodes(&self) -> &Block<'a> {
            &self.nodes
        }
        #[doc = " The entire code of the function, but mutable"]
        pub fn nodes_mut(&mut self) -> &mut Block<'a> {
            &mut self.nodes
        }
        #[doc = " An iterator over the tokens used to create the Ast"]
        pub fn iter_tokens(&self) -> impl Iterator<Item = &Token<'a>> {
            self.tokens.iter().map(|(_, token)| token).sorted()
        }
        #[doc = " Will update the positions of all the tokens in the tree"]
        #[doc = " Necessary if you are both mutating the tree and need the positions of the tokens"]
        pub fn update_positions(&mut self) {
            use crate::tokenizer::Position;
            let mut start_position = Position {
                bytes: 0,
                character: 1,
                line: 1,
            };
            let mut next_is_new_line = false;
            for (_, token) in self.tokens.iter() {
                let display = token.to_string();
                let new_lines = match bytecount::count(display.as_bytes(), b'\n') {
                    0 | 1 => 0,
                    n => n,
                };
                let end_position = if token.token_kind() == TokenKind::Eof {
                    start_position
                } else {
                    let mut end_position = Position {
                        bytes: start_position.bytes() + display.len(),
                        line: start_position.line() + new_lines,
                        character: {
                            let offset = display.lines().last().unwrap_or("").len();
                            if new_lines > 0 || next_is_new_line {
                                offset + 1
                            } else {
                                start_position.character() + offset
                            }
                        },
                    };
                    if next_is_new_line {
                        end_position.line += 1;
                        next_is_new_line = false;
                    }
                    end_position
                };
                if display.ends_with('\n') {
                    next_is_new_line = true;
                }
                token.start_position.store(start_position);
                token.end_position.store(end_position);
                start_position = end_position;
            }
        }
    }
}
pub mod node {
    use crate::tokenizer::{Position, TokenReference};
    pub trait Node {
        fn start_position(&self) -> Option<Position>;
        fn end_position(&self) -> Option<Position>;
    }
    impl<'a> Node for TokenReference<'a> {
        fn start_position(&self) -> Option<Position> {
            Some((**self).start_position())
        }
        fn end_position(&self) -> Option<Position> {
            Some((**self).end_position())
        }
    }
    impl<T: Node> Node for Option<T> {
        fn start_position(&self) -> Option<Position> {
            self.as_ref().and_then(Node::start_position)
        }
        fn end_position(&self) -> Option<Position> {
            self.as_ref().and_then(Node::end_position)
        }
    }
    impl<T: Node> Node for Vec<T> {
        fn start_position(&self) -> Option<Position> {
            self.first()?.start_position()
        }
        fn end_position(&self) -> Option<Position> {
            self.last()?.end_position()
        }
    }
    impl<A: Node, B: Node> Node for (A, B) {
        fn start_position(&self) -> Option<Position> {
            self.0.start_position()
        }
        fn end_position(&self) -> Option<Position> {
            self.1.end_position()
        }
    }
}
#[doc = " Used for tokenizing, the process of converting the code to individual tokens."]
#[doc = " Useful for getting symbols and manually tokenizing without going using an AST."]
pub mod tokenizer {
    use crate::visitors::{Visit, VisitMut, Visitor, VisitorMut};
    use atomic_refcell::AtomicRefCell;
    use crossbeam_utils::atomic::AtomicCell;
    use generational_arena::{Arena, Index};
    use lazy_static::lazy_static;
    use regex::{self, Regex};
    #[cfg(feature = "serde")]
    use serde::{Deserialize, Deserializer, Serialize, Serializer};
    use std::{borrow::Cow, cmp::Ordering, fmt, str::FromStr, sync::Arc};
    #[doc = " A literal symbol, used for both words important to syntax (like while) and operators (like +)"]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum Symbol {
        #[serde(rename = "and")]
        #[allow(missing_docs)]
        And,
        #[serde(rename = "break")]
        #[allow(missing_docs)]
        Break,
        #[serde(rename = "do")]
        #[allow(missing_docs)]
        Do,
        #[serde(rename = "elseif")]
        #[allow(missing_docs)]
        ElseIf,
        #[serde(rename = "else")]
        #[allow(missing_docs)]
        Else,
        #[serde(rename = "end")]
        #[allow(missing_docs)]
        End,
        #[serde(rename = "false")]
        #[allow(missing_docs)]
        False,
        #[serde(rename = "for")]
        #[allow(missing_docs)]
        For,
        #[serde(rename = "function")]
        #[allow(missing_docs)]
        Function,
        #[serde(rename = "if")]
        #[allow(missing_docs)]
        If,
        #[serde(rename = "in")]
        #[allow(missing_docs)]
        In,
        #[serde(rename = "local")]
        #[allow(missing_docs)]
        Local,
        #[serde(rename = "nil")]
        #[allow(missing_docs)]
        Nil,
        #[serde(rename = "not")]
        #[allow(missing_docs)]
        Not,
        #[serde(rename = "or")]
        #[allow(missing_docs)]
        Or,
        #[serde(rename = "repeat")]
        #[allow(missing_docs)]
        Repeat,
        #[serde(rename = "return")]
        #[allow(missing_docs)]
        Return,
        #[serde(rename = "then")]
        #[allow(missing_docs)]
        Then,
        #[serde(rename = "true")]
        #[allow(missing_docs)]
        True,
        #[serde(rename = "until")]
        #[allow(missing_docs)]
        Until,
        #[serde(rename = "while")]
        #[allow(missing_docs)]
        While,
        #[serde(rename = "^")]
        #[allow(missing_docs)]
        Caret,
        #[serde(rename = ":")]
        #[allow(missing_docs)]
        Colon,
        #[serde(rename = ",")]
        #[allow(missing_docs)]
        Comma,
        #[serde(rename = "...")]
        #[allow(missing_docs)]
        Ellipse,
        #[serde(rename = "..")]
        #[allow(missing_docs)]
        TwoDots,
        #[serde(rename = ".")]
        #[allow(missing_docs)]
        Dot,
        #[serde(rename = "==")]
        #[allow(missing_docs)]
        TwoEqual,
        #[serde(rename = "=")]
        #[allow(missing_docs)]
        Equal,
        #[serde(rename = ">=")]
        #[allow(missing_docs)]
        GreaterThanEqual,
        #[serde(rename = ">")]
        #[allow(missing_docs)]
        GreaterThan,
        #[serde(rename = "#")]
        #[allow(missing_docs)]
        Hash,
        #[serde(rename = "{")]
        #[allow(missing_docs)]
        LeftBrace,
        #[serde(rename = "[")]
        #[allow(missing_docs)]
        LeftBracket,
        #[serde(rename = "(")]
        #[allow(missing_docs)]
        LeftParen,
        #[serde(rename = "<=")]
        #[allow(missing_docs)]
        LessThanEqual,
        #[serde(rename = "<")]
        #[allow(missing_docs)]
        LessThan,
        #[serde(rename = "-")]
        #[allow(missing_docs)]
        Minus,
        #[serde(rename = "%")]
        #[allow(missing_docs)]
        Percent,
        #[serde(rename = "+")]
        #[allow(missing_docs)]
        Plus,
        #[serde(rename = "}")]
        #[allow(missing_docs)]
        RightBrace,
        #[serde(rename = "]")]
        #[allow(missing_docs)]
        RightBracket,
        #[serde(rename = ")")]
        #[allow(missing_docs)]
        RightParen,
        #[serde(rename = ";")]
        #[allow(missing_docs)]
        Semicolon,
        #[serde(rename = "/")]
        #[allow(missing_docs)]
        Slash,
        #[serde(rename = "*")]
        #[allow(missing_docs)]
        Star,
        #[serde(rename = "~=")]
        #[allow(missing_docs)]
        TildeEqual,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Symbol {
        #[inline]
        fn clone(&self) -> Symbol {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Symbol {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Symbol {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Symbol::And,) => {
                    let mut debug_trait_builder = f.debug_tuple("And");
                    debug_trait_builder.finish()
                }
                (&Symbol::Break,) => {
                    let mut debug_trait_builder = f.debug_tuple("Break");
                    debug_trait_builder.finish()
                }
                (&Symbol::Do,) => {
                    let mut debug_trait_builder = f.debug_tuple("Do");
                    debug_trait_builder.finish()
                }
                (&Symbol::ElseIf,) => {
                    let mut debug_trait_builder = f.debug_tuple("ElseIf");
                    debug_trait_builder.finish()
                }
                (&Symbol::Else,) => {
                    let mut debug_trait_builder = f.debug_tuple("Else");
                    debug_trait_builder.finish()
                }
                (&Symbol::End,) => {
                    let mut debug_trait_builder = f.debug_tuple("End");
                    debug_trait_builder.finish()
                }
                (&Symbol::False,) => {
                    let mut debug_trait_builder = f.debug_tuple("False");
                    debug_trait_builder.finish()
                }
                (&Symbol::For,) => {
                    let mut debug_trait_builder = f.debug_tuple("For");
                    debug_trait_builder.finish()
                }
                (&Symbol::Function,) => {
                    let mut debug_trait_builder = f.debug_tuple("Function");
                    debug_trait_builder.finish()
                }
                (&Symbol::If,) => {
                    let mut debug_trait_builder = f.debug_tuple("If");
                    debug_trait_builder.finish()
                }
                (&Symbol::In,) => {
                    let mut debug_trait_builder = f.debug_tuple("In");
                    debug_trait_builder.finish()
                }
                (&Symbol::Local,) => {
                    let mut debug_trait_builder = f.debug_tuple("Local");
                    debug_trait_builder.finish()
                }
                (&Symbol::Nil,) => {
                    let mut debug_trait_builder = f.debug_tuple("Nil");
                    debug_trait_builder.finish()
                }
                (&Symbol::Not,) => {
                    let mut debug_trait_builder = f.debug_tuple("Not");
                    debug_trait_builder.finish()
                }
                (&Symbol::Or,) => {
                    let mut debug_trait_builder = f.debug_tuple("Or");
                    debug_trait_builder.finish()
                }
                (&Symbol::Repeat,) => {
                    let mut debug_trait_builder = f.debug_tuple("Repeat");
                    debug_trait_builder.finish()
                }
                (&Symbol::Return,) => {
                    let mut debug_trait_builder = f.debug_tuple("Return");
                    debug_trait_builder.finish()
                }
                (&Symbol::Then,) => {
                    let mut debug_trait_builder = f.debug_tuple("Then");
                    debug_trait_builder.finish()
                }
                (&Symbol::True,) => {
                    let mut debug_trait_builder = f.debug_tuple("True");
                    debug_trait_builder.finish()
                }
                (&Symbol::Until,) => {
                    let mut debug_trait_builder = f.debug_tuple("Until");
                    debug_trait_builder.finish()
                }
                (&Symbol::While,) => {
                    let mut debug_trait_builder = f.debug_tuple("While");
                    debug_trait_builder.finish()
                }
                (&Symbol::Caret,) => {
                    let mut debug_trait_builder = f.debug_tuple("Caret");
                    debug_trait_builder.finish()
                }
                (&Symbol::Colon,) => {
                    let mut debug_trait_builder = f.debug_tuple("Colon");
                    debug_trait_builder.finish()
                }
                (&Symbol::Comma,) => {
                    let mut debug_trait_builder = f.debug_tuple("Comma");
                    debug_trait_builder.finish()
                }
                (&Symbol::Ellipse,) => {
                    let mut debug_trait_builder = f.debug_tuple("Ellipse");
                    debug_trait_builder.finish()
                }
                (&Symbol::TwoDots,) => {
                    let mut debug_trait_builder = f.debug_tuple("TwoDots");
                    debug_trait_builder.finish()
                }
                (&Symbol::Dot,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dot");
                    debug_trait_builder.finish()
                }
                (&Symbol::TwoEqual,) => {
                    let mut debug_trait_builder = f.debug_tuple("TwoEqual");
                    debug_trait_builder.finish()
                }
                (&Symbol::Equal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Equal");
                    debug_trait_builder.finish()
                }
                (&Symbol::GreaterThanEqual,) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterThanEqual");
                    debug_trait_builder.finish()
                }
                (&Symbol::GreaterThan,) => {
                    let mut debug_trait_builder = f.debug_tuple("GreaterThan");
                    debug_trait_builder.finish()
                }
                (&Symbol::Hash,) => {
                    let mut debug_trait_builder = f.debug_tuple("Hash");
                    debug_trait_builder.finish()
                }
                (&Symbol::LeftBrace,) => {
                    let mut debug_trait_builder = f.debug_tuple("LeftBrace");
                    debug_trait_builder.finish()
                }
                (&Symbol::LeftBracket,) => {
                    let mut debug_trait_builder = f.debug_tuple("LeftBracket");
                    debug_trait_builder.finish()
                }
                (&Symbol::LeftParen,) => {
                    let mut debug_trait_builder = f.debug_tuple("LeftParen");
                    debug_trait_builder.finish()
                }
                (&Symbol::LessThanEqual,) => {
                    let mut debug_trait_builder = f.debug_tuple("LessThanEqual");
                    debug_trait_builder.finish()
                }
                (&Symbol::LessThan,) => {
                    let mut debug_trait_builder = f.debug_tuple("LessThan");
                    debug_trait_builder.finish()
                }
                (&Symbol::Minus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Minus");
                    debug_trait_builder.finish()
                }
                (&Symbol::Percent,) => {
                    let mut debug_trait_builder = f.debug_tuple("Percent");
                    debug_trait_builder.finish()
                }
                (&Symbol::Plus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Plus");
                    debug_trait_builder.finish()
                }
                (&Symbol::RightBrace,) => {
                    let mut debug_trait_builder = f.debug_tuple("RightBrace");
                    debug_trait_builder.finish()
                }
                (&Symbol::RightBracket,) => {
                    let mut debug_trait_builder = f.debug_tuple("RightBracket");
                    debug_trait_builder.finish()
                }
                (&Symbol::RightParen,) => {
                    let mut debug_trait_builder = f.debug_tuple("RightParen");
                    debug_trait_builder.finish()
                }
                (&Symbol::Semicolon,) => {
                    let mut debug_trait_builder = f.debug_tuple("Semicolon");
                    debug_trait_builder.finish()
                }
                (&Symbol::Slash,) => {
                    let mut debug_trait_builder = f.debug_tuple("Slash");
                    debug_trait_builder.finish()
                }
                (&Symbol::Star,) => {
                    let mut debug_trait_builder = f.debug_tuple("Star");
                    debug_trait_builder.finish()
                }
                (&Symbol::TildeEqual,) => {
                    let mut debug_trait_builder = f.debug_tuple("TildeEqual");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Symbol {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Symbol {
        #[inline]
        fn eq(&self, other: &Symbol) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Symbol: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Symbol {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                    __field14,
                    __field15,
                    __field16,
                    __field17,
                    __field18,
                    __field19,
                    __field20,
                    __field21,
                    __field22,
                    __field23,
                    __field24,
                    __field25,
                    __field26,
                    __field27,
                    __field28,
                    __field29,
                    __field30,
                    __field31,
                    __field32,
                    __field33,
                    __field34,
                    __field35,
                    __field36,
                    __field37,
                    __field38,
                    __field39,
                    __field40,
                    __field41,
                    __field42,
                    __field43,
                    __field44,
                    __field45,
                    __field46,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            10u64 => _serde::export::Ok(__Field::__field10),
                            11u64 => _serde::export::Ok(__Field::__field11),
                            12u64 => _serde::export::Ok(__Field::__field12),
                            13u64 => _serde::export::Ok(__Field::__field13),
                            14u64 => _serde::export::Ok(__Field::__field14),
                            15u64 => _serde::export::Ok(__Field::__field15),
                            16u64 => _serde::export::Ok(__Field::__field16),
                            17u64 => _serde::export::Ok(__Field::__field17),
                            18u64 => _serde::export::Ok(__Field::__field18),
                            19u64 => _serde::export::Ok(__Field::__field19),
                            20u64 => _serde::export::Ok(__Field::__field20),
                            21u64 => _serde::export::Ok(__Field::__field21),
                            22u64 => _serde::export::Ok(__Field::__field22),
                            23u64 => _serde::export::Ok(__Field::__field23),
                            24u64 => _serde::export::Ok(__Field::__field24),
                            25u64 => _serde::export::Ok(__Field::__field25),
                            26u64 => _serde::export::Ok(__Field::__field26),
                            27u64 => _serde::export::Ok(__Field::__field27),
                            28u64 => _serde::export::Ok(__Field::__field28),
                            29u64 => _serde::export::Ok(__Field::__field29),
                            30u64 => _serde::export::Ok(__Field::__field30),
                            31u64 => _serde::export::Ok(__Field::__field31),
                            32u64 => _serde::export::Ok(__Field::__field32),
                            33u64 => _serde::export::Ok(__Field::__field33),
                            34u64 => _serde::export::Ok(__Field::__field34),
                            35u64 => _serde::export::Ok(__Field::__field35),
                            36u64 => _serde::export::Ok(__Field::__field36),
                            37u64 => _serde::export::Ok(__Field::__field37),
                            38u64 => _serde::export::Ok(__Field::__field38),
                            39u64 => _serde::export::Ok(__Field::__field39),
                            40u64 => _serde::export::Ok(__Field::__field40),
                            41u64 => _serde::export::Ok(__Field::__field41),
                            42u64 => _serde::export::Ok(__Field::__field42),
                            43u64 => _serde::export::Ok(__Field::__field43),
                            44u64 => _serde::export::Ok(__Field::__field44),
                            45u64 => _serde::export::Ok(__Field::__field45),
                            46u64 => _serde::export::Ok(__Field::__field46),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 47",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "and" => _serde::export::Ok(__Field::__field0),
                            "break" => _serde::export::Ok(__Field::__field1),
                            "do" => _serde::export::Ok(__Field::__field2),
                            "elseif" => _serde::export::Ok(__Field::__field3),
                            "else" => _serde::export::Ok(__Field::__field4),
                            "end" => _serde::export::Ok(__Field::__field5),
                            "false" => _serde::export::Ok(__Field::__field6),
                            "for" => _serde::export::Ok(__Field::__field7),
                            "function" => _serde::export::Ok(__Field::__field8),
                            "if" => _serde::export::Ok(__Field::__field9),
                            "in" => _serde::export::Ok(__Field::__field10),
                            "local" => _serde::export::Ok(__Field::__field11),
                            "nil" => _serde::export::Ok(__Field::__field12),
                            "not" => _serde::export::Ok(__Field::__field13),
                            "or" => _serde::export::Ok(__Field::__field14),
                            "repeat" => _serde::export::Ok(__Field::__field15),
                            "return" => _serde::export::Ok(__Field::__field16),
                            "then" => _serde::export::Ok(__Field::__field17),
                            "true" => _serde::export::Ok(__Field::__field18),
                            "until" => _serde::export::Ok(__Field::__field19),
                            "while" => _serde::export::Ok(__Field::__field20),
                            "^" => _serde::export::Ok(__Field::__field21),
                            ":" => _serde::export::Ok(__Field::__field22),
                            "," => _serde::export::Ok(__Field::__field23),
                            "..." => _serde::export::Ok(__Field::__field24),
                            ".." => _serde::export::Ok(__Field::__field25),
                            "." => _serde::export::Ok(__Field::__field26),
                            "==" => _serde::export::Ok(__Field::__field27),
                            "=" => _serde::export::Ok(__Field::__field28),
                            ">=" => _serde::export::Ok(__Field::__field29),
                            ">" => _serde::export::Ok(__Field::__field30),
                            "#" => _serde::export::Ok(__Field::__field31),
                            "{" => _serde::export::Ok(__Field::__field32),
                            "[" => _serde::export::Ok(__Field::__field33),
                            "(" => _serde::export::Ok(__Field::__field34),
                            "<=" => _serde::export::Ok(__Field::__field35),
                            "<" => _serde::export::Ok(__Field::__field36),
                            "-" => _serde::export::Ok(__Field::__field37),
                            "%" => _serde::export::Ok(__Field::__field38),
                            "+" => _serde::export::Ok(__Field::__field39),
                            "}" => _serde::export::Ok(__Field::__field40),
                            "]" => _serde::export::Ok(__Field::__field41),
                            ")" => _serde::export::Ok(__Field::__field42),
                            ";" => _serde::export::Ok(__Field::__field43),
                            "/" => _serde::export::Ok(__Field::__field44),
                            "*" => _serde::export::Ok(__Field::__field45),
                            "~=" => _serde::export::Ok(__Field::__field46),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"and" => _serde::export::Ok(__Field::__field0),
                            b"break" => _serde::export::Ok(__Field::__field1),
                            b"do" => _serde::export::Ok(__Field::__field2),
                            b"elseif" => _serde::export::Ok(__Field::__field3),
                            b"else" => _serde::export::Ok(__Field::__field4),
                            b"end" => _serde::export::Ok(__Field::__field5),
                            b"false" => _serde::export::Ok(__Field::__field6),
                            b"for" => _serde::export::Ok(__Field::__field7),
                            b"function" => _serde::export::Ok(__Field::__field8),
                            b"if" => _serde::export::Ok(__Field::__field9),
                            b"in" => _serde::export::Ok(__Field::__field10),
                            b"local" => _serde::export::Ok(__Field::__field11),
                            b"nil" => _serde::export::Ok(__Field::__field12),
                            b"not" => _serde::export::Ok(__Field::__field13),
                            b"or" => _serde::export::Ok(__Field::__field14),
                            b"repeat" => _serde::export::Ok(__Field::__field15),
                            b"return" => _serde::export::Ok(__Field::__field16),
                            b"then" => _serde::export::Ok(__Field::__field17),
                            b"true" => _serde::export::Ok(__Field::__field18),
                            b"until" => _serde::export::Ok(__Field::__field19),
                            b"while" => _serde::export::Ok(__Field::__field20),
                            b"^" => _serde::export::Ok(__Field::__field21),
                            b":" => _serde::export::Ok(__Field::__field22),
                            b"," => _serde::export::Ok(__Field::__field23),
                            b"..." => _serde::export::Ok(__Field::__field24),
                            b".." => _serde::export::Ok(__Field::__field25),
                            b"." => _serde::export::Ok(__Field::__field26),
                            b"==" => _serde::export::Ok(__Field::__field27),
                            b"=" => _serde::export::Ok(__Field::__field28),
                            b">=" => _serde::export::Ok(__Field::__field29),
                            b">" => _serde::export::Ok(__Field::__field30),
                            b"#" => _serde::export::Ok(__Field::__field31),
                            b"{" => _serde::export::Ok(__Field::__field32),
                            b"[" => _serde::export::Ok(__Field::__field33),
                            b"(" => _serde::export::Ok(__Field::__field34),
                            b"<=" => _serde::export::Ok(__Field::__field35),
                            b"<" => _serde::export::Ok(__Field::__field36),
                            b"-" => _serde::export::Ok(__Field::__field37),
                            b"%" => _serde::export::Ok(__Field::__field38),
                            b"+" => _serde::export::Ok(__Field::__field39),
                            b"}" => _serde::export::Ok(__Field::__field40),
                            b"]" => _serde::export::Ok(__Field::__field41),
                            b")" => _serde::export::Ok(__Field::__field42),
                            b";" => _serde::export::Ok(__Field::__field43),
                            b"/" => _serde::export::Ok(__Field::__field44),
                            b"*" => _serde::export::Ok(__Field::__field45),
                            b"~=" => _serde::export::Ok(__Field::__field46),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Symbol>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Symbol;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Symbol")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::And)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Break)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Do)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::ElseIf)
                            }
                            (__Field::__field4, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Else)
                            }
                            (__Field::__field5, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::End)
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::False)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::For)
                            }
                            (__Field::__field8, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Function)
                            }
                            (__Field::__field9, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::If)
                            }
                            (__Field::__field10, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::In)
                            }
                            (__Field::__field11, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Local)
                            }
                            (__Field::__field12, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Nil)
                            }
                            (__Field::__field13, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Not)
                            }
                            (__Field::__field14, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Or)
                            }
                            (__Field::__field15, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Repeat)
                            }
                            (__Field::__field16, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Return)
                            }
                            (__Field::__field17, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Then)
                            }
                            (__Field::__field18, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::True)
                            }
                            (__Field::__field19, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Until)
                            }
                            (__Field::__field20, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::While)
                            }
                            (__Field::__field21, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Caret)
                            }
                            (__Field::__field22, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Colon)
                            }
                            (__Field::__field23, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Comma)
                            }
                            (__Field::__field24, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Ellipse)
                            }
                            (__Field::__field25, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TwoDots)
                            }
                            (__Field::__field26, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Dot)
                            }
                            (__Field::__field27, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TwoEqual)
                            }
                            (__Field::__field28, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Equal)
                            }
                            (__Field::__field29, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::GreaterThanEqual)
                            }
                            (__Field::__field30, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::GreaterThan)
                            }
                            (__Field::__field31, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Hash)
                            }
                            (__Field::__field32, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftBrace)
                            }
                            (__Field::__field33, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftBracket)
                            }
                            (__Field::__field34, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LeftParen)
                            }
                            (__Field::__field35, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LessThanEqual)
                            }
                            (__Field::__field36, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::LessThan)
                            }
                            (__Field::__field37, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Minus)
                            }
                            (__Field::__field38, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Percent)
                            }
                            (__Field::__field39, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Plus)
                            }
                            (__Field::__field40, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightBrace)
                            }
                            (__Field::__field41, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightBracket)
                            }
                            (__Field::__field42, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::RightParen)
                            }
                            (__Field::__field43, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Semicolon)
                            }
                            (__Field::__field44, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Slash)
                            }
                            (__Field::__field45, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::Star)
                            }
                            (__Field::__field46, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Symbol::TildeEqual)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "and", "break", "do", "elseif", "else", "end", "false", "for", "function",
                    "if", "in", "local", "nil", "not", "or", "repeat", "return", "then", "true",
                    "until", "while", "^", ":", ",", "...", "..", ".", "==", "=", ">=", ">", "#",
                    "{", "[", "(", "<=", "<", "-", "%", "+", "}", "]", ")", ";", "/", "*", "~=",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Symbol",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Symbol>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Symbol: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Symbol {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Symbol::And => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        0u32,
                        "and",
                    ),
                    Symbol::Break => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        1u32,
                        "break",
                    ),
                    Symbol::Do => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        2u32,
                        "do",
                    ),
                    Symbol::ElseIf => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        3u32,
                        "elseif",
                    ),
                    Symbol::Else => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        4u32,
                        "else",
                    ),
                    Symbol::End => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        5u32,
                        "end",
                    ),
                    Symbol::False => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        6u32,
                        "false",
                    ),
                    Symbol::For => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        7u32,
                        "for",
                    ),
                    Symbol::Function => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        8u32,
                        "function",
                    ),
                    Symbol::If => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        9u32,
                        "if",
                    ),
                    Symbol::In => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        10u32,
                        "in",
                    ),
                    Symbol::Local => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        11u32,
                        "local",
                    ),
                    Symbol::Nil => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        12u32,
                        "nil",
                    ),
                    Symbol::Not => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        13u32,
                        "not",
                    ),
                    Symbol::Or => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        14u32,
                        "or",
                    ),
                    Symbol::Repeat => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        15u32,
                        "repeat",
                    ),
                    Symbol::Return => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        16u32,
                        "return",
                    ),
                    Symbol::Then => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        17u32,
                        "then",
                    ),
                    Symbol::True => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        18u32,
                        "true",
                    ),
                    Symbol::Until => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        19u32,
                        "until",
                    ),
                    Symbol::While => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        20u32,
                        "while",
                    ),
                    Symbol::Caret => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        21u32,
                        "^",
                    ),
                    Symbol::Colon => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        22u32,
                        ":",
                    ),
                    Symbol::Comma => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        23u32,
                        ",",
                    ),
                    Symbol::Ellipse => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        24u32,
                        "...",
                    ),
                    Symbol::TwoDots => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        25u32,
                        "..",
                    ),
                    Symbol::Dot => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        26u32,
                        ".",
                    ),
                    Symbol::TwoEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        27u32,
                        "==",
                    ),
                    Symbol::Equal => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        28u32,
                        "=",
                    ),
                    Symbol::GreaterThanEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        29u32,
                        ">=",
                    ),
                    Symbol::GreaterThan => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        30u32,
                        ">",
                    ),
                    Symbol::Hash => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        31u32,
                        "#",
                    ),
                    Symbol::LeftBrace => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        32u32,
                        "{",
                    ),
                    Symbol::LeftBracket => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        33u32,
                        "[",
                    ),
                    Symbol::LeftParen => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        34u32,
                        "(",
                    ),
                    Symbol::LessThanEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        35u32,
                        "<=",
                    ),
                    Symbol::LessThan => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        36u32,
                        "<",
                    ),
                    Symbol::Minus => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        37u32,
                        "-",
                    ),
                    Symbol::Percent => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        38u32,
                        "%",
                    ),
                    Symbol::Plus => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        39u32,
                        "+",
                    ),
                    Symbol::RightBrace => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        40u32,
                        "}",
                    ),
                    Symbol::RightBracket => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        41u32,
                        "]",
                    ),
                    Symbol::RightParen => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        42u32,
                        ")",
                    ),
                    Symbol::Semicolon => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        43u32,
                        ";",
                    ),
                    Symbol::Slash => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        44u32,
                        "/",
                    ),
                    Symbol::Star => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        45u32,
                        "*",
                    ),
                    Symbol::TildeEqual => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Symbol",
                        46u32,
                        "~=",
                    ),
                }
            }
        }
    };
    impl<'a> fmt::Display for Symbol {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                Symbol::And => "and",
                Symbol::Break => "break",
                Symbol::Do => "do",
                Symbol::ElseIf => "elseif",
                Symbol::Else => "else",
                Symbol::End => "end",
                Symbol::False => "false",
                Symbol::For => "for",
                Symbol::Function => "function",
                Symbol::If => "if",
                Symbol::In => "in",
                Symbol::Local => "local",
                Symbol::Nil => "nil",
                Symbol::Not => "not",
                Symbol::Or => "or",
                Symbol::Repeat => "repeat",
                Symbol::Return => "return",
                Symbol::Then => "then",
                Symbol::True => "true",
                Symbol::Until => "until",
                Symbol::While => "while",
                Symbol::Caret => "^",
                Symbol::Colon => ":",
                Symbol::Comma => ",",
                Symbol::Ellipse => "...",
                Symbol::TwoDots => "..",
                Symbol::Dot => ".",
                Symbol::TwoEqual => "==",
                Symbol::Equal => "=",
                Symbol::GreaterThanEqual => ">=",
                Symbol::GreaterThan => ">",
                Symbol::Hash => "#",
                Symbol::LeftBrace => "{",
                Symbol::LeftBracket => "[",
                Symbol::LeftParen => "(",
                Symbol::LessThanEqual => "<=",
                Symbol::LessThan => "<",
                Symbol::Minus => "-",
                Symbol::Percent => "%",
                Symbol::Plus => "+",
                Symbol::RightBrace => "}",
                Symbol::RightBracket => "]",
                Symbol::RightParen => ")",
                Symbol::Semicolon => ";",
                Symbol::Slash => "/",
                Symbol::Star => "*",
                Symbol::TildeEqual => "~=",
            }
            .fmt(formatter)
        }
    }
    impl FromStr for Symbol {
        type Err = ();
        fn from_str(string: &str) -> Result<Self, Self::Err> {
            Ok(match string {
                "and" => Symbol::And,
                "break" => Symbol::Break,
                "do" => Symbol::Do,
                "elseif" => Symbol::ElseIf,
                "else" => Symbol::Else,
                "end" => Symbol::End,
                "false" => Symbol::False,
                "for" => Symbol::For,
                "function" => Symbol::Function,
                "if" => Symbol::If,
                "in" => Symbol::In,
                "local" => Symbol::Local,
                "nil" => Symbol::Nil,
                "not" => Symbol::Not,
                "or" => Symbol::Or,
                "repeat" => Symbol::Repeat,
                "return" => Symbol::Return,
                "then" => Symbol::Then,
                "true" => Symbol::True,
                "until" => Symbol::Until,
                "while" => Symbol::While,
                "^" => Symbol::Caret,
                ":" => Symbol::Colon,
                "," => Symbol::Comma,
                "..." => Symbol::Ellipse,
                ".." => Symbol::TwoDots,
                "." => Symbol::Dot,
                "==" => Symbol::TwoEqual,
                "=" => Symbol::Equal,
                ">=" => Symbol::GreaterThanEqual,
                ">" => Symbol::GreaterThan,
                "#" => Symbol::Hash,
                "{" => Symbol::LeftBrace,
                "[" => Symbol::LeftBracket,
                "(" => Symbol::LeftParen,
                "<=" => Symbol::LessThanEqual,
                "<" => Symbol::LessThan,
                "-" => Symbol::Minus,
                "%" => Symbol::Percent,
                "+" => Symbol::Plus,
                "}" => Symbol::RightBrace,
                "]" => Symbol::RightBracket,
                ")" => Symbol::RightParen,
                ";" => Symbol::Semicolon,
                "/" => Symbol::Slash,
                "*" => Symbol::Star,
                "~=" => Symbol::TildeEqual,
                _ => Err(())?,
            })
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_SYMBOL {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_SYMBOL: PATTERN_SYMBOL = PATTERN_SYMBOL {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for PATTERN_SYMBOL {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(
                    &<[_]>::into_vec(box [
                        "and", "break", "do", "elseif", "else", "end", "false", "for", "function",
                        "if", "in", "local", "nil", "not", "or", "repeat", "return", "then",
                        "true", "until", "while", "^", ":", ",", "...", "..", ".", "==", "=", ">=",
                        ">", "#", "{", "[", "(", "<=", "<", "-", "%", "+", "}", "]", ")", ";", "/",
                        "*", "~=",
                    ])
                    .iter()
                    .map(|x| regex::escape(&x.to_string()))
                    .collect::<Vec<_>>()
                    .join("|"),
                )
                .unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_SYMBOL {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[doc = " The possible errors that can happen while tokenizing."]
    #[rustc_copy_clone_marker]
    pub enum TokenizerErrorType {
        #[doc = " An unclosed multi-line comment was found"]
        UnclosedComment,
        #[doc = " An unclosed string was found"]
        UnclosedString,
        #[doc = " An unexpected token was found"]
        UnexpectedToken(char),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TokenizerErrorType {
        #[inline]
        fn clone(&self) -> TokenizerErrorType {
            {
                let _: ::std::clone::AssertParamIsClone<char>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for TokenizerErrorType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TokenizerErrorType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&TokenizerErrorType::UnclosedComment,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnclosedComment");
                    debug_trait_builder.finish()
                }
                (&TokenizerErrorType::UnclosedString,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnclosedString");
                    debug_trait_builder.finish()
                }
                (&TokenizerErrorType::UnexpectedToken(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("UnexpectedToken");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TokenizerErrorType {
        #[inline]
        fn eq(&self, other: &TokenizerErrorType) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenizerErrorType::UnexpectedToken(ref __self_0),
                            &TokenizerErrorType::UnexpectedToken(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &TokenizerErrorType) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenizerErrorType::UnexpectedToken(ref __self_0),
                            &TokenizerErrorType::UnexpectedToken(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_TokenizerErrorType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenizerErrorType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UnclosedComment" => _serde::export::Ok(__Field::__field0),
                            "UnclosedString" => _serde::export::Ok(__Field::__field1),
                            "UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UnclosedComment" => _serde::export::Ok(__Field::__field0),
                            b"UnclosedString" => _serde::export::Ok(__Field::__field1),
                            b"UnexpectedToken" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TokenizerErrorType>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenizerErrorType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum TokenizerErrorType")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TokenizerErrorType::UnclosedComment)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(TokenizerErrorType::UnclosedString)
                            }
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<char>(__variant),
                                TokenizerErrorType::UnexpectedToken,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["UnclosedComment", "UnclosedString", "UnexpectedToken"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "TokenizerErrorType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TokenizerErrorType>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_TokenizerErrorType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenizerErrorType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TokenizerErrorType::UnclosedComment => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TokenizerErrorType",
                            0u32,
                            "UnclosedComment",
                        )
                    }
                    TokenizerErrorType::UnclosedString => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TokenizerErrorType",
                            1u32,
                            "UnclosedString",
                        )
                    }
                    TokenizerErrorType::UnexpectedToken(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "TokenizerErrorType",
                            2u32,
                            "UnexpectedToken",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc = " The type of tokens in parsed code"]
    #[serde(tag = "type")]
    #[structural_match]
    pub enum TokenType<'a> {
        #[doc = " End of file, should always be the very last token"]
        Eof,
        #[doc = " An identifier, such as `foo`"]
        Identifier {
            #[serde(borrow)]
            #[doc = " The identifier itself"]
            identifier: Cow<'a, str>,
        },
        #[doc = " A multi line comment in the format of --[[ comment ]]"]
        MultiLineComment {
            #[doc = " Number of equals signs, if any, for the multi line comment"]
            #[doc = " For example, `--[=[` would have a `blocks` value of `1`"]
            blocks: usize,
            #[serde(borrow)]
            #[doc = " The comment itself, ignoring opening and closing tags"]
            comment: Cow<'a, str>,
        },
        #[doc = " A literal number, such as `3.3`"]
        Number {
            #[serde(borrow)]
            #[doc = " The text representing the number, includes details such as `0x`"]
            text: Cow<'a, str>,
        },
        #[doc = " A single line comment, such as `-- comment`"]
        SingleLineComment {
            #[serde(borrow)]
            #[doc = " The comment, ignoring initial `--`"]
            comment: Cow<'a, str>,
        },
        #[doc = " A literal string, such as \"Hello, world\""]
        StringLiteral {
            #[serde(borrow)]
            #[doc = " The literal itself, ignoring quotation marks"]
            literal: Cow<'a, str>,
            #[serde(skip_serializing_if = "Option::is_none")]
            #[doc = " Number of equals signs used for a multi line string, if it is one"]
            #[doc = " For example, `[=[string]=]` would have a `multi_line` value of Some(1)"]
            #[doc = " [[string]] would have a `multi_line` value of Some(0)"]
            #[doc = " A string such as `\"string\"` would have a `multi_line` value of None"]
            multi_line: Option<usize>,
            #[doc = " The type of quotation mark used to make the string"]
            quote_type: StringLiteralQuoteType,
        },
        #[doc = " A [`Symbol`](enum.Symbol.html), such as `local` or `+`"]
        Symbol {
            #[doc = " The symbol itself"]
            symbol: Symbol,
        },
        #[doc = " Whitespace, such as tabs or new lines"]
        Whitespace {
            #[serde(borrow)]
            #[doc = " Characters consisting of the whitespace"]
            characters: Cow<'a, str>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for TokenType<'a> {
        #[inline]
        fn clone(&self) -> TokenType<'a> {
            match (&*self,) {
                (&TokenType::Eof,) => TokenType::Eof,
                (&TokenType::Identifier {
                    identifier: ref __self_0,
                },) => TokenType::Identifier {
                    identifier: ::std::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::MultiLineComment {
                    blocks: ref __self_0,
                    comment: ref __self_1,
                },) => TokenType::MultiLineComment {
                    blocks: ::std::clone::Clone::clone(&(*__self_0)),
                    comment: ::std::clone::Clone::clone(&(*__self_1)),
                },
                (&TokenType::Number { text: ref __self_0 },) => TokenType::Number {
                    text: ::std::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::SingleLineComment {
                    comment: ref __self_0,
                },) => TokenType::SingleLineComment {
                    comment: ::std::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::StringLiteral {
                    literal: ref __self_0,
                    multi_line: ref __self_1,
                    quote_type: ref __self_2,
                },) => TokenType::StringLiteral {
                    literal: ::std::clone::Clone::clone(&(*__self_0)),
                    multi_line: ::std::clone::Clone::clone(&(*__self_1)),
                    quote_type: ::std::clone::Clone::clone(&(*__self_2)),
                },
                (&TokenType::Symbol {
                    symbol: ref __self_0,
                },) => TokenType::Symbol {
                    symbol: ::std::clone::Clone::clone(&(*__self_0)),
                },
                (&TokenType::Whitespace {
                    characters: ref __self_0,
                },) => TokenType::Whitespace {
                    characters: ::std::clone::Clone::clone(&(*__self_0)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for TokenType<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&TokenType::Eof,) => {
                    let mut debug_trait_builder = f.debug_tuple("Eof");
                    debug_trait_builder.finish()
                }
                (&TokenType::Identifier {
                    identifier: ref __self_0,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Identifier");
                    let _ = debug_trait_builder.field("identifier", &&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenType::MultiLineComment {
                    blocks: ref __self_0,
                    comment: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("MultiLineComment");
                    let _ = debug_trait_builder.field("blocks", &&(*__self_0));
                    let _ = debug_trait_builder.field("comment", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&TokenType::Number { text: ref __self_0 },) => {
                    let mut debug_trait_builder = f.debug_struct("Number");
                    let _ = debug_trait_builder.field("text", &&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenType::SingleLineComment {
                    comment: ref __self_0,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("SingleLineComment");
                    let _ = debug_trait_builder.field("comment", &&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenType::StringLiteral {
                    literal: ref __self_0,
                    multi_line: ref __self_1,
                    quote_type: ref __self_2,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("StringLiteral");
                    let _ = debug_trait_builder.field("literal", &&(*__self_0));
                    let _ = debug_trait_builder.field("multi_line", &&(*__self_1));
                    let _ = debug_trait_builder.field("quote_type", &&(*__self_2));
                    debug_trait_builder.finish()
                }
                (&TokenType::Symbol {
                    symbol: ref __self_0,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Symbol");
                    let _ = debug_trait_builder.field("symbol", &&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&TokenType::Whitespace {
                    characters: ref __self_0,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Whitespace");
                    let _ = debug_trait_builder.field("characters", &&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::Eq for TokenType<'a> {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
                let _: ::std::cmp::AssertParamIsEq<usize>;
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
                let _: ::std::cmp::AssertParamIsEq<Option<usize>>;
                let _: ::std::cmp::AssertParamIsEq<StringLiteralQuoteType>;
                let _: ::std::cmp::AssertParamIsEq<Symbol>;
                let _: ::std::cmp::AssertParamIsEq<Cow<'a, str>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for TokenType<'a> {
        #[inline]
        fn eq(&self, other: &TokenType<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenType::Identifier {
                                identifier: ref __self_0,
                            },
                            &TokenType::Identifier {
                                identifier: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::MultiLineComment {
                                blocks: ref __self_0,
                                comment: ref __self_1,
                            },
                            &TokenType::MultiLineComment {
                                blocks: ref __arg_1_0,
                                comment: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &TokenType::Number { text: ref __self_0 },
                            &TokenType::Number {
                                text: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::SingleLineComment {
                                comment: ref __self_0,
                            },
                            &TokenType::SingleLineComment {
                                comment: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::StringLiteral {
                                literal: ref __self_0,
                                multi_line: ref __self_1,
                                quote_type: ref __self_2,
                            },
                            &TokenType::StringLiteral {
                                literal: ref __arg_1_0,
                                multi_line: ref __arg_1_1,
                                quote_type: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        (
                            &TokenType::Symbol {
                                symbol: ref __self_0,
                            },
                            &TokenType::Symbol {
                                symbol: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &TokenType::Whitespace {
                                characters: ref __self_0,
                            },
                            &TokenType::Whitespace {
                                characters: ref __arg_1_0,
                            },
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &TokenType<'a>) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &TokenType::Identifier {
                                identifier: ref __self_0,
                            },
                            &TokenType::Identifier {
                                identifier: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::MultiLineComment {
                                blocks: ref __self_0,
                                comment: ref __self_1,
                            },
                            &TokenType::MultiLineComment {
                                blocks: ref __arg_1_0,
                                comment: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &TokenType::Number { text: ref __self_0 },
                            &TokenType::Number {
                                text: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::SingleLineComment {
                                comment: ref __self_0,
                            },
                            &TokenType::SingleLineComment {
                                comment: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::StringLiteral {
                                literal: ref __self_0,
                                multi_line: ref __self_1,
                                quote_type: ref __self_2,
                            },
                            &TokenType::StringLiteral {
                                literal: ref __arg_1_0,
                                multi_line: ref __arg_1_1,
                                quote_type: ref __arg_1_2,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        (
                            &TokenType::Symbol {
                                symbol: ref __self_0,
                            },
                            &TokenType::Symbol {
                                symbol: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &TokenType::Whitespace {
                                characters: ref __self_0,
                            },
                            &TokenType::Whitespace {
                                characters: ref __arg_1_0,
                            },
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_TokenType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for TokenType<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 8",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Eof" => _serde::export::Ok(__Field::__field0),
                            "Identifier" => _serde::export::Ok(__Field::__field1),
                            "MultiLineComment" => _serde::export::Ok(__Field::__field2),
                            "Number" => _serde::export::Ok(__Field::__field3),
                            "SingleLineComment" => _serde::export::Ok(__Field::__field4),
                            "StringLiteral" => _serde::export::Ok(__Field::__field5),
                            "Symbol" => _serde::export::Ok(__Field::__field6),
                            "Whitespace" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Eof" => _serde::export::Ok(__Field::__field0),
                            b"Identifier" => _serde::export::Ok(__Field::__field1),
                            b"MultiLineComment" => _serde::export::Ok(__Field::__field2),
                            b"Number" => _serde::export::Ok(__Field::__field3),
                            b"SingleLineComment" => _serde::export::Ok(__Field::__field4),
                            b"StringLiteral" => _serde::export::Ok(__Field::__field5),
                            b"Symbol" => _serde::export::Ok(__Field::__field6),
                            b"Whitespace" => _serde::export::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Eof",
                    "Identifier",
                    "MultiLineComment",
                    "Number",
                    "SingleLineComment",
                    "StringLiteral",
                    "Symbol",
                    "Whitespace",
                ];
                let __tagged = match _serde::Deserializer::deserialize_any(
                    __deserializer,
                    _serde::private::de::TaggedContentVisitor::<__Field>::new("type"),
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match __tagged.tag {
                    __Field::__field0 => {
                        match _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            _serde::private::de::InternallyTaggedUnitVisitor::new(
                                "TokenType",
                                "Eof",
                            ),
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::export::Ok(TokenType::Eof)
                    }
                    __Field::__field1 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "identifier" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"identifier" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Identifier",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant TokenType::Identifier with 1 element" ) ) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::Identifier {
                                    identifier: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "identifier" ) ) ;
                                            }
                                            __field0 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "identifier",
                                            ),
                                        )
                                    }
                                };
                                _serde::export::Ok(TokenType::Identifier {
                                    identifier: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["identifier"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field2 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    1u64 => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 2",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "blocks" => _serde::export::Ok(__Field::__field0),
                                    "comment" => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"blocks" => _serde::export::Ok(__Field::__field0),
                                    b"comment" => _serde::export::Ok(__Field::__field1),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::MultiLineComment",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    usize,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant TokenType::MultiLineComment with 2 elements" ) ) ;
                                    }
                                };
                                let __field1 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant TokenType::MultiLineComment with 2 elements" ) ) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::MultiLineComment {
                                    blocks: __field0,
                                    comment: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<usize> =
                                    _serde::export::None;
                                let mut __field1: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "blocks" ) ) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<usize>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "comment" ) ) ;
                                            }
                                            __field1 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("blocks") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::export::Some(__field1) => __field1,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "comment",
                                            ),
                                        )
                                    }
                                };
                                _serde::export::Ok(TokenType::MultiLineComment {
                                    blocks: __field0,
                                    comment: __field1,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["blocks", "comment"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field3 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "text" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"text" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Number",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant TokenType::Number with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::export::Ok(TokenType::Number { text: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "text" ) ) ;
                                            }
                                            __field0 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "text",
                                            ),
                                        )
                                    }
                                };
                                _serde::export::Ok(TokenType::Number { text: __field0 })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["text"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field4 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "comment" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"comment" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::SingleLineComment",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant TokenType::SingleLineComment with 1 element" ) ) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::SingleLineComment {
                                    comment: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "comment" ) ) ;
                                            }
                                            __field0 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "comment",
                                            ),
                                        )
                                    }
                                };
                                _serde::export::Ok(TokenType::SingleLineComment {
                                    comment: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["comment"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field5 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    1u64 => _serde::export::Ok(__Field::__field1),
                                    2u64 => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 3",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "literal" => _serde::export::Ok(__Field::__field0),
                                    "multi_line" => _serde::export::Ok(__Field::__field1),
                                    "quote_type" => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"literal" => _serde::export::Ok(__Field::__field0),
                                    b"multi_line" => _serde::export::Ok(__Field::__field1),
                                    b"quote_type" => _serde::export::Ok(__Field::__field2),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::StringLiteral",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant TokenType::StringLiteral with 3 elements" ) ) ;
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<
                                    Option<usize>,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 1usize , & "struct variant TokenType::StringLiteral with 3 elements" ) ) ;
                                    }
                                };
                                let __field2 = match match _serde::de::SeqAccess::next_element::<
                                    StringLiteralQuoteType,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 2usize , & "struct variant TokenType::StringLiteral with 3 elements" ) ) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::StringLiteral {
                                    literal: __field0,
                                    multi_line: __field1,
                                    quote_type: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                let mut __field1: _serde::export::Option<Option<usize>> =
                                    _serde::export::None;
                                let mut __field2: _serde::export::Option<StringLiteralQuoteType> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "literal" ) ) ;
                                            }
                                            __field0 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        __Field::__field1 => {
                                            if _serde::export::Option::is_some(&__field1) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "multi_line" ) ) ;
                                            }
                                            __field1 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    Option<usize>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::export::Option::is_some(&__field2) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "quote_type" ) ) ;
                                            }
                                            __field2 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<
                                                    StringLiteralQuoteType,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "literal",
                                            ),
                                        )
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::export::Some(__field1) => __field1,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("multi_line") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::export::Some(__field2) => __field2,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("quote_type") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::StringLiteral {
                                    literal: __field0,
                                    multi_line: __field1,
                                    quote_type: __field2,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] =
                            &["literal", "multi_line", "quote_type"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field6 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "symbol" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"symbol" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Symbol",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<
                                    Symbol,
                                >(
                                    &mut __seq
                                ) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct variant TokenType::Symbol with 1 element",
                                            ),
                                        );
                                    }
                                };
                                _serde::export::Ok(TokenType::Symbol { symbol: __field0 })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Symbol> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "symbol" ) ) ;
                                            }
                                            __field0 = _serde::export::Some(
                                                match _serde::de::MapAccess::next_value::<Symbol>(
                                                    &mut __map,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        match _serde::private::de::missing_field("symbol") {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::export::Ok(TokenType::Symbol { symbol: __field0 })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["symbol"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                    __Field::__field7 => {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                        _serde::de::Unexpected::Unsigned(__value),
                                        &"field index 0 <= i < 1",
                                    )),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "characters" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::export::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"characters" => _serde::export::Ok(__Field::__field0),
                                    _ => _serde::export::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::export::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de: 'a, 'a> {
                            marker: _serde::export::PhantomData<TokenType<'a>>,
                            lifetime: _serde::export::PhantomData<&'de ()>,
                        }
                        impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                            type Value = TokenType<'a>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::export::Formatter,
                            ) -> _serde::export::fmt::Result {
                                _serde::export::Formatter::write_str(
                                    __formatter,
                                    "struct variant TokenType::Whitespace",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match {
                                    struct __DeserializeWith<'de: 'a, 'a> {
                                        value: Cow<'a, str>,
                                        phantom: _serde::export::PhantomData<TokenType<'a>>,
                                        lifetime: _serde::export::PhantomData<&'de ()>,
                                    }
                                    impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::export::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::export::Ok(__DeserializeWith {
                                                value: match _serde::private::de::borrow_cow_str(
                                                    __deserializer,
                                                ) {
                                                    _serde::export::Ok(__val) => __val,
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                },
                                                phantom: _serde::export::PhantomData,
                                                lifetime: _serde::export::PhantomData,
                                            })
                                        }
                                    }
                                    _serde::export::Option::map(
                                        match _serde::de::SeqAccess::next_element::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __seq)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        |__wrap| __wrap.value,
                                    )
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct variant TokenType::Whitespace with 1 element" ) ) ;
                                    }
                                };
                                _serde::export::Ok(TokenType::Whitespace {
                                    characters: __field0,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::export::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::export::Option<Cow<'a, str>> =
                                    _serde::export::None;
                                while let _serde::export::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::export::Option::is_some(&__field0) {
                                                return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "characters" ) ) ;
                                            }
                                            __field0 = _serde::export::Some({
                                                struct __DeserializeWith<'de: 'a, 'a> {
                                                    value: Cow<'a, str>,
                                                    phantom:
                                                        _serde::export::PhantomData<TokenType<'a>>,
                                                    lifetime: _serde::export::PhantomData<&'de ()>,
                                                }
                                                impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                                    fn deserialize<__D>(
                                                        __deserializer: __D,
                                                    ) -> _serde::export::Result<Self, __D::Error>
                                                    where
                                                        __D: _serde::Deserializer<'de>,
                                                    {
                                                        _serde :: export :: Ok ( __DeserializeWith { value : match _serde :: private :: de :: borrow_cow_str ( __deserializer ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , phantom : _serde :: export :: PhantomData , lifetime : _serde :: export :: PhantomData , } )
                                                    }
                                                }
                                                match _serde::de::MapAccess::next_value::<
                                                    __DeserializeWith<'de, 'a>,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::export::Ok(__wrapper) => {
                                                        __wrapper.value
                                                    }
                                                    _serde::export::Err(__err) => {
                                                        return _serde::export::Err(__err);
                                                    }
                                                }
                                            });
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::export::Some(__field0) => __field0,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::missing_field(
                                                "characters",
                                            ),
                                        )
                                    }
                                };
                                _serde::export::Ok(TokenType::Whitespace {
                                    characters: __field0,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["characters"];
                        _serde::Deserializer::deserialize_any(
                            _serde::private::de::ContentDeserializer::<__D::Error>::new(
                                __tagged.content,
                            ),
                            __Visitor {
                                marker: _serde::export::PhantomData::<TokenType<'a>>,
                                lifetime: _serde::export::PhantomData,
                            },
                        )
                    }
                }
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_TokenType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for TokenType<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    TokenType::Eof => {
                        let mut __struct = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __struct,
                            "type",
                            "Eof",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__struct)
                    }
                    TokenType::Identifier { ref identifier } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Identifier",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "identifier",
                            identifier,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::MultiLineComment {
                        ref blocks,
                        ref comment,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "MultiLineComment",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "blocks",
                            blocks,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "comment",
                            comment,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Number { ref text } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Number",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "text",
                            text,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::SingleLineComment { ref comment } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "SingleLineComment",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "comment",
                            comment,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::StringLiteral {
                        ref literal,
                        ref multi_line,
                        ref quote_type,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + if Option::is_none(multi_line) { 0 } else { 1 } + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "StringLiteral",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "literal",
                            literal,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        if !Option::is_none(multi_line) {
                            match _serde::ser::SerializeStruct::serialize_field(
                                &mut __serde_state,
                                "multi_line",
                                multi_line,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        } else {
                            match _serde::ser::SerializeStruct::skip_field(
                                &mut __serde_state,
                                "multi_line",
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                        }
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "quote_type",
                            quote_type,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Symbol { ref symbol } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Symbol",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "symbol",
                            symbol,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                    TokenType::Whitespace { ref characters } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "TokenType",
                            0 + 1 + 1,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "type",
                            "Whitespace",
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "characters",
                            characters,
                        ) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            }
        }
    };
    impl<'a> TokenType<'a> {
        #[doc = " Returns whether a token can be practically ignored in most cases"]
        #[doc = " Comments and whitespace will return `true`, everything else will return `false`"]
        pub fn ignore(&self) -> bool {
            match self {
                TokenType::SingleLineComment { .. }
                | TokenType::MultiLineComment { .. }
                | TokenType::Whitespace { .. } => true,
                _ => false,
            }
        }
        #[doc = " Returns the [`TokenKind`](enum.TokenKind.html) of the token type."]
        #[doc = ""]
        #[doc = " ```rust"]
        #[doc = " use std::borrow::Cow;"]
        #[doc = " use full_moon::tokenizer::{TokenKind, TokenType};"]
        #[doc = ""]
        #[doc = " assert_eq!("]
        #[doc = "     TokenType::Identifier {"]
        #[doc = "         identifier: Cow::from(\"hello\")"]
        #[doc = "     }.kind(),"]
        #[doc = "     TokenKind::Identifier,"]
        #[doc = " );"]
        #[doc = " ```"]
        pub fn kind(&self) -> TokenKind {
            match self {
                TokenType::Eof => TokenKind::Eof,
                TokenType::Identifier { .. } => TokenKind::Identifier,
                TokenType::MultiLineComment { .. } => TokenKind::MultiLineComment,
                TokenType::Number { .. } => TokenKind::Number,
                TokenType::SingleLineComment { .. } => TokenKind::SingleLineComment,
                TokenType::StringLiteral { .. } => TokenKind::StringLiteral,
                TokenType::Symbol { .. } => TokenKind::Symbol,
                TokenType::Whitespace { .. } => TokenKind::Whitespace,
            }
        }
    }
    #[doc = " The kind of token. Contains no additional data."]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum TokenKind {
        #[doc = " End of file, should always be the very last token"]
        Eof,
        #[doc = " An identifier, such as `foo`"]
        Identifier,
        #[doc = " A multi line comment in the format of --[[ comment ]]"]
        MultiLineComment,
        #[doc = " A literal number, such as `3.3`"]
        Number,
        #[doc = " A single line comment, such as `-- comment`"]
        SingleLineComment,
        #[doc = " A literal string, such as \"Hello, world\""]
        StringLiteral,
        #[doc = " A [`Symbol`](enum.Symbol.html), such as `local` or `+`"]
        Symbol,
        #[doc = " Whitespace, such as tabs or new lines"]
        Whitespace,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TokenKind {
        #[inline]
        fn clone(&self) -> TokenKind {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for TokenKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TokenKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&TokenKind::Eof,) => {
                    let mut debug_trait_builder = f.debug_tuple("Eof");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Identifier,) => {
                    let mut debug_trait_builder = f.debug_tuple("Identifier");
                    debug_trait_builder.finish()
                }
                (&TokenKind::MultiLineComment,) => {
                    let mut debug_trait_builder = f.debug_tuple("MultiLineComment");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Number,) => {
                    let mut debug_trait_builder = f.debug_tuple("Number");
                    debug_trait_builder.finish()
                }
                (&TokenKind::SingleLineComment,) => {
                    let mut debug_trait_builder = f.debug_tuple("SingleLineComment");
                    debug_trait_builder.finish()
                }
                (&TokenKind::StringLiteral,) => {
                    let mut debug_trait_builder = f.debug_tuple("StringLiteral");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Symbol,) => {
                    let mut debug_trait_builder = f.debug_tuple("Symbol");
                    debug_trait_builder.finish()
                }
                (&TokenKind::Whitespace,) => {
                    let mut debug_trait_builder = f.debug_tuple("Whitespace");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for TokenKind {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TokenKind {
        #[inline]
        fn eq(&self, other: &TokenKind) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[doc = " A token such consisting of its [`Position`](struct.Position.html) and a [`TokenType`](enum.TokenType.html)"]
    pub struct Token<'a> {
        #[serde(with = "serde_arc_atomic_cell")]
        pub(crate) start_position: Arc<AtomicCell<Position>>,
        #[serde(with = "serde_arc_atomic_cell")]
        pub(crate) end_position: Arc<AtomicCell<Position>>,
        #[serde(borrow)]
        #[serde(with = "serde_arc_atomic_refcell")]
        pub(crate) token_type: Arc<AtomicRefCell<TokenType<'a>>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for Token<'a> {
        #[inline]
        fn clone(&self) -> Token<'a> {
            match *self {
                Token {
                    start_position: ref __self_0_0,
                    end_position: ref __self_0_1,
                    token_type: ref __self_0_2,
                } => Token {
                    start_position: ::std::clone::Clone::clone(&(*__self_0_0)),
                    end_position: ::std::clone::Clone::clone(&(*__self_0_1)),
                    token_type: ::std::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for Token<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Token {
                    start_position: ref __self_0_0,
                    end_position: ref __self_0_1,
                    token_type: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Token");
                    let _ = debug_trait_builder.field("start_position", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("end_position", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("token_type", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Token: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de: 'a, 'a> _serde::Deserialize<'de> for Token<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "start_position" => _serde::export::Ok(__Field::__field0),
                            "end_position" => _serde::export::Ok(__Field::__field1),
                            "token_type" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"start_position" => _serde::export::Ok(__Field::__field0),
                            b"end_position" => _serde::export::Ok(__Field::__field1),
                            b"token_type" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de: 'a, 'a> {
                    marker: _serde::export::PhantomData<Token<'a>>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de: 'a, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Token<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Token")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match {
                            struct __DeserializeWith<'de: 'a, 'a> {
                                value: Arc<AtomicCell<Position>>,
                                phantom: _serde::export::PhantomData<Token<'a>>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::export::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::export::Ok(__DeserializeWith {
                                        value: match serde_arc_atomic_cell::deserialize(
                                            __deserializer,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        phantom: _serde::export::PhantomData,
                                        lifetime: _serde::export::PhantomData,
                                    })
                                }
                            }
                            _serde::export::Option::map(
                                match _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de, 'a>,
                                >(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Token with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match {
                            struct __DeserializeWith<'de: 'a, 'a> {
                                value: Arc<AtomicCell<Position>>,
                                phantom: _serde::export::PhantomData<Token<'a>>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::export::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::export::Ok(__DeserializeWith {
                                        value: match serde_arc_atomic_cell::deserialize(
                                            __deserializer,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        phantom: _serde::export::PhantomData,
                                        lifetime: _serde::export::PhantomData,
                                    })
                                }
                            }
                            _serde::export::Option::map(
                                match _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de, 'a>,
                                >(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Token with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match {
                            struct __DeserializeWith<'de: 'a, 'a> {
                                value: Arc<AtomicRefCell<TokenType<'a>>>,
                                phantom: _serde::export::PhantomData<Token<'a>>,
                                lifetime: _serde::export::PhantomData<&'de ()>,
                            }
                            impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::export::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::export::Ok(__DeserializeWith {
                                        value: match serde_arc_atomic_refcell::deserialize(
                                            __deserializer,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                        phantom: _serde::export::PhantomData,
                                        lifetime: _serde::export::PhantomData,
                                    })
                                }
                            }
                            _serde::export::Option::map(
                                match _serde::de::SeqAccess::next_element::<
                                    __DeserializeWith<'de, 'a>,
                                >(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                },
                                |__wrap| __wrap.value,
                            )
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Token with 3 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Token {
                            start_position: __field0,
                            end_position: __field1,
                            token_type: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Arc<AtomicCell<Position>>> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Arc<AtomicCell<Position>>> =
                            _serde::export::None;
                        let mut __field2: _serde::export::Option<
                            Arc<AtomicRefCell<TokenType<'a>>>,
                        > = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "start_position",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some({
                                        struct __DeserializeWith<'de: 'a, 'a> {
                                            value: Arc<AtomicCell<Position>>,
                                            phantom: _serde::export::PhantomData<Token<'a>>,
                                            lifetime: _serde::export::PhantomData<&'de ()>,
                                        }
                                        impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::export::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::export::Ok(__DeserializeWith {
                                                    value: match serde_arc_atomic_cell::deserialize(
                                                        __deserializer,
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::export::PhantomData,
                                                    lifetime: _serde::export::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__wrapper) => __wrapper.value,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "end_position",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some({
                                        struct __DeserializeWith<'de: 'a, 'a> {
                                            value: Arc<AtomicCell<Position>>,
                                            phantom: _serde::export::PhantomData<Token<'a>>,
                                            lifetime: _serde::export::PhantomData<&'de ()>,
                                        }
                                        impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::export::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::export::Ok(__DeserializeWith {
                                                    value: match serde_arc_atomic_cell::deserialize(
                                                        __deserializer,
                                                    ) {
                                                        _serde::export::Ok(__val) => __val,
                                                        _serde::export::Err(__err) => {
                                                            return _serde::export::Err(__err);
                                                        }
                                                    },
                                                    phantom: _serde::export::PhantomData,
                                                    lifetime: _serde::export::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__wrapper) => __wrapper.value,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    });
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "token_type",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some({
                                        struct __DeserializeWith<'de: 'a, 'a> {
                                            value: Arc<AtomicRefCell<TokenType<'a>>>,
                                            phantom: _serde::export::PhantomData<Token<'a>>,
                                            lifetime: _serde::export::PhantomData<&'de ()>,
                                        }
                                        impl<'de: 'a, 'a> _serde::Deserialize<'de> for __DeserializeWith<'de, 'a> {
                                            fn deserialize<__D>(
                                                __deserializer: __D,
                                            ) -> _serde::export::Result<Self, __D::Error>
                                            where
                                                __D: _serde::Deserializer<'de>,
                                            {
                                                _serde::export::Ok(__DeserializeWith {
                                                    value:
                                                        match serde_arc_atomic_refcell::deserialize(
                                                            __deserializer,
                                                        ) {
                                                            _serde::export::Ok(__val) => __val,
                                                            _serde::export::Err(__err) => {
                                                                return _serde::export::Err(__err);
                                                            }
                                                        },
                                                    phantom: _serde::export::PhantomData,
                                                    lifetime: _serde::export::PhantomData,
                                                })
                                            }
                                        }
                                        match _serde::de::MapAccess::next_value::<
                                            __DeserializeWith<'de, 'a>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__wrapper) => __wrapper.value,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        }
                                    });
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                return _serde::export::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "start_position",
                                    ),
                                )
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                return _serde::export::Err(
                                    <__A::Error as _serde::de::Error>::missing_field(
                                        "end_position",
                                    ),
                                )
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                return _serde::export::Err(
                                    <__A::Error as _serde::de::Error>::missing_field("token_type"),
                                )
                            }
                        };
                        _serde::export::Ok(Token {
                            start_position: __field0,
                            end_position: __field1,
                            token_type: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] =
                    &["start_position", "end_position", "token_type"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Token",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Token<'a>>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Token: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Token<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Token",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "start_position",
                    {
                        struct __SerializeWith<'__a, 'a: '__a> {
                            values: (&'__a Arc<AtomicCell<Position>>,),
                            phantom: _serde::export::PhantomData<Token<'a>>,
                        }
                        impl<'__a, 'a: '__a> _serde::Serialize for __SerializeWith<'__a, 'a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::export::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                serde_arc_atomic_cell::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.start_position,),
                            phantom: _serde::export::PhantomData::<Token<'a>>,
                        }
                    },
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "end_position",
                    {
                        struct __SerializeWith<'__a, 'a: '__a> {
                            values: (&'__a Arc<AtomicCell<Position>>,),
                            phantom: _serde::export::PhantomData<Token<'a>>,
                        }
                        impl<'__a, 'a: '__a> _serde::Serialize for __SerializeWith<'__a, 'a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::export::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                serde_arc_atomic_cell::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.end_position,),
                            phantom: _serde::export::PhantomData::<Token<'a>>,
                        }
                    },
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "token_type",
                    {
                        struct __SerializeWith<'__a, 'a: '__a> {
                            values: (&'__a Arc<AtomicRefCell<TokenType<'a>>>,),
                            phantom: _serde::export::PhantomData<Token<'a>>,
                        }
                        impl<'__a, 'a: '__a> _serde::Serialize for __SerializeWith<'__a, 'a> {
                            fn serialize<__S>(
                                &self,
                                __s: __S,
                            ) -> _serde::export::Result<__S::Ok, __S::Error>
                            where
                                __S: _serde::Serializer,
                            {
                                serde_arc_atomic_refcell::serialize(self.values.0, __s)
                            }
                        }
                        &__SerializeWith {
                            values: (&self.token_type,),
                            phantom: _serde::export::PhantomData::<Token<'a>>,
                        }
                    },
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl<'a> Token<'a> {
        #[doc = " The position a token begins at"]
        pub fn start_position(&self) -> Position {
            self.start_position.load()
        }
        #[doc = " The position a token ends at"]
        pub fn end_position(&self) -> Position {
            self.end_position.load()
        }
        #[doc = " The [type](enum.TokenType.html) of token as well as the data needed to represent it"]
        #[doc = " If you don't need any other information, use [`token_kind`](#method.token_kind) instead."]
        pub fn token_type(&self) -> atomic_refcell::AtomicRef<TokenType<'a>> {
            self.token_type.borrow()
        }
        #[doc = " The [kind](enum.TokenKind.html) of token with no additional data."]
        #[doc = " If you need any information such as idenitfier names, use [`token_type`](#method.token_type) instead."]
        pub fn token_kind(&self) -> TokenKind {
            self.token_type().kind()
        }
    }
    impl<'a> fmt::Display for Token<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            use self::TokenType::*;
            match &*self.token_type() {
                Eof => "".to_string(),
                Number { text } => text.to_string(),
                Identifier { identifier } => identifier.to_string(),
                MultiLineComment { blocks, comment } => {
                    ::alloc::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                        &["--[", "[", "]", "]"],
                        &match (&"=".repeat(*blocks), &comment) {
                            (arg0, arg1) => [
                                ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                            ],
                        },
                        &[
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(0usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(1usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(0usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ))
                }
                SingleLineComment { comment } => {
                    ::alloc::fmt::format(::std::fmt::Arguments::new_v1(
                        &["--"],
                        &match (&comment,) {
                            (arg0,) => {
                                [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)]
                            }
                        },
                    ))
                }
                StringLiteral {
                    literal,
                    multi_line,
                    quote_type,
                } => {
                    if let Some(blocks) = multi_line {
                        ::alloc::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                            &["[", "[", "]", "]"],
                            &match (&"=".repeat(*blocks), &literal.to_string()) {
                                (arg0, arg1) => [
                                    ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                    ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                ],
                            },
                            &[
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(1usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                            ],
                        ))
                    } else {
                        ::alloc::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                            &["", "", ""],
                            &match (&quote_type.to_string(), &literal.to_string()) {
                                (arg0, arg1) => [
                                    ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                    ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                ],
                            },
                            &[
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(1usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                            ],
                        ))
                    }
                }
                Symbol { symbol } => symbol.to_string(),
                Whitespace { characters } => characters.to_string(),
            }
            .fmt(formatter)
        }
    }
    impl<'a> PartialEq<Self> for Token<'a> {
        fn eq(&self, rhs: &Self) -> bool {
            self.start_position() == rhs.start_position()
                && self.end_position() == rhs.end_position()
                && self.token_type == rhs.token_type
        }
    }
    impl<'a> Eq for Token<'a> {}
    impl<'a> Ord for Token<'a> {
        fn cmp(&self, other: &Self) -> Ordering {
            self.start_position().cmp(&other.start_position())
        }
    }
    impl<'a> PartialOrd for Token<'a> {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    #[doc = " A reference to a token used by Ast's."]
    #[doc = " Dereferences to a [`Token`](struct.Token.html)"]
    pub enum TokenReference<'a> {
        #[doc = " Token is borrowed from an Ast's arena"]
        #[doc(hidden)]
        Borrowed {
            arena: Arc<Arena<Token<'a>>>,
            index: Index,
        },
        #[doc = " Token reference was manually created, likely through deserialization"]
        #[doc(hidden)]
        Owned(Token<'a>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for TokenReference<'a> {
        #[inline]
        fn clone(&self) -> TokenReference<'a> {
            match (&*self,) {
                (&TokenReference::Borrowed {
                    arena: ref __self_0,
                    index: ref __self_1,
                },) => TokenReference::Borrowed {
                    arena: ::std::clone::Clone::clone(&(*__self_0)),
                    index: ::std::clone::Clone::clone(&(*__self_1)),
                },
                (&TokenReference::Owned(ref __self_0),) => {
                    TokenReference::Owned(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<'a> TokenReference<'a> {
        #[doc = " Sets the type of token. Note that positions will not update after using this function."]
        #[doc = " If you need them to, call [`Ast::update_positions`](../ast/struct.Ast.html#method.update_positions)"]
        pub fn set_token_type(&mut self, new_token_type: TokenType<'a>) {
            *self.token_type.borrow_mut() = new_token_type;
        }
    }
    impl<'a> std::ops::Deref for TokenReference<'a> {
        type Target = Token<'a>;
        fn deref(&self) -> &Self::Target {
            match self {
                TokenReference::Borrowed { arena, index } => {
                    arena.get(*index).expect("arena doesn\'t have index?")
                }
                TokenReference::Owned(token) => &token,
            }
        }
    }
    impl<'a> fmt::Debug for TokenReference<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_fmt(::std::fmt::Arguments::new_v1(
                &["TokenReference { ", " }"],
                &match (&**self,) {
                    (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                },
            ))
        }
    }
    impl<'a> fmt::Display for TokenReference<'a> {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            (**self).fmt(formatter)
        }
    }
    impl<'a> PartialEq<Self> for TokenReference<'a> {
        fn eq(&self, other: &Self) -> bool {
            (**self).eq(other)
        }
    }
    impl<'a> Eq for TokenReference<'a> {}
    impl<'a> Ord for TokenReference<'a> {
        fn cmp(&self, other: &Self) -> Ordering {
            (**self).cmp(&**other)
        }
    }
    impl<'a> PartialOrd for TokenReference<'a> {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    #[cfg(feature = "serde")]
    impl<'a> Serialize for TokenReference<'a> {
        fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            (**self).serialize(serializer)
        }
    }
    #[cfg(feature = "serde")]
    impl<'de: 'a, 'a> Deserialize<'de> for TokenReference<'a> {
        fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
            Ok(TokenReference::Owned(Token::deserialize(deserializer)?))
        }
    }
    impl<'ast> Visit<'ast> for TokenReference<'ast> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            match self.token_kind() {
                TokenKind::Eof => visitor.visit_eof(self),
                TokenKind::Identifier => visitor.visit_identifier(self),
                TokenKind::MultiLineComment => visitor.visit_multi_line_comment(self),
                TokenKind::Number => visitor.visit_number(self),
                TokenKind::SingleLineComment => visitor.visit_single_line_comment(self),
                TokenKind::StringLiteral => visitor.visit_string_literal(self),
                TokenKind::Symbol => visitor.visit_symbol(self),
                TokenKind::Whitespace => visitor.visit_whitespace(self),
            }
        }
    }
    impl<'ast> VisitMut<'ast> for TokenReference<'ast> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            match self.token_kind() {
                TokenKind::Eof => visitor.visit_eof(self),
                TokenKind::Identifier => visitor.visit_identifier(self),
                TokenKind::MultiLineComment => visitor.visit_multi_line_comment(self),
                TokenKind::Number => visitor.visit_number(self),
                TokenKind::SingleLineComment => visitor.visit_single_line_comment(self),
                TokenKind::StringLiteral => visitor.visit_string_literal(self),
                TokenKind::Symbol => visitor.visit_symbol(self),
                TokenKind::Whitespace => visitor.visit_whitespace(self),
            }
        }
    }
    #[doc = " Used to represent exact positions of tokens in code"]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct Position {
        pub(crate) bytes: usize,
        pub(crate) character: usize,
        pub(crate) line: usize,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Position {
        #[inline]
        fn clone(&self) -> Position {
            {
                let _: ::std::clone::AssertParamIsClone<usize>;
                let _: ::std::clone::AssertParamIsClone<usize>;
                let _: ::std::clone::AssertParamIsClone<usize>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Position {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Position {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Position {
                    bytes: ref __self_0_0,
                    character: ref __self_0_1,
                    line: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Position");
                    let _ = debug_trait_builder.field("bytes", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("character", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("line", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for Position {
        #[inline]
        fn default() -> Position {
            Position {
                bytes: ::std::default::Default::default(),
                character: ::std::default::Default::default(),
                line: ::std::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Position {
        #[inline]
        fn eq(&self, other: &Position) -> bool {
            match *other {
                Position {
                    bytes: ref __self_1_0,
                    character: ref __self_1_1,
                    line: ref __self_1_2,
                } => match *self {
                    Position {
                        bytes: ref __self_0_0,
                        character: ref __self_0_1,
                        line: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Position) -> bool {
            match *other {
                Position {
                    bytes: ref __self_1_0,
                    character: ref __self_1_1,
                    line: ref __self_1_2,
                } => match *self {
                    Position {
                        bytes: ref __self_0_0,
                        character: ref __self_0_1,
                        line: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Position {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<usize>;
                let _: ::std::cmp::AssertParamIsEq<usize>;
                let _: ::std::cmp::AssertParamIsEq<usize>;
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_Position: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Position {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "bytes" => _serde::export::Ok(__Field::__field0),
                            "character" => _serde::export::Ok(__Field::__field1),
                            "line" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"bytes" => _serde::export::Ok(__Field::__field0),
                            b"character" => _serde::export::Ok(__Field::__field1),
                            b"line" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Position>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Position;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Position")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<usize>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Position with 3 elements",
                                    ));
                                }
                            };
                        _serde::export::Ok(Position {
                            bytes: __field0,
                            character: __field1,
                            line: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<usize> = _serde::export::None;
                        let mut __field1: _serde::export::Option<usize> = _serde::export::None;
                        let mut __field2: _serde::export::Option<usize> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "bytes",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "character",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "line",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<usize>(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("bytes") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("character") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("line") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Position {
                            bytes: __field0,
                            character: __field1,
                            line: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["bytes", "character", "line"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Position",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Position>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_Position: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Position {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Position",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "bytes",
                    &self.bytes,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "character",
                    &self.character,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "line",
                    &self.line,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl Position {
        #[doc = " How many bytes, ignoring lines, it would take to find this position"]
        pub fn bytes(self) -> usize {
            self.bytes
        }
        #[doc = " Index of the character on the line for this position"]
        pub fn character(self) -> usize {
            self.character
        }
        #[doc = " Line the position lies on"]
        pub fn line(self) -> usize {
            self.line
        }
    }
    impl Ord for Position {
        fn cmp(&self, other: &Self) -> Ordering {
            self.bytes.cmp(&other.bytes)
        }
    }
    impl PartialOrd for Position {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }
    struct TokenAdvancement<'a> {
        pub advance: usize,
        pub token_type: TokenType<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::clone::Clone for TokenAdvancement<'a> {
        #[inline]
        fn clone(&self) -> TokenAdvancement<'a> {
            match *self {
                TokenAdvancement {
                    advance: ref __self_0_0,
                    token_type: ref __self_0_1,
                } => TokenAdvancement {
                    advance: ::std::clone::Clone::clone(&(*__self_0_0)),
                    token_type: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for TokenAdvancement<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TokenAdvancement {
                    advance: ref __self_0_0,
                    token_type: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("TokenAdvancement");
                    let _ = debug_trait_builder.field("advance", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("token_type", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for TokenAdvancement<'a> {
        #[inline]
        fn eq(&self, other: &TokenAdvancement<'a>) -> bool {
            match *other {
                TokenAdvancement {
                    advance: ref __self_1_0,
                    token_type: ref __self_1_1,
                } => match *self {
                    TokenAdvancement {
                        advance: ref __self_0_0,
                        token_type: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenAdvancement<'a>) -> bool {
            match *other {
                TokenAdvancement {
                    advance: ref __self_1_0,
                    token_type: ref __self_1_1,
                } => match *self {
                    TokenAdvancement {
                        advance: ref __self_0_0,
                        token_type: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[doc = " The types of quotes used in a Lua string"]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum StringLiteralQuoteType {
        #[doc = " Strings formatted \\[\\[with brackets\\]\\]"]
        Brackets,
        #[doc = " Strings formatted \"with double quotes\""]
        Double,
        #[doc = " Strings formatted 'with single quotes'"]
        Single,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StringLiteralQuoteType {
        #[inline]
        fn clone(&self) -> StringLiteralQuoteType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for StringLiteralQuoteType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StringLiteralQuoteType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&StringLiteralQuoteType::Brackets,) => {
                    let mut debug_trait_builder = f.debug_tuple("Brackets");
                    debug_trait_builder.finish()
                }
                (&StringLiteralQuoteType::Double,) => {
                    let mut debug_trait_builder = f.debug_tuple("Double");
                    debug_trait_builder.finish()
                }
                (&StringLiteralQuoteType::Single,) => {
                    let mut debug_trait_builder = f.debug_tuple("Single");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for StringLiteralQuoteType {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StringLiteralQuoteType {
        #[inline]
        fn eq(&self, other: &StringLiteralQuoteType) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_StringLiteralQuoteType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for StringLiteralQuoteType {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Brackets" => _serde::export::Ok(__Field::__field0),
                            "Double" => _serde::export::Ok(__Field::__field1),
                            "Single" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Brackets" => _serde::export::Ok(__Field::__field0),
                            b"Double" => _serde::export::Ok(__Field::__field1),
                            b"Single" => _serde::export::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<StringLiteralQuoteType>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = StringLiteralQuoteType;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(
                            __formatter,
                            "enum StringLiteralQuoteType",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Brackets)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Double)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(StringLiteralQuoteType::Single)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Brackets", "Double", "Single"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "StringLiteralQuoteType",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<StringLiteralQuoteType>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_StringLiteralQuoteType: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for StringLiteralQuoteType {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    StringLiteralQuoteType::Brackets => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        0u32,
                        "Brackets",
                    ),
                    StringLiteralQuoteType::Double => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        1u32,
                        "Double",
                    ),
                    StringLiteralQuoteType::Single => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "StringLiteralQuoteType",
                        2u32,
                        "Single",
                    ),
                }
            }
        }
    };
    impl<'a> fmt::Display for StringLiteralQuoteType {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            match *self {
                StringLiteralQuoteType::Brackets => ::std::rt::begin_panic(
                    "internal error: entered unreachable code",
                    &("src/tokenizer.rs", 511u32, 49u32),
                ),
                StringLiteralQuoteType::Double => "\"",
                StringLiteralQuoteType::Single => "\'",
            }
            .fmt(formatter)
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_IDENTIFIER {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_IDENTIFIER: PATTERN_IDENTIFIER = PATTERN_IDENTIFIER {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for PATTERN_IDENTIFIER {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"[^\W\d]+\w*").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_IDENTIFIER {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_NUMBER {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_NUMBER: PATTERN_NUMBER = PATTERN_NUMBER {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for PATTERN_NUMBER {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"^((-?0x[A-Fa-f\d]+)|(-?((\d*\.\d+)|(\d+))([eE]-?\d+)?))").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_NUMBER {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_COMMENT_MULTI_LINE_BEGIN {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_COMMENT_MULTI_LINE_BEGIN: PATTERN_COMMENT_MULTI_LINE_BEGIN =
        PATTERN_COMMENT_MULTI_LINE_BEGIN {
            __private_field: (),
        };
    impl ::lazy_static::__Deref for PATTERN_COMMENT_MULTI_LINE_BEGIN {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"--\[(=*)\[").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_COMMENT_MULTI_LINE_BEGIN {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_COMMENT_SINGLE_LINE {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_COMMENT_SINGLE_LINE: PATTERN_COMMENT_SINGLE_LINE = PATTERN_COMMENT_SINGLE_LINE {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for PATTERN_COMMENT_SINGLE_LINE {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"--([^\n]*)").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_COMMENT_SINGLE_LINE {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_STRING_MULTI_LINE_BEGIN {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_STRING_MULTI_LINE_BEGIN: PATTERN_STRING_MULTI_LINE_BEGIN =
        PATTERN_STRING_MULTI_LINE_BEGIN {
            __private_field: (),
        };
    impl ::lazy_static::__Deref for PATTERN_STRING_MULTI_LINE_BEGIN {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"\[(=*)\[").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_STRING_MULTI_LINE_BEGIN {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct PATTERN_WHITESPACE {
        __private_field: (),
    }
    #[doc(hidden)]
    static PATTERN_WHITESPACE: PATTERN_WHITESPACE = PATTERN_WHITESPACE {
        __private_field: (),
    };
    impl ::lazy_static::__Deref for PATTERN_WHITESPACE {
        type Target = Regex;
        fn deref(&self) -> &Regex {
            #[inline(always)]
            fn __static_ref_initialize() -> Regex {
                Regex::new(r"(^[^\S\n]+\n?|\n)").unwrap()
            }
            #[inline(always)]
            fn __stability() -> &'static Regex {
                static LAZY: ::lazy_static::lazy::Lazy<Regex> = ::lazy_static::lazy::Lazy::INIT;
                LAZY.get(__static_ref_initialize)
            }
            __stability()
        }
    }
    impl ::lazy_static::LazyStatic for PATTERN_WHITESPACE {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    type Advancement<'a> = Result<Option<TokenAdvancement<'a>>, TokenizerErrorType>;
    fn advance_comment(code: &str) -> Advancement {
        if let Some(captures) = PATTERN_COMMENT_MULTI_LINE_BEGIN.captures(code) {
            let whole_beginning = captures.get(0).unwrap();
            if whole_beginning.start() == 0 {
                let block_count = match captures.get(1) {
                    Some(block_count) => block_count.end() - block_count.start(),
                    None => 0,
                };
                let end_regex = Regex::new(&::alloc::fmt::format(::std::fmt::Arguments::new_v1(
                    &["\\]={", "}\\]"],
                    &match (&block_count,) {
                        (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                    },
                )))
                .unwrap();
                let end_find = match end_regex.find(code) {
                    Some(find) => find,
                    None => return Err(TokenizerErrorType::UnclosedComment),
                };
                return Ok(Some(TokenAdvancement {
                    advance: end_find.end(),
                    token_type: TokenType::MultiLineComment {
                        blocks: block_count,
                        comment: Cow::from(&code[whole_beginning.end()..end_find.start()]),
                    },
                }));
            }
        }
        if let Some(find) = PATTERN_COMMENT_SINGLE_LINE.find(code) {
            if find.start() == 0 {
                return Ok(Some(TokenAdvancement {
                    advance: find.end(),
                    token_type: TokenType::SingleLineComment {
                        comment: Cow::from(&find.as_str()[2..]),
                    },
                }));
            }
        }
        Ok(None)
    }
    fn advance_number(code: &str) -> Advancement {
        if let Some(find) = PATTERN_NUMBER.find(code) {
            if find.start() != 0 {
                Ok(None)
            } else {
                Ok(Some(TokenAdvancement {
                    advance: find.end() - find.start(),
                    token_type: TokenType::Number {
                        text: Cow::from(find.as_str()),
                    },
                }))
            }
        } else {
            Ok(None)
        }
    }
    fn advance_identifier(code: &str) -> Advancement {
        if let Some(find) = PATTERN_IDENTIFIER.find(code) {
            if find.start() != 0 {
                Ok(None)
            } else {
                Ok(Some(TokenAdvancement {
                    advance: find.end() - find.start(),
                    token_type: TokenType::Identifier {
                        identifier: Cow::from(find.as_str()),
                    },
                }))
            }
        } else {
            Ok(None)
        }
    }
    fn advance_quote(code: &str) -> Advancement {
        if let Some(captures) = PATTERN_STRING_MULTI_LINE_BEGIN.captures(code) {
            let whole_beginning = captures.get(0).unwrap();
            if whole_beginning.start() == 0 {
                let block_count = match captures.get(1) {
                    Some(block_count) => block_count.end() - block_count.start(),
                    None => 0,
                };
                let end_regex = Regex::new(&::alloc::fmt::format(::std::fmt::Arguments::new_v1(
                    &["\\]={", "}\\]"],
                    &match (&block_count,) {
                        (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                    },
                )))
                .unwrap();
                let end_find = match end_regex.find(code) {
                    Some(find) => find,
                    None => return Err(TokenizerErrorType::UnclosedString),
                };
                return Ok(Some(TokenAdvancement {
                    advance: end_find.end(),
                    token_type: TokenType::StringLiteral {
                        multi_line: Some(block_count),
                        literal: Cow::from(&code[whole_beginning.end()..end_find.start()]),
                        quote_type: StringLiteralQuoteType::Brackets,
                    },
                }));
            }
        }
        let quote = if code.starts_with('\"') {
            '\"'
        } else if code.starts_with('\'') {
            '\''
        } else {
            return Ok(None);
        };
        let mut end = None;
        let mut escape = false;
        for (index, character) in code.char_indices().skip(1) {
            if character == '\\' {
                escape = !escape;
            } else if character == quote {
                if escape {
                    escape = false;
                } else {
                    end = Some(index);
                    break;
                }
            } else if character == '\r' || character == '\n' {
                return Err(TokenizerErrorType::UnclosedString);
            } else {
                escape = false;
            }
        }
        if let Some(end) = end {
            Ok(Some(TokenAdvancement {
                advance: end + 1,
                token_type: TokenType::StringLiteral {
                    literal: Cow::from(&code[1..end]),
                    multi_line: None,
                    quote_type: match quote {
                        '\"' => StringLiteralQuoteType::Double,
                        '\'' => StringLiteralQuoteType::Single,
                        _ => ::std::rt::begin_panic(
                            "internal error: entered unreachable code",
                            &("src/tokenizer.rs", 664u32, 26u32),
                        ),
                    },
                },
            }))
        } else {
            return Err(TokenizerErrorType::UnclosedString);
        }
    }
    fn advance_symbol(code: &str) -> Advancement {
        if code.chars().next().unwrap().is_alphanumeric() {
            let identifier = PATTERN_IDENTIFIER.find(code).unwrap();
            let expected_len = identifier.end() - identifier.start();
            if let Some(find) = PATTERN_SYMBOL.find(&code[0..expected_len]) {
                if find.start() != 0 {
                    Ok(None)
                } else {
                    Ok(Some(TokenAdvancement {
                        advance: find.end() - find.start(),
                        token_type: TokenType::Symbol {
                            symbol: {
                                if find.end() - find.start() == expected_len {
                                    Symbol::from_str(find.as_str()).unwrap()
                                } else {
                                    return Ok(None);
                                }
                            },
                        },
                    }))
                }
            } else {
                Ok(None)
            }
        } else {
            if let Some(find) = PATTERN_SYMBOL.find(code) {
                if find.start() != 0 {
                    Ok(None)
                } else {
                    Ok(Some(TokenAdvancement {
                        advance: find.end() - find.start(),
                        token_type: TokenType::Symbol {
                            symbol: Symbol::from_str(find.as_str()).unwrap(),
                        },
                    }))
                }
            } else {
                Ok(None)
            }
        }
    }
    fn advance_whitespace(code: &str) -> Advancement {
        if let Some(find) = PATTERN_WHITESPACE.find(code) {
            if find.start() != 0 {
                Ok(None)
            } else {
                Ok(Some(TokenAdvancement {
                    advance: find.end() - find.start(),
                    token_type: TokenType::Whitespace {
                        characters: Cow::from(find.as_str()),
                    },
                }))
            }
        } else {
            Ok(None)
        }
    }
    #[doc = " Information about an error that occurs while tokenizing"]
    pub struct TokenizerError {
        #[doc = " The type of error"]
        error: TokenizerErrorType,
        #[doc = " The position of the token that caused the error"]
        position: Position,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TokenizerError {
        #[inline]
        fn clone(&self) -> TokenizerError {
            match *self {
                TokenizerError {
                    error: ref __self_0_0,
                    position: ref __self_0_1,
                } => TokenizerError {
                    error: ::std::clone::Clone::clone(&(*__self_0_0)),
                    position: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TokenizerError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TokenizerError {
                    error: ref __self_0_0,
                    position: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("TokenizerError");
                    let _ = debug_trait_builder.field("error", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("position", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TokenizerError {
        #[inline]
        fn eq(&self, other: &TokenizerError) -> bool {
            match *other {
                TokenizerError {
                    error: ref __self_1_0,
                    position: ref __self_1_1,
                } => match *self {
                    TokenizerError {
                        error: ref __self_0_0,
                        position: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TokenizerError) -> bool {
            match *other {
                TokenizerError {
                    error: ref __self_1_0,
                    position: ref __self_1_1,
                } => match *self {
                    TokenizerError {
                        error: ref __self_0_0,
                        position: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_DESERIALIZE_FOR_TokenizerError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for TokenizerError {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "error" => _serde::export::Ok(__Field::__field0),
                            "position" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"error" => _serde::export::Ok(__Field::__field0),
                            b"position" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<TokenizerError>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = TokenizerError;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct TokenizerError")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            TokenizerErrorType,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct TokenizerError with 2 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Position>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct TokenizerError with 2 elements",
                                    ));
                                }
                            };
                        _serde::export::Ok(TokenizerError {
                            error: __field0,
                            position: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<TokenizerErrorType> =
                            _serde::export::None;
                        let mut __field1: _serde::export::Option<Position> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "error",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<TokenizerErrorType>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "position",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Position>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("error") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("position") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(TokenizerError {
                            error: __field0,
                            position: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["error", "position"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "TokenizerError",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<TokenizerError>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _IMPL_SERIALIZE_FOR_TokenizerError: () = {
        #[allow(unknown_lints)]
        #[allow(rust_2018_idioms)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for TokenizerError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "TokenizerError",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "error",
                    &self.error,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "position",
                    &self.position,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    impl fmt::Display for TokenizerError {
        fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
            formatter.write_fmt(::std::fmt::Arguments::new_v1(
                &["", " at line ", ", column "],
                &match (
                    &match self.error {
                        TokenizerErrorType::UnclosedComment => "unclosed comment".to_string(),
                        TokenizerErrorType::UnclosedString => "unclosed string".to_string(),
                        TokenizerErrorType::UnexpectedToken(character) => {
                            ::alloc::fmt::format(::std::fmt::Arguments::new_v1(
                                &["unexpected character "],
                                &match (&character,) {
                                    (arg0,) => [::std::fmt::ArgumentV1::new(
                                        arg0,
                                        ::std::fmt::Display::fmt,
                                    )],
                                },
                            ))
                        }
                    },
                    &self.position.line,
                    &self.position.character,
                ) {
                    (arg0, arg1, arg2) => [
                        ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                        ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                        ::std::fmt::ArgumentV1::new(arg2, ::std::fmt::Display::fmt),
                    ],
                },
            ))
        }
    }
    impl std::error::Error for TokenizerError {}
    #[doc = " Returns a list of [`Token`](struct.Token.html) structs."]
    #[doc = " You probably want [`parse`](../fn.parse.html) instead."]
    #[doc = ""]
    #[doc = " # Errors"]
    #[doc = ""]
    #[doc = " If the code passed is malformed from normal Lua expectations,"]
    #[doc = " a [`TokenizerError`](struct.TokenizerError.html) will be returned."]
    #[doc = ""]
    #[doc = " ```rust"]
    #[doc = " # use full_moon::tokenizer::tokens;"]
    #[doc = " assert!(tokens(\"local x = 1\").is_ok());"]
    #[doc = " assert!(tokens(\"local 4 = end\").is_ok()); // tokens does *not* check validity of code, only tokenizing"]
    #[doc = " assert!(tokens(\"--[[ Unclosed comment!\").is_err());"]
    #[doc = " ```"]
    pub fn tokens<'a>(code: &'a str) -> Result<Vec<Token<'a>>, TokenizerError> {
        let mut tokens = Vec::new();
        let mut position = Position {
            bytes: 0,
            character: 1,
            line: 1,
        };
        let mut next_is_new_line = false;
        while code.len() > position.bytes {
            match advance_whitespace(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            match advance_comment(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            match advance_number(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            match advance_quote(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            match advance_symbol(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            match advance_identifier(&code[position.bytes..]) {
                Ok(Some(advancement)) => {
                    let start_position = position;
                    for character in code[position.bytes..].chars().take(advancement.advance) {
                        if next_is_new_line {
                            next_is_new_line = false;
                            position.line += 1;
                            position.character = 1;
                        }
                        if character == '\n' {
                            next_is_new_line = true;
                        } else {
                            position.character += 1;
                        }
                        position.bytes += 1;
                    }
                    tokens.push(Token {
                        start_position: Arc::new(AtomicCell::new(start_position)),
                        end_position: Arc::new(AtomicCell::new(position)),
                        token_type: Arc::new(AtomicRefCell::new(advancement.token_type)),
                    });
                    continue;
                }
                Ok(None) => {}
                Err(error) => {
                    return Err(TokenizerError { error, position });
                }
            };
            return Err(TokenizerError {
                error: TokenizerErrorType::UnexpectedToken(
                    code.chars()
                        .nth(position.bytes)
                        .expect("text overflow while giving unexpected token error"),
                ),
                position,
            });
        }
        tokens.push(Token {
            start_position: Arc::new(AtomicCell::new(position)),
            end_position: Arc::new(AtomicCell::new(position)),
            token_type: Arc::new(AtomicRefCell::new(TokenType::Eof)),
        });
        Ok(tokens)
    }
    #[cfg(feature = "serde")]
    mod serde_arc_atomic_cell {
        use super::*;
        pub fn serialize<S: Serializer, T: Copy + Serialize>(
            this: &Arc<AtomicCell<T>>,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            this.load().serialize(serializer)
        }
        pub fn deserialize<'de, D: Deserializer<'de>, T: Copy + Deserialize<'de>>(
            deserializer: D,
        ) -> Result<Arc<AtomicCell<T>>, D::Error> {
            Ok(Arc::new(AtomicCell::new(T::deserialize(deserializer)?)))
        }
    }
    #[cfg(feature = "serde")]
    mod serde_arc_atomic_refcell {
        use super::*;
        pub fn serialize<S: Serializer, T: Serialize>(
            this: &Arc<AtomicRefCell<T>>,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            this.borrow().serialize(serializer)
        }
        pub fn deserialize<'de, D: Deserializer<'de>, T: Deserialize<'de>>(
            deserializer: D,
        ) -> Result<Arc<AtomicRefCell<T>>, D::Error> {
            Ok(Arc::new(AtomicRefCell::new(T::deserialize(deserializer)?)))
        }
    }
}
#[doc = " Used to create visitors that recurse through [`Ast`](ast/struct.Ast.html) nodes."]
pub mod visitors {
    use crate::ast;
    use crate::tokenizer::TokenReference;
    use std::borrow::Cow;
    pub(crate) trait Visit<'ast> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V);
    }
    pub(crate) trait VisitMut<'ast> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V);
    }
    impl<'ast, T: Visit<'ast>> Visit<'ast> for Vec<T> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            for item in self {
                item.visit(visitor);
            }
        }
    }
    impl<'ast, T: VisitMut<'ast>> VisitMut<'ast> for Vec<T> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            for item in self {
                item.visit_mut(visitor);
            }
        }
    }
    impl<'ast, T: Visit<'ast>> Visit<'ast> for Option<T> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            if let Some(item) = self {
                item.visit(visitor);
            }
        }
    }
    impl<'ast, T: VisitMut<'ast>> VisitMut<'ast> for Option<T> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            if let Some(item) = self {
                item.visit_mut(visitor);
            }
        }
    }
    impl<'ast, A: Visit<'ast>, B: Visit<'ast>> Visit<'ast> for (A, B) {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            self.0.visit(visitor);
            self.1.visit(visitor);
        }
    }
    impl<'ast, A: VisitMut<'ast>, B: VisitMut<'ast>> VisitMut<'ast> for (A, B) {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            self.0.visit_mut(visitor);
            self.1.visit_mut(visitor);
        }
    }
    impl<'ast, T: Clone + Visit<'ast>> Visit<'ast> for Cow<'ast, T> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            (**self).visit(visitor);
        }
    }
    impl<'ast, T: Clone + VisitMut<'ast>> VisitMut<'ast> for Cow<'ast, T> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            self.to_mut().visit_mut(visitor);
        }
    }
    impl<'ast, T: Visit<'ast>> Visit<'ast> for Box<T> {
        fn visit<V: Visitor<'ast>>(&self, visitor: &mut V) {
            (**self).visit(visitor);
        }
    }
    impl<'ast, T: VisitMut<'ast>> VisitMut<'ast> for Box<T> {
        fn visit_mut<V: VisitorMut<'ast>>(&mut self, visitor: &mut V) {
            (**self).visit_mut(visitor);
        }
    }
    #[doc = " A trait that implements functions to listen for specific nodes/tokens."]
    #[doc = " Unlike [`VisitorMut`](trait.VisitorMut.html), nodes/tokens passed are immutable."]
    #[doc = ""]
    #[doc = " ```rust"]
    #[doc = " # use full_moon::ast;"]
    #[doc = " # use full_moon::visitors::*;"]
    #[doc = " # fn main() -> Result<(), Box<std::error::Error>> {"]
    #[doc = " // A visitor that logs every local assignment made"]
    #[doc = " #[derive(Default)]"]
    #[doc = " struct LocalVariableVisitor {"]
    #[doc = "     names: Vec<String>,"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " impl<'ast> Visitor<'ast> for LocalVariableVisitor {"]
    #[doc = "     fn visit_local_assignment(&mut self, local_assignment: &ast::LocalAssignment<'ast>) {"]
    #[doc = "         self.names.extend(&mut local_assignment.iter_name_list().map(|name| name.to_string()));"]
    #[doc = "     }"]
    #[doc = " }"]
    #[doc = ""]
    #[doc = " let mut visitor = LocalVariableVisitor::default();"]
    #[doc = " visitor.visit_ast(&full_moon::parse(\"local x = 1; local y, z = 2, 3\")?);"]
    #[doc = " assert_eq!(visitor.names, vec![\"x\", \"y\", \"z\"]);"]
    #[doc = " # Ok(())"]
    #[doc = " # }"]
    #[doc = " ```"]
    pub trait Visitor<'ast> {
        #[doc = " Visit the nodes of an [`Ast`](../ast/struct.Ast.html)"]
        fn visit_ast(&mut self, ast: &ast::Ast<'ast>)
        where
            Self: Sized,
        {
            ast.nodes().visit(self);
        }
        #[allow(missing_docs)]
        fn visit_anonymous_call(&mut self, _node: &ast::FunctionArgs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_assignment(&mut self, _node: &ast::Assignment<'ast>) {}
        #[allow(missing_docs)]
        fn visit_bin_op(&mut self, _node: &ast::BinOpRhs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_block(&mut self, _node: &ast::Block<'ast>) {}
        #[allow(missing_docs)]
        fn visit_call(&mut self, _node: &ast::Call<'ast>) {}
        #[allow(missing_docs)]
        fn visit_do(&mut self, _node: &ast::Block<'ast>) {}
        #[allow(missing_docs)]
        fn visit_expression(&mut self, _node: &ast::Expression<'ast>) {}
        #[allow(missing_docs)]
        fn visit_field(&mut self, _node: &ast::Field<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_args(&mut self, _node: &ast::FunctionArgs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_body(&mut self, _node: &ast::FunctionBody<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_call(&mut self, _node: &ast::FunctionCall<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_declaration(&mut self, _node: &ast::FunctionDeclaration<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_name(&mut self, _node: &ast::FunctionName<'ast>) {}
        #[allow(missing_docs)]
        fn visit_generic_for(&mut self, _node: &ast::GenericFor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_if(&mut self, _node: &ast::If<'ast>) {}
        #[allow(missing_docs)]
        fn visit_index(&mut self, _node: &ast::Index<'ast>) {}
        #[allow(missing_docs)]
        fn visit_local_assignment(&mut self, _node: &ast::LocalAssignment<'ast>) {}
        #[allow(missing_docs)]
        fn visit_local_function(&mut self, _node: &ast::LocalFunction<'ast>) {}
        #[allow(missing_docs)]
        fn visit_last_stmt(&mut self, _node: &ast::LastStmt<'ast>) {}
        #[allow(missing_docs)]
        fn visit_method_call(&mut self, _node: &ast::MethodCall<'ast>) {}
        #[allow(missing_docs)]
        fn visit_numeric_for(&mut self, _node: &ast::NumericFor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_parameter(&mut self, _node: &ast::Parameter<'ast>) {}
        #[allow(missing_docs)]
        fn visit_prefix(&mut self, _node: &ast::Prefix<'ast>) {}
        #[allow(missing_docs)]
        fn visit_repeat(&mut self, _node: &ast::Repeat<'ast>) {}
        #[allow(missing_docs)]
        fn visit_stmt(&mut self, _node: &ast::Stmt<'ast>) {}
        #[allow(missing_docs)]
        fn visit_suffix(&mut self, _node: &ast::Suffix<'ast>) {}
        #[allow(missing_docs)]
        fn visit_table_constructor(&mut self, _node: &ast::TableConstructor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_un_op(&mut self, _node: &ast::UnOp<'ast>) {}
        #[allow(missing_docs)]
        fn visit_value(&mut self, _node: &ast::Value<'ast>) {}
        #[allow(missing_docs)]
        fn visit_var(&mut self, _node: &ast::Var<'ast>) {}
        #[allow(missing_docs)]
        fn visit_var_expression(&mut self, _node: &ast::VarExpression<'ast>) {}
        #[allow(missing_docs)]
        fn visit_while(&mut self, _node: &ast::While<'ast>) {}
        #[allow(missing_docs)]
        fn visit_eof(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_identifier(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_multi_line_comment(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_number(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_single_line_comment(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_string_literal(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_symbol(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_token(&mut self, _token: &TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_whitespace(&mut self, _token: &TokenReference<'ast>) {}
    }
    #[doc = " A trait that implements functions to listen for specific nodes/tokens."]
    #[doc = " Unlike [`Visitor`](trait.Visitor.html), nodes/tokens passed are mutable."]
    pub trait VisitorMut<'ast> {
        #[doc = " Visit the nodes of an [`Ast`](../ast/struct.Ast.html)"]
        fn visit_ast(&mut self, ast: &mut ast::Ast<'ast>)
        where
            Self: Sized,
        {
            ast.nodes_mut().visit_mut(self);
        }
        #[allow(missing_docs)]
        fn visit_anonymous_call(&mut self, _node: &mut ast::FunctionArgs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_assignment(&mut self, _node: &mut ast::Assignment<'ast>) {}
        #[allow(missing_docs)]
        fn visit_bin_op(&mut self, _node: &mut ast::BinOpRhs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_block(&mut self, _node: &mut ast::Block<'ast>) {}
        #[allow(missing_docs)]
        fn visit_call(&mut self, _node: &mut ast::Call<'ast>) {}
        #[allow(missing_docs)]
        fn visit_do(&mut self, _node: &mut ast::Block<'ast>) {}
        #[allow(missing_docs)]
        fn visit_expression(&mut self, _node: &mut ast::Expression<'ast>) {}
        #[allow(missing_docs)]
        fn visit_field(&mut self, _node: &mut ast::Field<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_args(&mut self, _node: &mut ast::FunctionArgs<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_body(&mut self, _node: &mut ast::FunctionBody<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_call(&mut self, _node: &mut ast::FunctionCall<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_declaration(&mut self, _node: &mut ast::FunctionDeclaration<'ast>) {}
        #[allow(missing_docs)]
        fn visit_function_name(&mut self, _node: &mut ast::FunctionName<'ast>) {}
        #[allow(missing_docs)]
        fn visit_generic_for(&mut self, _node: &mut ast::GenericFor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_if(&mut self, _node: &mut ast::If<'ast>) {}
        #[allow(missing_docs)]
        fn visit_index(&mut self, _node: &mut ast::Index<'ast>) {}
        #[allow(missing_docs)]
        fn visit_local_assignment(&mut self, _node: &mut ast::LocalAssignment<'ast>) {}
        #[allow(missing_docs)]
        fn visit_local_function(&mut self, _node: &mut ast::LocalFunction<'ast>) {}
        #[allow(missing_docs)]
        fn visit_last_stmt(&mut self, _node: &mut ast::LastStmt<'ast>) {}
        #[allow(missing_docs)]
        fn visit_method_call(&mut self, _node: &mut ast::MethodCall<'ast>) {}
        #[allow(missing_docs)]
        fn visit_numeric_for(&mut self, _node: &mut ast::NumericFor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_parameter(&mut self, _node: &mut ast::Parameter<'ast>) {}
        #[allow(missing_docs)]
        fn visit_prefix(&mut self, _node: &mut ast::Prefix<'ast>) {}
        #[allow(missing_docs)]
        fn visit_repeat(&mut self, _node: &mut ast::Repeat<'ast>) {}
        #[allow(missing_docs)]
        fn visit_stmt(&mut self, _node: &mut ast::Stmt<'ast>) {}
        #[allow(missing_docs)]
        fn visit_suffix(&mut self, _node: &mut ast::Suffix<'ast>) {}
        #[allow(missing_docs)]
        fn visit_table_constructor(&mut self, _node: &mut ast::TableConstructor<'ast>) {}
        #[allow(missing_docs)]
        fn visit_un_op(&mut self, _node: &mut ast::UnOp<'ast>) {}
        #[allow(missing_docs)]
        fn visit_value(&mut self, _node: &mut ast::Value<'ast>) {}
        #[allow(missing_docs)]
        fn visit_var(&mut self, _node: &mut ast::Var<'ast>) {}
        #[allow(missing_docs)]
        fn visit_var_expression(&mut self, _node: &mut ast::VarExpression<'ast>) {}
        #[allow(missing_docs)]
        fn visit_while(&mut self, _node: &mut ast::While<'ast>) {}
        #[allow(missing_docs)]
        fn visit_eof(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_identifier(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_multi_line_comment(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_number(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_single_line_comment(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_string_literal(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_symbol(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_token(&mut self, _token: &mut TokenReference<'ast>) {}
        #[allow(missing_docs)]
        fn visit_whitespace(&mut self, _token: &mut TokenReference<'ast>) {}
    }
}
use std::fmt;
#[doc = " An error type that consists of both [`AstError`](ast/enum.AstError.html) and [`TokenizerError`](tokenizer/enum.TokenizerError.html)"]
#[doc = " Used by [`parse`](fn.parse)"]
pub enum Error<'a> {
    #[doc = " Triggered if there's an issue creating an AST, but tokenizing must have succeeded"]
    AstError(ast::AstError<'a>),
    #[doc = " Triggered if there's an issue when tokenizing, and an AST can't be made"]
    TokenizerError(tokenizer::TokenizerError),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<'a> ::std::clone::Clone for Error<'a> {
    #[inline]
    fn clone(&self) -> Error<'a> {
        match (&*self,) {
            (&Error::AstError(ref __self_0),) => {
                Error::AstError(::std::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::TokenizerError(ref __self_0),) => {
                Error::TokenizerError(::std::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<'a> ::std::fmt::Debug for Error<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match (&*self,) {
            (&Error::AstError(ref __self_0),) => {
                let mut debug_trait_builder = f.debug_tuple("AstError");
                let _ = debug_trait_builder.field(&&(*__self_0));
                debug_trait_builder.finish()
            }
            (&Error::TokenizerError(ref __self_0),) => {
                let mut debug_trait_builder = f.debug_tuple("TokenizerError");
                let _ = debug_trait_builder.field(&&(*__self_0));
                debug_trait_builder.finish()
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl<'a> ::std::cmp::PartialEq for Error<'a> {
    #[inline]
    fn eq(&self, other: &Error<'a>) -> bool {
        {
            let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
            let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Error::AstError(ref __self_0), &Error::AstError(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    (
                        &Error::TokenizerError(ref __self_0),
                        &Error::TokenizerError(ref __arg_1_0),
                    ) => (*__self_0) == (*__arg_1_0),
                    _ => unsafe { ::std::intrinsics::unreachable() },
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &Error<'a>) -> bool {
        {
            let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
            let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&Error::AstError(ref __self_0), &Error::AstError(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    (
                        &Error::TokenizerError(ref __self_0),
                        &Error::TokenizerError(ref __arg_1_0),
                    ) => (*__self_0) != (*__arg_1_0),
                    _ => unsafe { ::std::intrinsics::unreachable() },
                }
            } else {
                true
            }
        }
    }
}
impl<'a> fmt::Display for Error<'a> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Error::AstError(error) => formatter.write_fmt(::std::fmt::Arguments::new_v1(
                &["error occurred while creating ast: "],
                &match (&error,) {
                    (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                },
            )),
            Error::TokenizerError(error) => formatter.write_fmt(::std::fmt::Arguments::new_v1(
                &["error occurred while tokenizing: "],
                &match (&error,) {
                    (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                },
            )),
        }
    }
}
impl<'a> std::error::Error for Error<'a> {}
#[doc = " Creates an [`Ast`](ast/struct.Ast.html) from Lua code"]
#[doc = ""]
#[doc = " # Errors"]
#[doc = " If the code passed cannot be tokenized, a TokenizerError will be returned."]
#[doc = " If the code passed is not valid Lua 5.1 code, an AstError will be returned,"]
#[doc = " specifically AstError::UnexpectedToken."]
#[doc = ""]
#[doc = " ```rust"]
#[doc = " assert!(full_moon::parse(\"local x = 1\").is_ok());"]
#[doc = " assert!(full_moon::parse(\"local x = \").is_err());"]
#[doc = " ```"]
pub fn parse(code: &str) -> Result<ast::Ast, Error> {
    let tokens = tokenizer::tokens(code).map_err(Error::TokenizerError)?;
    ast::Ast::from_tokens(tokens).map_err(Error::AstError)
}
#[doc = " Prints back Lua code from an [Ast](ast/struct.Ast.html)"]
pub fn print(ast: &ast::Ast) -> String {
    ast.iter_tokens()
        .fold(String::new(), |acc, token| acc + &token.to_string())
}
